// ===== charger\ISO15118_chargerImpl.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2022-2023 chargebyte GmbH
// Copyright (C) 2022-2023 Contributors to EVerest
#include "ISO15118_chargerImpl.hpp"
#include "log.hpp"
#include "v2g_ctx.hpp"

const std::string CERTS_SUB_DIR = "certs"; // relativ path of the certs

using namespace std::chrono_literals;
using BidiMode = types::iso15118::SaeJ2847BidiMode;

namespace module {
namespace charger {

void ISO15118_chargerImpl::init() {
    if (!v2g_ctx) {
        dlog(DLOG_LEVEL_ERROR, "v2g_ctx not created");
        return;
    }

    /* Configure if_name and auth_mode */
    v2g_ctx->if_name = mod->config.device.data();
    dlog(DLOG_LEVEL_DEBUG, "if_name %s", v2g_ctx->if_name);

    /* Configure hlc_protocols */
    if (mod->config.supported_DIN70121 == true) {
        v2g_ctx->supported_protocols |= (1 << V2G_PROTO_DIN70121);
    }
    if (mod->config.supported_ISO15118_2 == true) {
        v2g_ctx->supported_protocols |= (1 << V2G_PROTO_ISO15118_2013);
    }

    /* Configure tls_security */
    if (mod->config.tls_security == "force") {
        v2g_ctx->tls_security = TLS_SECURITY_FORCE;
        dlog(DLOG_LEVEL_DEBUG, "tls_security force");
    } else if (mod->config.tls_security == "allow") {
        v2g_ctx->tls_security = TLS_SECURITY_ALLOW;
        dlog(DLOG_LEVEL_DEBUG, "tls_security allow");
    } else {
        v2g_ctx->tls_security = TLS_SECURITY_PROHIBIT;
        dlog(DLOG_LEVEL_DEBUG, "tls_security prohibit");
    }

    v2g_ctx->terminate_connection_on_failed_response = mod->config.terminate_connection_on_failed_response;

    v2g_ctx->tls_key_logging = mod->config.tls_key_logging;
    v2g_ctx->tls_key_logging_path = mod->config.tls_key_logging_path;

    if (mod->config.tls_key_logging == true) {
        dlog(DLOG_LEVEL_DEBUG, "tls-key-logging enabled (path: %s)", mod->config.tls_key_logging_path.c_str());
    }

    v2g_ctx->network_read_timeout_tls = mod->config.tls_timeout;

    /* Configure if the contract certificate chain should be verified locally */
    v2g_ctx->session.verify_contract_cert_chain = mod->config.verify_contract_cert_chain;

    v2g_ctx->session.auth_timeout_eim = mod->config.auth_timeout_eim;
    v2g_ctx->session.auth_timeout_pnc = mod->config.auth_timeout_pnc;
}

void ISO15118_chargerImpl::ready() {
}

void ISO15118_chargerImpl::handle_setup(
    types::iso15118::EVSEID& evse_id,
    std::vector<types::iso15118::SupportedEnergyMode>& supported_energy_transfer_modes,
    types::iso15118::SaeJ2847BidiMode& sae_j2847_mode, bool& debug_mode) {

    uint8_t len = evse_id.evse_id.length();
    if (len < iso2_EVSEID_CHARACTER_SIZE) {
        memcpy(v2g_ctx->evse_v2g_data.evse_id.bytes, reinterpret_cast<uint8_t*>(evse_id.evse_id.data()), len);
        v2g_ctx->evse_v2g_data.evse_id.bytesLen = len;
    } else {
        dlog(DLOG_LEVEL_WARNING, "EVSEID_CHARACTER_SIZE exceeded (received: %u, max: %u)", len,
             iso2_EVSEID_CHARACTER_SIZE);
    }

    if (v2g_ctx->hlc_pause_active != true) {
        uint16_t& energyArrayLen =
            (v2g_ctx->evse_v2g_data.charge_service.SupportedEnergyTransferMode.EnergyTransferMode.arrayLen);
        iso2_EnergyTransferModeType* energyArray =
            v2g_ctx->evse_v2g_data.charge_service.SupportedEnergyTransferMode.EnergyTransferMode.array;
        energyArrayLen = 0;

        v2g_ctx->is_dc_charger = true;

        for (const auto& mode : supported_energy_transfer_modes) {

            if (mode.bidirectional) {
                dlog(DLOG_LEVEL_INFO, "Ignoring bidirectional SupportedEnergyTransferMode");
                continue;
            }

            switch (mode.energy_transfer_mode) {
            case types::iso15118::EnergyTransferMode::AC_single_phase_core:
                energyArray[(energyArrayLen)++] = iso2_EnergyTransferModeType_AC_single_phase_core;
                v2g_ctx->is_dc_charger = false;
                break;
            case types::iso15118::EnergyTransferMode::AC_three_phase_core:
                energyArray[(energyArrayLen)++] = iso2_EnergyTransferModeType_AC_three_phase_core;
                v2g_ctx->is_dc_charger = false;
                break;
            case types::iso15118::EnergyTransferMode::DC_core:
                energyArray[(energyArrayLen)++] = iso2_EnergyTransferModeType_DC_core;
                break;
            case types::iso15118::EnergyTransferMode::DC_extended:
                energyArray[(energyArrayLen)++] = iso2_EnergyTransferModeType_DC_extended;
                break;
            case types::iso15118::EnergyTransferMode::DC_combo_core:
                energyArray[(energyArrayLen)++] = iso2_EnergyTransferModeType_DC_combo_core;
                break;
            case types::iso15118::EnergyTransferMode::DC_unique:
                energyArray[(energyArrayLen)++] = iso2_EnergyTransferModeType_DC_unique;
                break;
            default:
                if (energyArrayLen == 0) {

                    dlog(DLOG_LEVEL_WARNING, "Unable to configure SupportedEnergyTransferMode %s",
                         types::iso15118::energy_transfer_mode_to_string(mode.energy_transfer_mode).c_str());
                }
                break;
            }
        }

        if (mod->config.supported_DIN70121 == true and v2g_ctx->is_dc_charger == false) {
            v2g_ctx->supported_protocols &= ~(1 << V2G_PROTO_DIN70121);
            dlog(DLOG_LEVEL_WARNING, "Removed DIN70121 from the list of supported protocols as AC is enabled");
        }
    }

    v2g_ctx->debugMode = debug_mode;

    if (sae_j2847_mode == BidiMode::V2H || sae_j2847_mode == BidiMode::V2G) {
        struct iso2_ServiceType sae_service;

        init_iso2_ServiceType(&sae_service);

        sae_service.FreeService = 1;
        sae_service.ServiceCategory = iso2_serviceCategoryType_OtherCustom;

        if (sae_j2847_mode == BidiMode::V2H) {
            sae_service.ServiceID = 28472;
            const std::string service_name = "SAE J2847/2 V2H";
            memcpy(sae_service.ServiceName.characters, reinterpret_cast<const char*>(service_name.data()),
                   service_name.length());
            sae_service.ServiceName.charactersLen = service_name.length();
            sae_service.ServiceName_isUsed = true;
        } else {
            sae_service.ServiceID = 28473;
            const std::string service_name = "SAE J2847/2 V2G";
            memcpy(sae_service.ServiceName.characters, reinterpret_cast<const char*>(service_name.data()),
                   service_name.length());
            sae_service.ServiceName.charactersLen = service_name.length();
            sae_service.ServiceName_isUsed = true;
        }

        add_service_to_service_list(v2g_ctx, sae_service);
    }
}

void ISO15118_chargerImpl::handle_session_setup(std::vector<types::iso15118::PaymentOption>& payment_options,
                                                bool& supported_certificate_service,
                                                bool& central_contract_validation_allowed) {
    if (v2g_ctx->hlc_pause_active != true) {
        v2g_ctx->evse_v2g_data.payment_option_list_len = 0;

        for (auto option : payment_options) {

            if (option == types::iso15118::PaymentOption::Contract) {
                v2g_ctx->evse_v2g_data.payment_option_list[v2g_ctx->evse_v2g_data.payment_option_list_len] =
                    iso2_paymentOptionType_Contract;
                v2g_ctx->evse_v2g_data.payment_option_list_len++;
            } else if (option == types::iso15118::PaymentOption::ExternalPayment) {
                v2g_ctx->evse_v2g_data.payment_option_list[v2g_ctx->evse_v2g_data.payment_option_list_len] =
                    iso2_paymentOptionType_ExternalPayment;
                v2g_ctx->evse_v2g_data.payment_option_list_len++;
            } else if (v2g_ctx->evse_v2g_data.payment_option_list_len == 0) {
                dlog(DLOG_LEVEL_WARNING, "Unable to configure PaymentOptions %s",
                     types::iso15118::payment_option_to_string(option).c_str());
            }
        }
    }

    const auto pnc_enabled = ((v2g_ctx->evse_v2g_data.payment_option_list[0] == iso2_paymentOptionType_Contract) or
                              (v2g_ctx->evse_v2g_data.payment_option_list[1] == iso2_paymentOptionType_Contract));

    if (pnc_enabled and supported_certificate_service) {
        // For setting "Certificate" in ServiceList in ServiceDiscoveryRes
        struct iso2_ServiceType cert_service;

        init_iso2_ServiceType(&cert_service);

        const std::string service_name = "Certificate";
        const int16_t cert_parameter_set_id[] = {1}; // parameter-set-ID 1: "Installation" service. TODO: Support of the
                                                     // "Update" service (parameter-set-ID 2)

        cert_service.FreeService = 1; // true
        cert_service.ServiceID = 2;   // as defined in ISO 15118-2
        cert_service.ServiceCategory = iso2_serviceCategoryType_ContractCertificate;
        memcpy(cert_service.ServiceName.characters, reinterpret_cast<const char*>(service_name.data()),
               service_name.length());

        cert_service.ServiceName.charactersLen = service_name.length();
        cert_service.ServiceName_isUsed = true;

        add_service_to_service_list(v2g_ctx, cert_service, cert_parameter_set_id,
                                    sizeof(cert_parameter_set_id) / sizeof(cert_parameter_set_id[0]));
    } else {
        remove_service_from_service_list_if_exists(v2g_ctx, V2G_SERVICE_ID_CERTIFICATE);
    }

    v2g_ctx->evse_v2g_data.central_contract_validation_allowed = central_contract_validation_allowed;
}

void ISO15118_chargerImpl::handle_authorization_response(
    types::authorization::AuthorizationStatus& authorization_status,
    types::authorization::CertificateStatus& certificate_status) {

    if (v2g_ctx->session.iso_selected_payment_option == iso2_paymentOptionType_ExternalPayment) {
        if (authorization_status == types::authorization::AuthorizationStatus::Accepted) {
            v2g_ctx->evse_v2g_data.evse_processing[PHASE_AUTH] = (uint8_t)iso2_EVSEProcessingType_Finished;
        }
    } else if (v2g_ctx->session.iso_selected_payment_option == iso2_paymentOptionType_Contract) {
        v2g_ctx->session.certificate_status = certificate_status;
        v2g_ctx->evse_v2g_data.evse_processing[PHASE_AUTH] = static_cast<uint8_t>(iso2_EVSEProcessingType_Finished);

        if (authorization_status != types::authorization::AuthorizationStatus::Accepted) {
            v2g_ctx->session.authorization_rejected = true;
        }
    }
}

void ISO15118_chargerImpl::handle_ac_contactor_closed(bool& status) {
    /* signal changes to possible waiters, according to man page, it never returns an error code */
    pthread_mutex_lock(&v2g_ctx->mqtt_lock);
    v2g_ctx->contactor_is_closed = status;
    pthread_cond_signal(&v2g_ctx->mqtt_cond);
    /* unlock */
    pthread_mutex_unlock(&v2g_ctx->mqtt_lock);
}

void ISO15118_chargerImpl::handle_dlink_ready(bool& value) {
    // FIXME: dlink_ready(true) is ignored for now
    // If dlink becomes not ready (false), stop TCP connection in the read thread
    if (!value) {
        v2g_ctx->is_connection_terminated = true;
    }
}

void ISO15118_chargerImpl::handle_cable_check_finished(bool& status) {
    if (status == true) {
        v2g_ctx->evse_v2g_data.evse_processing[PHASE_ISOLATION] = (uint8_t)iso2_EVSEProcessingType_Finished;
    } else {
        v2g_ctx->evse_v2g_data.evse_processing[PHASE_ISOLATION] = (uint8_t)iso2_EVSEProcessingType_Ongoing;
    }
}

void ISO15118_chargerImpl::handle_receipt_is_required(bool& receipt_required) {
    v2g_ctx->evse_v2g_data.receipt_required = (int)receipt_required;
}

void ISO15118_chargerImpl::handle_stop_charging(bool& stop) {
    // FIXME we need to use locks on v2g-ctx in all commands as they are running in different threads

    if (stop) {
        // spawn new thread to not block command handler
        std::thread([stop] {
            // try to gracefully shutdown charging session
            v2g_ctx->evse_v2g_data.evse_notification = iso2_EVSENotificationType_StopCharging;
            memset(v2g_ctx->evse_v2g_data.evse_status_code, iso2_DC_EVSEStatusCodeType_EVSE_Shutdown,
                   sizeof(v2g_ctx->evse_v2g_data.evse_status_code));

            int i;
            bool timeout_reached = true;
            // allow 10 seconds for graceful shutdown
            for (i = 0; i < 10; i++) {
                if (v2g_ctx->is_connection_terminated) {
                    timeout_reached = false;
                    break;
                }
                std::this_thread::sleep_for(1s);
            }

            // If it did not stop within timeout, stop session using FAILED reply
            if (timeout_reached) {
                v2g_ctx->stop_hlc = stop;
            }
        }).detach();
    } else {
        v2g_ctx->stop_hlc = false;
    }
}

void ISO15118_chargerImpl::handle_pause_charging(bool& pause) {
    EVLOG_warning << "Pause initialized by the charger is not supported in DIN70121 and ISO15118-2";
}

void ISO15118_chargerImpl::handle_set_charging_parameters(types::iso15118::SetupPhysicalValues& physical_values) {

    if (physical_values.ac_nominal_voltage.has_value()) {
        populate_physical_value_float(&v2g_ctx->evse_v2g_data.evse_nominal_voltage,
                                      physical_values.ac_nominal_voltage.value(), 1, iso2_unitSymbolType_V);
    }

    if (physical_values.dc_current_regulation_tolerance.has_value()) {
        populate_physical_value_float(&v2g_ctx->evse_v2g_data.evse_current_regulation_tolerance,
                                      physical_values.dc_current_regulation_tolerance.value(), 1,
                                      iso2_unitSymbolType_A);
        v2g_ctx->evse_v2g_data.evse_current_regulation_tolerance_is_used = 1;
    }

    if (physical_values.dc_peak_current_ripple.has_value()) {
        populate_physical_value_float(&v2g_ctx->evse_v2g_data.evse_peak_current_ripple,
                                      physical_values.dc_peak_current_ripple.value(), 1, iso2_unitSymbolType_A);
    }

    if (physical_values.dc_energy_to_be_delivered.has_value()) {
        populate_physical_value(&v2g_ctx->evse_v2g_data.evse_energy_to_be_delivered,
                                physical_values.dc_energy_to_be_delivered.value(), iso2_unitSymbolType_Wh);
        v2g_ctx->evse_v2g_data.evse_energy_to_be_delivered_is_used = 1;
    }
}

void ISO15118_chargerImpl::handle_update_ac_max_current(double& max_current) {
    v2g_ctx->basic_config.evse_ac_current_limit = max_current;
}

void ISO15118_chargerImpl::handle_update_dc_maximum_limits(types::iso15118::DcEvseMaximumLimits& maximum_limits) {
    if (maximum_limits.evse_maximum_current_limit > 300.) {
        populate_physical_value_float(&v2g_ctx->evse_v2g_data.evse_maximum_current_limit,
                                      maximum_limits.evse_maximum_current_limit, 1, iso2_unitSymbolType_A);
    } else {
        populate_physical_value_float(&v2g_ctx->evse_v2g_data.evse_maximum_current_limit,
                                      maximum_limits.evse_maximum_current_limit, 2, iso2_unitSymbolType_A);
    }
    v2g_ctx->evse_v2g_data.evse_maximum_current_limit_is_used = 1;

    populate_physical_value(&v2g_ctx->evse_v2g_data.evse_maximum_power_limit, maximum_limits.evse_maximum_power_limit,
                            iso2_unitSymbolType_W);
    v2g_ctx->evse_v2g_data.evse_maximum_power_limit_is_used = 1;

    populate_physical_value_float(&v2g_ctx->evse_v2g_data.evse_maximum_voltage_limit,
                                  maximum_limits.evse_maximum_voltage_limit, 1, iso2_unitSymbolType_V);
    v2g_ctx->evse_v2g_data.evse_maximum_voltage_limit_is_used = 1;
}

void ISO15118_chargerImpl::handle_update_dc_minimum_limits(types::iso15118::DcEvseMinimumLimits& minimum_limits) {

    populate_physical_value_float(&v2g_ctx->evse_v2g_data.evse_minimum_current_limit,
                                  static_cast<long long int>(minimum_limits.evse_minimum_current_limit), 1,
                                  iso2_unitSymbolType_A);
    populate_physical_value_float(&v2g_ctx->evse_v2g_data.evse_minimum_voltage_limit,
                                  static_cast<long long int>(minimum_limits.evse_minimum_voltage_limit), 1,
                                  iso2_unitSymbolType_V);
}

void ISO15118_chargerImpl::handle_update_isolation_status(types::iso15118::IsolationStatus& isolation_status) {
    v2g_ctx->evse_v2g_data.evse_isolation_status = (uint8_t)isolation_status;
    v2g_ctx->evse_v2g_data.evse_isolation_status_is_used = 1;
}

void ISO15118_chargerImpl::handle_update_dc_present_values(
    types::iso15118::DcEvsePresentVoltageCurrent& present_voltage_current) {
    populate_physical_value_float(&v2g_ctx->evse_v2g_data.evse_present_voltage,
                                  present_voltage_current.evse_present_voltage, 1, iso2_unitSymbolType_V);

    if (present_voltage_current.evse_present_current.has_value()) {
        populate_physical_value_float(&v2g_ctx->evse_v2g_data.evse_present_current,
                                      static_cast<float>(present_voltage_current.evse_present_current.value()), 1,
                                      iso2_unitSymbolType_A);
    }
}

void ISO15118_chargerImpl::handle_update_meter_info(types::powermeter::Powermeter& powermeter) {
    // Signal for ChargingStatus and CurrentDemand that MeterInfo is used
    v2g_ctx->meter_info.meter_info_is_used = 1;
    v2g_ctx->meter_info.meter_reading = powermeter.energy_Wh_import.total;

    if (powermeter.meter_id) {
        uint8_t len = powermeter.meter_id->length();
        if (len < iso2_MeterID_CHARACTER_SIZE) {
            memcpy(v2g_ctx->meter_info.meter_id.bytes, powermeter.meter_id->c_str(), len);
            v2g_ctx->meter_info.meter_id.bytesLen = len;
        } else {
            dlog(DLOG_LEVEL_WARNING, "MeterID_CHARACTER_SIZEexceeded (received: %u, max: %u)", len,
                 iso2_MeterID_CHARACTER_SIZE);
        }
    }
}

void ISO15118_chargerImpl::handle_send_error(types::iso15118::EvseError& error) {
    switch (error) {
    case types::iso15118::EvseError::Error_Contactor:
        break;
    case types::iso15118::EvseError::Error_RCD:
        v2g_ctx->evse_v2g_data.rcd = 1;
        break;
    case types::iso15118::EvseError::Error_UtilityInterruptEvent:
        memset(v2g_ctx->evse_v2g_data.evse_status_code, (int)iso2_DC_EVSEStatusCodeType_EVSE_UtilityInterruptEvent,
               sizeof(v2g_ctx->evse_v2g_data.evse_status_code));
        break;
    case types::iso15118::EvseError::Error_Malfunction:
        memset(v2g_ctx->evse_v2g_data.evse_status_code, (int)iso2_DC_EVSEStatusCodeType_EVSE_Malfunction,
               sizeof(v2g_ctx->evse_v2g_data.evse_status_code));
        break;
    case types::iso15118::EvseError::Error_EmergencyShutdown:
        /* signal changes to possible waiters, according to man page, it never returns an error code */
        pthread_mutex_lock(&v2g_ctx->mqtt_lock);
        v2g_ctx->intl_emergency_shutdown = true;
        pthread_cond_signal(&v2g_ctx->mqtt_cond);
        /* unlock */
        pthread_mutex_unlock(&v2g_ctx->mqtt_lock);
        break;
    default:
        break;
    }
}

void ISO15118_chargerImpl::handle_reset_error() {
    v2g_ctx->evse_v2g_data.rcd = 0;

    v2g_ctx->evse_v2g_data.evse_status_code[PHASE_INIT] = iso2_DC_EVSEStatusCodeType_EVSE_NotReady;
    v2g_ctx->evse_v2g_data.evse_status_code[PHASE_AUTH] = iso2_DC_EVSEStatusCodeType_EVSE_NotReady;
    v2g_ctx->evse_v2g_data.evse_status_code[PHASE_PARAMETER] = iso2_DC_EVSEStatusCodeType_EVSE_Ready; // [V2G-DC-453]
    v2g_ctx->evse_v2g_data.evse_status_code[PHASE_ISOLATION] =
        iso2_DC_EVSEStatusCodeType_EVSE_IsolationMonitoringActive;
    v2g_ctx->evse_v2g_data.evse_status_code[PHASE_PRECHARGE] = iso2_DC_EVSEStatusCodeType_EVSE_Ready;
    v2g_ctx->evse_v2g_data.evse_status_code[PHASE_CHARGE] = iso2_DC_EVSEStatusCodeType_EVSE_Ready;
    v2g_ctx->evse_v2g_data.evse_status_code[PHASE_WELDING] = iso2_DC_EVSEStatusCodeType_EVSE_NotReady;
    v2g_ctx->evse_v2g_data.evse_status_code[PHASE_STOP] = iso2_DC_EVSEStatusCodeType_EVSE_NotReady;

    // Todo(sl): check if emergency should be cleared here?
}

} // namespace charger
} // namespace module


// ===== charger\ISO15118_chargerImpl.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright Pionix GmbH and Contributors to EVerest
#ifndef CHARGER_ISO15118_CHARGER_IMPL_HPP
#define CHARGER_ISO15118_CHARGER_IMPL_HPP

//
// AUTO GENERATED - MARKED REGIONS WILL BE KEPT
// template version 3
//

#include <generated/interfaces/ISO15118_charger/Implementation.hpp>

#include "../EvseV2G.hpp"

// ev@75ac1216-19eb-4182-a85c-820f1fc2c091:v1
#include "v2g.hpp"
extern struct v2g_context* v2g_ctx;
// ev@75ac1216-19eb-4182-a85c-820f1fc2c091:v1

namespace module {
namespace charger {

struct Conf {};

class ISO15118_chargerImpl : public ISO15118_chargerImplBase {
public:
    ISO15118_chargerImpl() = delete;
    ISO15118_chargerImpl(Everest::ModuleAdapter* ev, const Everest::PtrContainer<EvseV2G>& mod, Conf& config) :
        ISO15118_chargerImplBase(ev, "charger"), mod(mod), config(config){};

    // ev@8ea32d28-373f-4c90-ae5e-b4fcc74e2a61:v1
    // insert your public definitions here
    // ev@8ea32d28-373f-4c90-ae5e-b4fcc74e2a61:v1

protected:
    // command handler functions (virtual)
    virtual void handle_setup(types::iso15118::EVSEID& evse_id,
                              std::vector<types::iso15118::SupportedEnergyMode>& supported_energy_transfer_modes,
                              types::iso15118::SaeJ2847BidiMode& sae_j2847_mode, bool& debug_mode) override;
    virtual void handle_set_charging_parameters(types::iso15118::SetupPhysicalValues& physical_values) override;
    virtual void handle_session_setup(std::vector<types::iso15118::PaymentOption>& payment_options,
                                      bool& supported_certificate_service,
                                      bool& central_contract_validation_allowed) override;
    virtual void handle_authorization_response(types::authorization::AuthorizationStatus& authorization_status,
                                               types::authorization::CertificateStatus& certificate_status) override;
    virtual void handle_ac_contactor_closed(bool& status) override;
    virtual void handle_dlink_ready(bool& value) override;
    virtual void handle_cable_check_finished(bool& status) override;
    virtual void handle_receipt_is_required(bool& receipt_required) override;
    virtual void handle_stop_charging(bool& stop) override;
    virtual void handle_pause_charging(bool& pause) override;
    virtual void handle_update_ac_max_current(double& max_current) override;
    virtual void handle_update_dc_maximum_limits(types::iso15118::DcEvseMaximumLimits& maximum_limits) override;
    virtual void handle_update_dc_minimum_limits(types::iso15118::DcEvseMinimumLimits& minimum_limits) override;
    virtual void handle_update_isolation_status(types::iso15118::IsolationStatus& isolation_status) override;
    virtual void
    handle_update_dc_present_values(types::iso15118::DcEvsePresentVoltageCurrent& present_voltage_current) override;
    virtual void handle_update_meter_info(types::powermeter::Powermeter& powermeter) override;
    virtual void handle_send_error(types::iso15118::EvseError& error) override;
    virtual void handle_reset_error() override;

    // ev@d2d1847a-7b88-41dd-ad07-92785f06f5c4:v1
    // insert your protected definitions here
    // ev@d2d1847a-7b88-41dd-ad07-92785f06f5c4:v1

private:
    const Everest::PtrContainer<EvseV2G>& mod;
    const Conf& config;

    virtual void init() override;
    virtual void ready() override;

    // ev@3370e4dd-95f4-47a9-aaec-ea76f34a66c9:v1
    // insert your private definitions here
    // ev@3370e4dd-95f4-47a9-aaec-ea76f34a66c9:v1
};

// ev@3d7da0ad-02c2-493d-9920-0bbbd56b9876:v1
// insert other definitions here
// ev@3d7da0ad-02c2-493d-9920-0bbbd56b9876:v1

} // namespace charger
} // namespace module

#endif // CHARGER_ISO15118_CHARGER_IMPL_HPP


// ===== connection\connection.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2022-2023 chargebyte GmbH
// Copyright (C) 2022-2023 Contributors to EVerest

#include "connection.hpp"
#include "log.hpp"
#include "tls_connection.hpp"
#include "tools.hpp"
#include "v2g_server.hpp"

#include <arpa/inet.h>
#include <cstring>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fstream>
#include <inttypes.h>
#include <iostream>
#include <net/if.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <sys/socket.h>
#include <time.h>
#include <unistd.h>

#define DEFAULT_SOCKET_BACKLOG        3
#define DEFAULT_TCP_PORT              61341
#define DEFAULT_TLS_PORT              64109
#define ERROR_SESSION_ALREADY_STARTED 2

/*!
 * \brief connection_create_socket This function creates a tcp/tls socket
 * \param sockaddr to bind the socket to an interface
 * \return Returns \c 0 on success, otherwise \c -1
 */
static int connection_create_socket(struct sockaddr_in6* sockaddr) {
    socklen_t addrlen = sizeof(*sockaddr);
    int s, enable = 1;
    static bool error_once = false;

    /* create socket */
    s = socket(AF_INET6, SOCK_STREAM, 0);
    if (s == -1) {
        if (!error_once) {
            dlog(DLOG_LEVEL_ERROR, "socket() failed: %s", strerror(errno));
            error_once = true;
        }
        return -1;
    }

    if (setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) == -1) {
        if (!error_once) {
            dlog(DLOG_LEVEL_ERROR, "setsockopt(SO_REUSEPORT) failed: %s", strerror(errno));
            error_once = true;
        }
        close(s);
        return -1;
    }

    /* bind it to interface */
    if (bind(s, reinterpret_cast<struct sockaddr*>(sockaddr), addrlen) == -1) {
        if (!error_once) {
            dlog(DLOG_LEVEL_WARNING, "bind() failed: %s", strerror(errno));
            dlog(DLOG_LEVEL_WARNING,
                 "Verify that the configured interface has a valid IPv6 link local address configured.");
            error_once = true;
        }
        close(s);
        return -1;
    }

    /* listen on this socket */
    if (listen(s, DEFAULT_SOCKET_BACKLOG) == -1) {
        if (!error_once) {
            dlog(DLOG_LEVEL_ERROR, "listen() failed: %s", strerror(errno));
            error_once = true;
        }
        close(s);
        return -1;
    }

    /* retrieve the actual port number we are listening on */
    if (getsockname(s, reinterpret_cast<struct sockaddr*>(sockaddr), &addrlen) == -1) {
        if (!error_once) {
            dlog(DLOG_LEVEL_ERROR, "getsockname() failed: %s", strerror(errno));
            error_once = true;
        }
        close(s);
        return -1;
    }

    return s;
}

/*!
 * \brief check_interface This function checks the interface name. The interface name is
 * configured automatically in case it is pre-initialized to â€œauto.
 * \param sockaddr to bind the socket to an interface
 * \return Returns \c 0 on success, otherwise \c -1
 */
int check_interface(struct v2g_context* v2g_ctx) {
    if (v2g_ctx == nullptr || v2g_ctx->if_name == nullptr) {
        return -1;
    }

    struct ipv6_mreq mreq = {};
    std::memset(&mreq, 0, sizeof(mreq));

    if (strcmp(v2g_ctx->if_name, "auto") == 0) {
        v2g_ctx->if_name = choose_first_ipv6_interface();
    }

    if (v2g_ctx->if_name == nullptr) {
        return -1;
    }

    mreq.ipv6mr_interface = if_nametoindex(v2g_ctx->if_name);
    if (!mreq.ipv6mr_interface) {
        dlog(DLOG_LEVEL_ERROR, "No such interface: %s", v2g_ctx->if_name);
        return -1;
    }

    return (v2g_ctx->if_name == nullptr) ? -1 : 0;
}

/*!
 * \brief connection_init This function initilizes the tcp and tls interface.
 * \param v2g_context is the V2G context.
 * \return Returns \c 0 on success, otherwise \c -1
 */
int connection_init(struct v2g_context* v2g_ctx) {
    if (check_interface(v2g_ctx) == -1) {
        return -1;
    }

    if (v2g_ctx->tls_security != TLS_SECURITY_FORCE) {
        v2g_ctx->local_tcp_addr = static_cast<sockaddr_in6*>(calloc(1, sizeof(*v2g_ctx->local_tcp_addr)));
        if (v2g_ctx->local_tcp_addr == nullptr) {
            dlog(DLOG_LEVEL_ERROR, "Failed to allocate memory for TCP address");
            return -1;
        }
    }

    if (v2g_ctx->tls_security != TLS_SECURITY_PROHIBIT) {
        v2g_ctx->local_tls_addr = static_cast<sockaddr_in6*>(calloc(1, sizeof(*v2g_ctx->local_tls_addr)));
        if (!v2g_ctx->local_tls_addr) {
            dlog(DLOG_LEVEL_ERROR, "Failed to allocate memory for TLS address");
            return -1;
        }
    }

    while (1) {
        if (v2g_ctx->local_tcp_addr) {
            get_interface_ipv6_address(v2g_ctx->if_name, ADDR6_TYPE_LINKLOCAL, v2g_ctx->local_tcp_addr);
            if (v2g_ctx->local_tls_addr) {
                // Handle allowing TCP with TLS (TLS_SECURITY_ALLOW)
                memcpy(v2g_ctx->local_tls_addr, v2g_ctx->local_tcp_addr, sizeof(*v2g_ctx->local_tls_addr));
            }
        } else {
            // Handle forcing TLS security (TLS_SECURITY_FORCE)
            get_interface_ipv6_address(v2g_ctx->if_name, ADDR6_TYPE_LINKLOCAL, v2g_ctx->local_tls_addr);
        }

        if (v2g_ctx->local_tcp_addr) {
            char buffer[INET6_ADDRSTRLEN];

            /*
             * When we bind with port = 0, the kernel assigns a dynamic port from the range configured
             * in /proc/sys/net/ipv4/ip_local_port_range. This is on a recent Ubuntu Linux e.g.
             * $ cat /proc/sys/net/ipv4/ip_local_port_range
             * 32768   60999
             * However, in ISO15118 spec the IANA range with 49152 to 65535 is referenced. So we have the
             * problem that the kernel (without further configuration - and we want to avoid this) could
             * hand out a port which is not "range compatible".
             * To fulfill the ISO15118 standard, we simply try to bind to static port numbers.
             */
            v2g_ctx->local_tcp_addr->sin6_port = htons(DEFAULT_TCP_PORT);
            v2g_ctx->tcp_socket = connection_create_socket(v2g_ctx->local_tcp_addr);
            if (v2g_ctx->tcp_socket < 0) {
                /* retry until interface is ready */
                sleep(1);
                continue;
            }
            if (inet_ntop(AF_INET6, &v2g_ctx->local_tcp_addr->sin6_addr, buffer, sizeof(buffer)) != nullptr) {
                dlog(DLOG_LEVEL_INFO, "TCP server on %s is listening on port [%s%%%" PRIu32 "]:%" PRIu16,
                     v2g_ctx->if_name, buffer, v2g_ctx->local_tcp_addr->sin6_scope_id,
                     ntohs(v2g_ctx->local_tcp_addr->sin6_port));
            } else {
                dlog(DLOG_LEVEL_ERROR, "TCP server on %s is listening, but inet_ntop failed: %s", v2g_ctx->if_name,
                     strerror(errno));
                return -1;
            }
        }

        if (v2g_ctx->local_tls_addr) {
            char buffer[INET6_ADDRSTRLEN];

            /* see comment above for reason */
            v2g_ctx->local_tls_addr->sin6_port = htons(DEFAULT_TLS_PORT);

            v2g_ctx->tls_socket.fd = connection_create_socket(v2g_ctx->local_tls_addr);
            if (v2g_ctx->tls_socket.fd < 0) {
                if (v2g_ctx->tcp_socket != -1) {
                    /* free the TCP socket */
                    close(v2g_ctx->tcp_socket);
                }
                /* retry until interface is ready */
                sleep(1);
                continue;
            }

            if (inet_ntop(AF_INET6, &v2g_ctx->local_tls_addr->sin6_addr, buffer, sizeof(buffer)) != nullptr) {
                dlog(DLOG_LEVEL_INFO, "TLS server on %s is listening on port [%s%%%" PRIu32 "]:%" PRIu16,
                     v2g_ctx->if_name, buffer, v2g_ctx->local_tls_addr->sin6_scope_id,
                     ntohs(v2g_ctx->local_tls_addr->sin6_port));
            } else {
                dlog(DLOG_LEVEL_INFO, "TLS server on %s is listening, but inet_ntop failed: %s", v2g_ctx->if_name,
                     strerror(errno));
                return -1;
            }
        }
        /* Sockets should be ready, leave the loop */
        break;
    }

    if (v2g_ctx->local_tls_addr) {
        return tls::connection_init(v2g_ctx);
    }
    return 0;
}

/*!
 * \brief is_sequence_timeout This function checks if a sequence timeout has occurred.
 * \param ts_start Is the time after waiting of the next request message.
 * \param ctx is the V2G context.
 * \return Returns \c true if a timeout has occurred, otherwise \c false
 */
bool is_sequence_timeout(struct timespec ts_start, struct v2g_context* ctx) {
    struct timespec ts_current;
    int sequence_timeout = V2G_SEQUENCE_TIMEOUT_60S;

    if (((clock_gettime(CLOCK_MONOTONIC, &ts_current)) != 0) ||
        (timespec_to_ms(timespec_sub(ts_current, ts_start)) > sequence_timeout)) {
        dlog(DLOG_LEVEL_ERROR, "Sequence timeout has occurred (message: %s)", v2g_msg_type[ctx->current_v2g_msg]);
        return true;
    }
    return false;
}

/*!
 * \brief connection_read This function reads from socket until requested bytes are received or sequence
 * timeout is reached
 * \param conn is the v2g connection context
 * \param buf is the buffer to store the v2g message
 * \param count is the number of bytes to read
 * \return Returns \c true if a timeout has occurred, otherwise \c false
 */
ssize_t connection_read(struct v2g_connection* conn, unsigned char* buf, size_t count) {
    struct timespec ts_start;
    int bytes_read = 0;

    if (clock_gettime(CLOCK_MONOTONIC, &ts_start) == -1) {
        dlog(DLOG_LEVEL_ERROR, "clock_gettime(ts_start) failed: %s", strerror(errno));
        return -1;
    }

    /* loop until we got all requested bytes or sequence timeout DIN [V2G-DC-432]*/
    while ((bytes_read < count) && (is_sequence_timeout(ts_start, conn->ctx) == false) &&
           (conn->ctx->is_connection_terminated == false)) { // [V2G2-536]

        int num_of_bytes;

        if (conn->is_tls_connection) {
            return -1; // shouldn't be using this function
        }
        /* use select for timeout handling */
        struct timeval tv;
        fd_set read_fds;

        FD_ZERO(&read_fds);
        FD_SET(conn->conn.socket_fd, &read_fds);

        tv.tv_sec = conn->ctx->network_read_timeout / 1000;
        tv.tv_usec = (conn->ctx->network_read_timeout % 1000) * 1000;

        num_of_bytes = select(conn->conn.socket_fd + 1, &read_fds, nullptr, nullptr, &tv);

        if (num_of_bytes == -1) {
            if (errno == EINTR)
                continue;

            return -1;
        }

        /* Zero fds ready means we timed out, so let upper loop check our sequence timeout */
        if (num_of_bytes == 0) {
            continue;
        }

        num_of_bytes = (int)read(conn->conn.socket_fd, &buf[bytes_read], count - bytes_read);

        if (num_of_bytes == -1) {
            if (errno == EINTR)
                continue;

            return -1;
        }

        /* return when peer closed connection */
        if (num_of_bytes == 0)
            return bytes_read;

        bytes_read += num_of_bytes;
    }

    if (conn->ctx->is_connection_terminated == true) {
        dlog(DLOG_LEVEL_ERROR, "Reading from tcp-socket aborted");
        return -2;
    }

    return (ssize_t)bytes_read; // [V2G2-537] read bytes are currupted if reading from socket was interrupted
                                // (V2G_SECC_Sequence_Timeout)
}

/*!
 * \brief connection_read This function writes to socket until bytes are written to the socket
 * \param conn is the v2g connection context
 * \param buf is the buffer where the v2g message is stored
 * \param count is the number of bytes to write
 * \return Returns \c true if a timeout has occurred, otherwise \c false
 */
ssize_t connection_write(struct v2g_connection* conn, unsigned char* buf, size_t count) {
    int bytes_written = 0;

    /* loop until we got all requested bytes out */
    while (bytes_written < count) {
        int num_of_bytes = (int)write(conn->conn.socket_fd, &buf[bytes_written], count - bytes_written);
        if (conn->is_tls_connection) {
            return -1; // shouldn't be using this function
        }
        if (num_of_bytes == -1) {
            if (errno == EINTR)
                continue;

            return -1;
        }

        /* return when peer closed connection */
        if (num_of_bytes == 0)
            return bytes_written;

        bytes_written += num_of_bytes;
    }

    return (ssize_t)bytes_written;
}

/*!
 * \brief connection_teardown This function must be called on connection teardown.
 * \param conn is the V2G connection context
 */
void connection_teardown(struct v2g_connection* conn) {
    if (conn->ctx->session.is_charging == true) {
        conn->ctx->p_charger->publish_current_demand_finished(nullptr);

        if (conn->ctx->is_dc_charger == true) {
            conn->ctx->p_charger->publish_dc_open_contactor(nullptr);
        } else {
            conn->ctx->p_charger->publish_ac_open_contactor(nullptr);
        }
    }

    /* init charging session */
    v2g_ctx_init_charging_session(conn->ctx, true);

    /* print dlink status */
    switch (conn->dlink_action) {
    case MQTT_DLINK_ACTION_ERROR:
        dlog(DLOG_LEVEL_TRACE, "d_link/error");
        break;
    case MQTT_DLINK_ACTION_TERMINATE:
        conn->ctx->p_charger->publish_dlink_terminate(nullptr);
        dlog(DLOG_LEVEL_TRACE, "d_link/terminate");
        break;
    case MQTT_DLINK_ACTION_PAUSE:
        conn->ctx->p_charger->publish_dlink_pause(nullptr);
        dlog(DLOG_LEVEL_TRACE, "d_link/pause");
        break;
    }
}

/**
 * This is the 'main' function of a thread, which handles a TCP connection.
 */
static void* connection_handle_tcp(void* data) {
    struct v2g_connection* conn = static_cast<struct v2g_connection*>(data);
    int rv = 0;

    dlog(DLOG_LEVEL_INFO, "Started new TCP connection thread");

    /* check if the v2g-session is already running in another thread, if not, handle v2g-connection */
    if (conn->ctx->state == 0) {
        int rv2 = v2g_handle_connection(conn);

        if (rv2 != 0) {
            dlog(DLOG_LEVEL_INFO, "v2g_handle_connection exited with %d", rv2);
        }
    } else {
        rv = ERROR_SESSION_ALREADY_STARTED;
        dlog(DLOG_LEVEL_WARNING, "%s", "Closing tcp-connection. v2g-session is already running");
    }

    /* tear down connection gracefully */
    dlog(DLOG_LEVEL_INFO, "Closing TCP connection");

    std::this_thread::sleep_for(std::chrono::seconds(2));

    if (shutdown(conn->conn.socket_fd, SHUT_RDWR) == -1) {
        dlog(DLOG_LEVEL_ERROR, "shutdown() failed: %s", strerror(errno));
    }

    // Waiting for client closing the connection
    std::this_thread::sleep_for(std::chrono::seconds(3));

    if (close(conn->conn.socket_fd) == -1) {
        dlog(DLOG_LEVEL_ERROR, "close() failed: %s", strerror(errno));
    }
    dlog(DLOG_LEVEL_INFO, "TCP connection closed gracefully");

    if (rv != ERROR_SESSION_ALREADY_STARTED) {
        /* cleanup and notify lower layers */
        connection_teardown(conn);
    }

    free(conn);

    return nullptr;
}

static void* connection_server(void* data) {
    struct v2g_context* ctx = static_cast<v2g_context*>(data);
    struct v2g_connection* conn = NULL;
    pthread_attr_t attr;

    /* create the thread in detached state so we don't need to join every single one */
    if (pthread_attr_init(&attr) != 0) {
        dlog(DLOG_LEVEL_ERROR, "pthread_attr_init failed: %s", strerror(errno));
        goto thread_exit;
    }
    if (pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) != 0) {
        dlog(DLOG_LEVEL_ERROR, "pthread_attr_setdetachstate failed: %s", strerror(errno));
        goto thread_exit;
    }

    while (1) {
        char client_addr[INET6_ADDRSTRLEN];
        struct sockaddr_in6 addr;
        socklen_t addrlen = sizeof(addr);

        /* cleanup old one and create new connection context */
        free(conn);
        conn = static_cast<v2g_connection*>(calloc(1, sizeof(*conn)));
        if (!conn) {
            dlog(DLOG_LEVEL_ERROR, "Calloc failed: %s", strerror(errno));
            break;
        }

        /* setup common stuff */
        conn->ctx = ctx;
        conn->read = &connection_read;
        conn->write = &connection_write;
        conn->is_tls_connection = false;

        /* wait for an incoming connection */
        conn->conn.socket_fd = accept(ctx->tcp_socket, (struct sockaddr*)&addr, &addrlen);
        if (conn->conn.socket_fd == -1) {
            dlog(DLOG_LEVEL_ERROR, "Accept(tcp) failed: %s", strerror(errno));
            continue;
        }

        if (inet_ntop(AF_INET6, &addr, client_addr, sizeof(client_addr)) != NULL) {
            dlog(DLOG_LEVEL_INFO, "Incoming connection on %s from [%s]:%" PRIu16, ctx->if_name, client_addr,
                 ntohs(addr.sin6_port));
        } else {
            dlog(DLOG_LEVEL_ERROR, "Incoming connection on %s, but inet_ntop failed: %s", ctx->if_name,
                 strerror(errno));
        }

        // store the port to create a udp socket
        conn->ctx->udp_port = ntohs(addr.sin6_port);

        if (pthread_create(&conn->thread_id, &attr, connection_handle_tcp, conn) != 0) {
            dlog(DLOG_LEVEL_ERROR, "pthread_create() failed: %s", strerror(errno));
            continue;
        }

        /* is up to the thread to cleanup conn */
        conn = NULL;
    }

thread_exit:
    if (pthread_attr_destroy(&attr) != 0) {
        dlog(DLOG_LEVEL_ERROR, "pthread_attr_destroy failed: %s", strerror(errno));
    }

    /* clean up if dangling */
    free(conn);

    return NULL;
}

int connection_start_servers(struct v2g_context* ctx) {
    int rv, tcp_started = 0;

    if (ctx->tcp_socket != -1) {
        rv = pthread_create(&ctx->tcp_thread, NULL, connection_server, ctx);
        if (rv != 0) {
            dlog(DLOG_LEVEL_ERROR, "pthread_create(tcp) failed: %s", strerror(errno));
            return -1;
        }
        tcp_started = 1;
    }

    if (ctx->tls_socket.fd != -1) {
        rv = tls::connection_start_server(ctx);
        if (rv != 0) {
            if (tcp_started) {
                pthread_cancel(ctx->tcp_thread);
                pthread_join(ctx->tcp_thread, NULL);
            }
            dlog(DLOG_LEVEL_ERROR, "pthread_create(tls) failed: %s", strerror(errno));
            return -1;
        }
    }

    return 0;
}

int create_udp_socket(const uint16_t udp_port, const char* interface_name) {
    constexpr auto LINK_LOCAL_MULTICAST = "ff02::1";

    int udp_socket = socket(AF_INET6, SOCK_DGRAM, 0);
    if (udp_socket < 0) {
        EVLOG_error << "Could not create socket: " << strerror(errno);
        return udp_socket;
    }

    // source setup

    // find port between 49152-65535
    auto could_bind = false;
    auto source_port = 49152;
    for (; source_port < 65535; source_port++) {
        sockaddr_in6 source_address = {AF_INET6, htons(source_port)};
        if (bind(udp_socket, reinterpret_cast<sockaddr*>(&source_address), sizeof(sockaddr_in6)) == 0) {
            could_bind = true;
            break;
        }
    }

    if (!could_bind) {
        EVLOG_error << "Could not bind: " << strerror(errno);
        return -1;
    }

    EVLOG_info << "UDP socket bound to source port: " << source_port;

    const auto index = if_nametoindex(interface_name);
    auto mreq = ipv6_mreq{};
    mreq.ipv6mr_interface = index;
    if (inet_pton(AF_INET6, LINK_LOCAL_MULTICAST, &mreq.ipv6mr_multiaddr) <= 0) {
        EVLOG_error << "Failed to setup multicast address" << strerror(errno);
        return -1;
    }
    if (setsockopt(udp_socket, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) < 0) {
        EVLOG_error << "Could not add multicast group membership: " << strerror(errno);
        return -1;
    }

    if (setsockopt(udp_socket, IPPROTO_IPV6, IPV6_MULTICAST_IF, &index, sizeof(index)) < 0) {
        EVLOG_error << "Could not set interface name: " << interface_name << "with error: " << strerror(errno);
    }

    // destination setup
    sockaddr_in6 destination_address = {AF_INET6, htons(udp_port)};
    if (inet_pton(AF_INET6, LINK_LOCAL_MULTICAST, &destination_address.sin6_addr) <= 0) {
        EVLOG_error << "Failed to setup server address" << strerror(errno);
    }
    const auto connected =
        connect(udp_socket, reinterpret_cast<sockaddr*>(&destination_address), sizeof(sockaddr_in6)) == 0;
    if (!connected) {
        EVLOG_error << "Could not connect: " << strerror(errno);
        return -1;
    }

    return udp_socket;
}


// ===== connection\connection.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2022 chargebyte GmbH
// Copyright (C) 2022 Contributors to EVerest

#ifndef CONNECTION_H
#define CONNECTION_H

#include <cstddef>
#include <netinet/in.h>

#include "v2g_ctx.hpp"

/*!
 * \brief initialise TCP/TLS connections
 * \param ctx the V2G context
 * \return 0 on success
 */
int connection_init(struct v2g_context* ctx);

/*!
 * \brief start TCP/TLS servers
 * \param ctx the V2G context
 * \return 0 on success
 */
int connection_start_servers(struct v2g_context* ctx);
int create_udp_socket(const uint16_t udp_port, const char* interface_name);

/*!
 * \brief check for V2G message sequence timeout
 * \param ts_start start time
 * \param ctx the V2G context
 * \return true on timeout
 */
bool is_sequence_timeout(struct timespec ts_start, struct v2g_context* ctx);

/*!
 * \brief actions to take on connection close
 * \param conn v2g connection context
 */
void connection_teardown(struct v2g_connection* conn);

/*!
 * \brief connection_read This abstracts a read from the connection socket, so that higher level functions
 * are not required to distinguish between TCP and TLS connections.
 * \param conn v2g connection context
 * \param buf buffer to store received message sequence.
 * \param count number of read bytes.
 * \return Returns the number of read bytes if successful, otherwise returns -1 for reading errors and
 * -2 for closed connection */
ssize_t connection_read(struct v2g_connection* conn, unsigned char* buf, std::size_t count);

/*!
 * \brief connection_write This abstracts a write to the connection socket, so that higher level functions
 * are not required to distinguish between TCP and TLS connections.
 * \param conn v2g connection context
 * \param buf buffer to store received message sequence.
 * \param count size of the buffer
 * \return Returns the number of read bytes if successful, otherwise returns -1 for reading errors and
 * -2 for closed connection */
ssize_t connection_write(struct v2g_connection* conn, unsigned char* buf, std::size_t count);

#endif /* CONNECTION_H */


// ===== connection\tls_connection.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2020 - 2023 Pionix GmbH and Contributors to EVerest

#include "tls_connection.hpp"
#include "connection.hpp"
#include "log.hpp"
#include "v2g.hpp"
#include "v2g_server.hpp"
#include <new>
#include <tls.hpp>

#include <cassert>
#include <cerrno>
#include <cstring>
#include <ctime>
#include <memory>
#include <sys/types.h>
#include <thread>

namespace {

// used when ctx->network_read_timeout_tls is 0
constexpr int default_timeout_ms = 1000;

void process_connection_thread(std::shared_ptr<tls::ServerConnection> con, struct v2g_context* ctx) {
    assert(con != nullptr);
    assert(ctx != nullptr);

    openssl::pkey_ptr contract_public_key{nullptr, nullptr};
    auto connection = std::make_unique<v2g_connection>();
    connection->ctx = ctx;
    connection->is_tls_connection = true;
    connection->read = &tls::connection_read;
    connection->write = &tls::connection_write;
    connection->tls_connection = con.get();
    connection->pubkey = &contract_public_key;

    dlog(DLOG_LEVEL_INFO, "Incoming TLS connection");

    bool loop{true};
    while (loop) {
        loop = false;
        const auto result = con->accept();
        switch (result) {
        case tls::Connection::result_t::success:
            if (ctx->state == 0) {
                const auto rv = ::v2g_handle_connection(connection.get());
                dlog(DLOG_LEVEL_INFO, "v2g_dispatch_connection exited with %d", rv);
            } else {
                dlog(DLOG_LEVEL_INFO, "%s", "Closing tls-connection. v2g-session is already running");
            }

            con->shutdown();
            break;
        case tls::Connection::result_t::want_read:
        case tls::Connection::result_t::want_write:
            loop = con->wait_for(result, default_timeout_ms) == tls::Connection::result_t::success;
            break;
        case tls::Connection::result_t::closed:
        case tls::Connection::result_t::timeout:
        default:
            break;
        }
    }

    ::connection_teardown(connection.get());
}

void handle_new_connection_cb(tls::Server::ConnectionPtr&& con, struct v2g_context* ctx) {
    assert(con != nullptr);
    assert(ctx != nullptr);
    // create a thread to process this connection
    try {
        // passing unique pointers through thread parameters is problematic
        std::shared_ptr<tls::ServerConnection> connection(con.release());
        std::thread connection_loop(process_connection_thread, connection, ctx);
        connection_loop.detach();
    } catch (const std::system_error&) {
        // unable to start thread
        dlog(DLOG_LEVEL_ERROR, "pthread_create() failed: %s", strerror(errno));
        con->shutdown();
    }
}

void server_loop_thread(struct v2g_context* ctx) {
    assert(ctx != nullptr);
    assert(ctx->tls_server != nullptr);
    const auto res = ctx->tls_server->serve([ctx](auto con) { handle_new_connection_cb(std::move(con), ctx); });
    if (res != tls::Server::state_t::stopped) {
        dlog(DLOG_LEVEL_ERROR, "tls::Server failed to serve");
    }
}

tls::Server::OptionalConfig configure_ssl(struct v2g_context* ctx) {
    try {
        dlog(DLOG_LEVEL_WARNING, "configure_ssl");
        auto config = std::make_unique<tls::Server::config_t>();

        // The config of interest is from Evse Security, no point in updating
        // config when there is a problem

        if (build_config(*config, ctx)) {
            return {{std::move(config)}};
        }
    } catch (const std::bad_alloc&) {
        dlog(DLOG_LEVEL_ERROR, "unable to create TLS config");
    }
    return std::nullopt;
}

} // namespace

namespace tls {

int connection_init(struct v2g_context* ctx) {
    using state_t = tls::Server::state_t;

    assert(ctx != nullptr);
    assert(ctx->tls_server != nullptr);
    assert(ctx->r_security != nullptr);

    int res{-1};
    tls::Server::config_t config;

    // build_config can fail due to issues with Evse Security,
    // this can be retried later. Not treated as an error.
    (void)build_config(config, ctx);

    // apply config
    ctx->tls_server->stop();
    ctx->tls_server->wait_stopped();
    const auto result = ctx->tls_server->init(config, [ctx]() { return configure_ssl(ctx); });
    if ((result == state_t::init_complete) || (result == state_t::init_socket)) {
        res = 0;
    }

    return res;
}

int connection_start_server(struct v2g_context* ctx) {
    assert(ctx != nullptr);
    assert(ctx->tls_server != nullptr);

    // only starts the TLS server

    int res = 0;
    try {
        ctx->tls_server->stop();
        ctx->tls_server->wait_stopped();
        if (ctx->tls_server->state() == tls::Server::state_t::stopped) {
            // need to re-initialise
            tls::connection_init(ctx);
        }
        std::thread serve_loop(server_loop_thread, ctx);
        serve_loop.detach();
        ctx->tls_server->wait_running();
    } catch (const std::system_error&) {
        // unable to start thread (caller logs failure)
        res = -1;
    }
    return res;
}

ssize_t connection_read(struct v2g_connection* conn, unsigned char* buf, const std::size_t count) {
    assert(conn != nullptr);
    assert(conn->tls_connection != nullptr);

    ssize_t result{0};
    std::size_t bytes_read{0};
    timespec ts_start{};

    if (clock_gettime(CLOCK_MONOTONIC, &ts_start) == -1) {
        dlog(DLOG_LEVEL_ERROR, "clock_gettime(ts_start) failed: %s", strerror(errno));
        result = -1;
    }

    while ((bytes_read < count) && (result >= 0)) {
        const std::size_t remaining = count - bytes_read;
        std::size_t bytes_in{0};
        auto* ptr = reinterpret_cast<std::byte*>(&buf[bytes_read]);

        const auto read_res = conn->tls_connection->read(ptr, remaining, bytes_in);
        switch (read_res) {
        case tls::Connection::result_t::success:
            bytes_read += bytes_in;
            break;
        case tls::Connection::result_t::want_read:
        case tls::Connection::result_t::want_write:
            conn->tls_connection->wait_for(read_res, default_timeout_ms);
            break;
        case tls::Connection::result_t::timeout:
            // is_sequence_timeout() is used to manage timeouts. Just loop and wait for more bytes
            break;
        case tls::Connection::result_t::closed:
        default:
            result = -1;
            break;
        }

        if (conn->ctx->is_connection_terminated) {
            dlog(DLOG_LEVEL_ERROR, "Reading from tcp-socket aborted");
            conn->tls_connection->shutdown();
            result = -2;
        }

        if (::is_sequence_timeout(ts_start, conn->ctx)) {
            break;
        }
    }

    return (result < 0) ? result : static_cast<ssize_t>(bytes_read);
}

ssize_t connection_write(struct v2g_connection* conn, unsigned char* buf, std::size_t count) {
    assert(conn != nullptr);
    assert(conn->tls_connection != nullptr);

    ssize_t result{0};
    std::size_t bytes_written{0};

    while ((bytes_written < count) && (result >= 0)) {
        const std::size_t remaining = count - bytes_written;
        std::size_t bytes_out{0};
        const auto* ptr = reinterpret_cast<std::byte*>(&buf[bytes_written]);

        const auto write_res = conn->tls_connection->write(ptr, remaining, bytes_out);
        switch (write_res) {
        case tls::Connection::result_t::success:
            bytes_written += bytes_out;
            break;
        case tls::Connection::result_t::want_read:
        case tls::Connection::result_t::want_write:
            conn->tls_connection->wait_for(write_res, default_timeout_ms);
            break;
        case tls::Connection::result_t::timeout:
            // is_sequence_timeout() is used to manage timeouts. Just loop and wait for more bytes
            break;
        case tls::Connection::result_t::closed:
        default:
            result = -1;
            break;
        }
    }

    if ((result == -1) && (conn->tls_connection->state() == tls::Connection::state_t::closed)) {
        // if the connection has closed - return the number of bytes sent
        result = 0;
    }

    return (result < 0) ? result : static_cast<ssize_t>(bytes_written);
}

bool build_config(tls::Server::config_t& config, struct v2g_context* ctx) {
    assert(ctx != nullptr);
    assert(ctx->r_security != nullptr);

    using types::evse_security::CaCertificateType;
    using types::evse_security::EncodingFormat;
    using types::evse_security::GetCertificateInfoStatus;
    using types::evse_security::LeafCertificateType;

    /*
     * libevse-security checks for an optional password and when one
     * isn't set is uses an empty string as the password rather than nullptr.
     * hence private keys are always encrypted.
     */

    bool bResult{false};

    config.cipher_list = "ECDHE-ECDSA-AES128-SHA256:ECDH-ECDSA-AES128-SHA256";
    config.ciphersuites = "";     // disable TLS 1.3
    config.verify_client = false; // contract certificate managed in-band in 15118-2

    // use the existing configured socket
    // TODO(james-ctc): switch to server socket init code otherwise there
    //                  may be issues with reinitialisation
    config.socket = ctx->tls_socket.fd;
    config.io_timeout_ms = static_cast<std::int32_t>(ctx->network_read_timeout_tls);

    config.tls_key_logging = ctx->tls_key_logging;
    config.tls_key_logging_path = ctx->tls_key_logging_path;
    config.host = ctx->if_name;

    // information from libevse-security
    const auto cert_info =
        ctx->r_security->call_get_all_valid_certificates_info(LeafCertificateType::V2G, EncodingFormat::PEM, true);
    if (cert_info.status != GetCertificateInfoStatus::Accepted) {
        dlog(DLOG_LEVEL_ERROR, "Failed to read cert_info! Not Accepted");
    } else {
        if (!cert_info.info.empty()) {
            // process all known certificate chains
            for (const auto& chain : cert_info.info) {
                const auto cert_path = chain.certificate.value_or("");
                const auto key_path = chain.key;
                const auto root_pem = chain.certificate_root.value_or("");

                // workaround (see above libevse-security comment)
                const auto key_password = chain.password.value_or("");

                auto& ref = config.chains.emplace_back();
                ref.certificate_chain_file = cert_path.c_str();
                ref.private_key_file = key_path.c_str();
                ref.private_key_password = key_password.c_str();
                ref.trust_anchor_pem = root_pem.c_str();

                if (chain.ocsp) {
                    for (const auto& ocsp : chain.ocsp.value()) {
                        const char* file{nullptr};
                        if (ocsp.ocsp_path) {
                            file = ocsp.ocsp_path.value().c_str();
                        }
                        ref.ocsp_response_files.push_back(file);
                    }
                }
            }

            bResult = true;
        } else {
            dlog(DLOG_LEVEL_ERROR, "Failed to read cert_info! Empty response");
        }
    }

    return bResult;
}

} // namespace tls


// ===== connection\tls_connection.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2020 - 2023 Pionix GmbH and Contributors to EVerest

#ifndef TLS_CONNECTION_HPP_
#define TLS_CONNECTION_HPP_

#include <cstddef>
#include <tls.hpp>
#include <unistd.h>

struct v2g_context;
struct v2g_connection;

namespace tls {

/*!
 * \param ctx v2g connection context
 * \return returns 0 on succss and -1 on error
 */
int connection_init(struct v2g_context* ctx);

/*!
 * \param ctx v2g connection context
 * \return returns 0 on succss and -1 on error
 */
int connection_start_server(struct v2g_context* ctx);

/*!
 * \brief connection_read This abstracts a read from the connection socket, so that higher level functions
 * are not required to distinguish between TCP and TLS connections.
 * \param conn v2g connection context
 * \param buf buffer to store received message sequence.
 * \param count number of read bytes.
 * \return Returns the number of read bytes if successful, otherwise returns -1 for reading errors and
 * -2 for closed connection */
ssize_t connection_read(struct v2g_connection* conn, unsigned char* buf, std::size_t count);

/*!
 * \brief connection_write This abstracts a write to the connection socket, so that higher level functions
 * are not required to distinguish between TCP and TLS connections.
 * \param conn v2g connection context
 * \param buf buffer to store received message sequence.
 * \param count size of the buffer
 * \return Returns the number of read bytes if successful, otherwise returns -1 for reading errors and
 * -2 for closed connection */
ssize_t connection_write(struct v2g_connection* conn, unsigned char* buf, std::size_t count);

/*!
 * \brief build_config This builds the TLS server configuration based on the v2g context.
 * \param config TLS server configuration to be filled
 * \param ctx v2g connection context
 * \return Returns true if the configuration was built successfully, otherwise false.
 */
bool build_config(tls::Server::config_t& config, struct v2g_context* ctx);

} // namespace tls

#endif // TLS_CONNECTION_HPP_


// ===== crypto\crypto_common.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2020 - 2023 Pionix GmbH and Contributors to EVerest

#ifndef CRTYPTO_COMMON_HPP_
#define CRTYPTO_COMMON_HPP_

#include <openssl_util.hpp>

#include <cstddef>

namespace crypto {

using verify_result_t = openssl::verify_result_t;

constexpr std::size_t MAX_EXI_SIZE = 8192;

} // namespace crypto

#endif // CRTYPTO_COMMON_HPP_


// ===== crypto\crypto_openssl.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2020 - 2023 Pionix GmbH and Contributors to EVerest

#include <array>
#include <cassert>

#include "crypto_openssl.hpp"
#include "iso_server.hpp"
#include "log.hpp"

#include <cbv2g/common/exi_bitstream.h>
#include <cbv2g/exi_v2gtp.h> //for V2GTP_HEADER_LENGTHs
#include <cbv2g/iso_2/iso2_msgDefDatatypes.h>
#include <cbv2g/iso_2/iso2_msgDefDecoder.h>
#include <cbv2g/iso_2/iso2_msgDefEncoder.h>

#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/store.h>
#include <openssl/x509.h>

namespace crypto ::openssl {
using ::openssl::bn_const_t;
using ::openssl::bn_t;
using ::openssl::log_error;
using ::openssl::sha_256;
using ::openssl::sha_256_digest_t;
using ::openssl::verify;

bool check_iso2_signature(const struct iso2_SignatureType* iso2_signature, EVP_PKEY* pkey,
                          struct iso2_exiFragment* iso2_exi_fragment) {
    assert(pkey != nullptr);
    assert(iso2_signature != nullptr);
    assert(iso2_exi_fragment != nullptr);

    bool bRes{true};

    // signature information
    const struct iso2_ReferenceType* req_ref = &iso2_signature->SignedInfo.Reference.array[0];
    const auto signature_len = iso2_signature->SignatureValue.CONTENT.bytesLen;
    const auto* signature = &iso2_signature->SignatureValue.CONTENT.bytes[0];

    // build data to check signature against
    std::array<std::uint8_t, MAX_EXI_SIZE> exi_buffer{};
    exi_bitstream_t stream;
    exi_bitstream_init(&stream, exi_buffer.data(), MAX_EXI_SIZE, 0, NULL);

    auto err = encode_iso2_exiFragment(&stream, iso2_exi_fragment);
    if (err != 0) {
        dlog(DLOG_LEVEL_ERROR, "Unable to encode fragment, error code = %d", err);
        bRes = false;
    }

    sha_256_digest_t digest;

    // calculate hash of data
    if (bRes) {
        const auto frag_data_len = exi_bitstream_get_length(&stream);
        bRes = sha_256(exi_buffer.data(), frag_data_len, digest);
    }

    // check hash matches the value in the message
    if (bRes) {
        if (req_ref->DigestValue.bytesLen != digest.size()) {
            dlog(DLOG_LEVEL_ERROR, "Invalid digest length %u in signature", req_ref->DigestValue.bytesLen);
            bRes = false;
        }
    }
    if (bRes) {
        if (std::memcmp(req_ref->DigestValue.bytes, digest.data(), digest.size()) != 0) {
            dlog(DLOG_LEVEL_ERROR, "Invalid digest in signature");
            bRes = false;
        }
    }

    // verify the signature
    if (bRes) {
        struct iso2_xmldsigFragment sig_fragment {};
        init_iso2_xmldsigFragment(&sig_fragment);
        sig_fragment.SignedInfo_isUsed = 1;
        sig_fragment.SignedInfo = iso2_signature->SignedInfo;

        /** \req [V2G2-771] Don't use following fields */
        sig_fragment.SignedInfo.Id_isUsed = 0;
        sig_fragment.SignedInfo.CanonicalizationMethod.ANY_isUsed = 0;
        sig_fragment.SignedInfo.SignatureMethod.HMACOutputLength_isUsed = 0;
        sig_fragment.SignedInfo.SignatureMethod.ANY_isUsed = 0;
        for (auto* ref = sig_fragment.SignedInfo.Reference.array;
             ref != (sig_fragment.SignedInfo.Reference.array + sig_fragment.SignedInfo.Reference.arrayLen); ++ref) {
            ref->Type_isUsed = 0;
            ref->Transforms.Transform.ANY_isUsed = 0;
            ref->Transforms.Transform.XPath_isUsed = 0;
            ref->DigestMethod.ANY_isUsed = 0;
        }

        stream.byte_pos = 0;
        stream.bit_count = 0;
        err = encode_iso2_xmldsigFragment(&stream, &sig_fragment);

        if (err != 0) {
            dlog(DLOG_LEVEL_ERROR, "Unable to encode XML signature fragment, error code = %d", err);
            bRes = false;
        }
    }

    if (bRes) {
        // hash again (different data) buffer_pos has been updated ...
        const auto frag_data_len = exi_bitstream_get_length(&stream);
        bRes = sha_256(exi_buffer.data(), frag_data_len, digest);
    }

    if (bRes) {
        /* Validate the ecdsa signature using the public key */
        if (signature_len != ::openssl::signature_size) {
            dlog(DLOG_LEVEL_ERROR, "Signature len is invalid (%i)", signature_len);
            bRes = false;
        }
    }

    if (bRes) {
        const std::uint8_t* r = &signature[0];
        const std::uint8_t* s = &signature[32];
        bRes = verify(pkey, r, s, digest);
    }

    return bRes;
}

bool load_contract_root_cert(::openssl::certificate_list& trust_anchors, const char* V2G_file_path,
                             const char* MO_file_path) {
    trust_anchors.clear();

    auto mo_certs = ::openssl::load_certificates(MO_file_path);
    trust_anchors = std::move(mo_certs);

    auto v2g_certs = ::openssl::load_certificates(V2G_file_path);
    trust_anchors.insert(trust_anchors.end(), std::make_move_iterator(v2g_certs.begin()),
                         std::make_move_iterator(v2g_certs.end()));

    if (trust_anchors.empty()) {
        log_error("Unable to load any MO or V2G root(s)");
    }

    return !trust_anchors.empty();
}

int load_certificate(::openssl::certificate_list* chain, const std::uint8_t* bytes, std::uint16_t bytesLen) {
    assert(chain != nullptr);
    int result{-1};

    auto tmp_cert = ::openssl::der_to_certificate(bytes, bytesLen);
    if (tmp_cert != nullptr) {
        chain->push_back(std::move(tmp_cert));
        result = 0;
    }

    return result;
}

int parse_contract_certificate(::openssl::certificate_ptr& crt, const std::uint8_t* buf, std::size_t buflen) {
    crt = ::openssl::der_to_certificate(buf, buflen);
    return (crt == nullptr) ? -1 : 0;
}

std::string getEmaidFromContractCert(const ::openssl::certificate_ptr& crt) {
    std::string cert_emaid;
    const auto subject = ::openssl::certificate_subject(crt.get());
    if (auto itt = subject.find("CN"); itt != subject.end()) {
        cert_emaid = itt->second;
    }

    return cert_emaid;
}

std::string chain_to_pem(const ::openssl::certificate_ptr& cert, const ::openssl::certificate_list* chain) {
    assert(chain != nullptr);

    std::string contract_cert_chain_pem(::openssl::certificate_to_pem(cert.get()));
    for (const auto& crt : *chain) {
        const auto pem = ::openssl::certificate_to_pem(crt.get());
        if (pem.empty()) {
            dlog(DLOG_LEVEL_ERROR, "Unable to encode certificate chain");
            break;
        }
        contract_cert_chain_pem.append(pem);
    }

    return contract_cert_chain_pem;
}

verify_result_t verify_certificate(const ::openssl::certificate_ptr& cert, const ::openssl::certificate_list* chain,
                                   const char* v2g_root_cert_path, const char* mo_root_cert_path,
                                   bool /* debugMode */) {
    assert(chain != nullptr);

    verify_result_t result{verify_result_t::Verified};
    ::openssl::certificate_list trust_anchors;

    if (!load_contract_root_cert(trust_anchors, v2g_root_cert_path, mo_root_cert_path)) {
        result = verify_result_t::NoCertificateAvailable;
    } else {
        result = ::openssl::verify_certificate(cert.get(), trust_anchors, *chain);
    }

    return result;
}

} // namespace crypto::openssl


// ===== crypto\crypto_openssl.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2020 - 2023 Pionix GmbH and Contributors to EVerest

#ifndef CRYPTO_OPENSSL_HPP_
#define CRYPTO_OPENSSL_HPP_

#include <cstddef>
#include <string>

#include "crypto_common.hpp"
#include <openssl_util.hpp>

/**
 * \file OpenSSL implementation
 */

struct evp_pkey_st;
struct iso2_SignatureType;
struct iso2_exiFragment;
struct x509_st;
struct v2g_connection;

namespace crypto::openssl {

/**
 * \brief check the signature of a signed 15118 message
 * \param iso2_signature the signature to check
 * \param public_key the public key from the contract certificate
 * \param iso2_exi_fragment the signed data
 * \return true when the signature is valid
 */
bool check_iso2_signature(const struct iso2_SignatureType* iso2_signature, evp_pkey_st* pkey,
                          struct iso2_exiFragment* iso2_exi_fragment);

/**
 * \brief load the trust anchor for the contract certificate.
 *        Use the mobility operator certificate if it exists otherwise
 *        the V2G certificate
 * \param contract_root_crt the retrieved trust anchor
 * \param V2G_file_path the file containing the V2G trust anchor (PEM format)
 * \param MO_file_path the file containing the mobility operator trust anchor (PEM format)
 * \return true when a certificate was found
 */
bool load_contract_root_cert(::openssl::certificate_list& trust_anchors, const char* V2G_file_path,
                             const char* MO_file_path);

/**
 * \brief clear certificate and public key from previous connection
 * \param conn the V2G connection data
 * \note not needed for the OpenSSL implementation
 */
constexpr void free_connection_crypto_data(v2g_connection* conn) {
}

/**
 * \brief load a contract certificate's certification path certificate from the V2G message as DER bytes
 * \param chain the certificate path certificates (this certificate is added to the list)
 * \param bytes the DER (ASN.1) X509v3 certificate in the V2G message
 * \param bytesLen the length of the DER encoded certificate
 * \return 0 when certificate successfully loaded
 */
int load_certificate(::openssl::certificate_list* chain, const std::uint8_t* bytes, std::uint16_t bytesLen);

/**
 * \brief load the contract certificate from the V2G message as DER bytes
 * \param crt the certificate
 * \param bytes the DER (ASN.1) X509v3 certificate in the V2G message
 * \param bytesLen the length of the DER encoded certificate
 * \return 0 when certificate successfully loaded
 */
int parse_contract_certificate(::openssl::certificate_ptr& crt, const std::uint8_t* buf, std::size_t buflen);

/**
 * \brief get the EMAID from the certificate (CommonName from the SubjectName)
 * \param crt the certificate
 * \return the EMAD or empty on error
 */
std::string getEmaidFromContractCert(const ::openssl::certificate_ptr& crt);

/**
 * \brief convert a list of certificates into a PEM string starting with the contract certificate
 * \param contract_crt the contract certificate (when not the first certificate in the chain)
 * \param chain the certification path chain (might include the contract certificate as the first item)
 * \return PEM string or empty on error
 */
std::string chain_to_pem(const ::openssl::certificate_ptr& cert, const ::openssl::certificate_list* chain);

/**
 * \brief verify certification path of the contract certificate through to a trust anchor
 * \param contract_crt (single certificate or chain with the contract certificate as the first item)
 * \param chain intermediate certificates (may be nullptr)
 * \param v2g_root_cert_path V2G trust anchor file name
 * \param mo_root_cert_path mobility operator trust anchor file name
 * \param debugMode additional information on verification failures
 * \result a subset of possible verification failures where known or 'verified' on success
 */
verify_result_t verify_certificate(const ::openssl::certificate_ptr& cert, const ::openssl::certificate_list* chain,
                                   const char* v2g_root_cert_path, const char* mo_root_cert_path, bool debugMode);

} // namespace crypto::openssl

#endif // CRYPTO_OPENSSL_HPP_


// ===== din_server.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2023 chargebyte GmbH
// Copyright (C) 2023 Contributors to EVerest

#include <cbv2g/din/din_msgDefDatatypes.h>

#include <inttypes.h>
#include <string.h>

#include "din_server.hpp"
#include "log.hpp"
#include "tools.hpp"
#include "v2g_ctx.hpp"
#include "v2g_server.hpp"

#define SASCHEDULETUPLEID 1

/**
 * @brief load_din_physical_value This function copies the physical values from source to destination struct.
 * @param phy_value_dest is the destination struct.
 * @param phy_value_source is the source struct.
 */
void load_din_physical_value(struct din_PhysicalValueType* const phy_value_dest,
                             struct iso2_PhysicalValueType* const phy_value_source) {
    phy_value_dest->Multiplier = phy_value_source->Multiplier;
    phy_value_dest->Value = phy_value_source->Value;
    phy_value_dest->Unit_isUsed = 1;

    switch (phy_value_source->Unit) {
    case iso2_unitSymbolType_h:
        phy_value_dest->Unit = din_unitSymbolType_h;
        break;
    case iso2_unitSymbolType_m:
        phy_value_dest->Unit = din_unitSymbolType_m;
        break;
    case iso2_unitSymbolType_s:
        phy_value_dest->Unit = din_unitSymbolType_s;
        break;
    case iso2_unitSymbolType_A:
        phy_value_dest->Unit = din_unitSymbolType_A;
        break;
    case iso2_unitSymbolType_V:
        phy_value_dest->Unit = din_unitSymbolType_V;
        break;
    case iso2_unitSymbolType_W:
        phy_value_dest->Unit = din_unitSymbolType_W;
        break;
    case iso2_unitSymbolType_Wh:
        phy_value_dest->Unit = din_unitSymbolType_Wh;
        break;
    default:
        phy_value_dest->Unit = din_unitSymbolType_h;
        break;
    }
}

/*!
 * \brief din_validate_state This function checks whether the received message is expected and valid at this
 * point in the communication sequence state machine. The current V2G msg type must be set with the current V2G msg
 * state. \param state is the current state of the charging session \param current_v2g_msg is the current handled V2G
 * message \param state of the actual session. \return Returns a din_ResponseCode with sequence error if current_v2g_msg
 * is not expected, otherwise OK.
 */
static din_responseCodeType din_validate_state(int state, enum V2gMsgTypeId current_v2g_msg) {
    /* if the request type has enabled (= set) bit in expected_requests, then this
     * message is ok at this stage; otherwise reject it.
     */
    return (din_states[state].allowed_requests & (1 << current_v2g_msg)) ? din_responseCodeType_OK
                                                                         : din_responseCodeType_FAILED_SequenceError;
}

namespace utils {
/*!
 * \brief din_validate_response_code This function checks if an external error has occurred (sequence error, user
 * abort)... ). \param din_response_code is a pointer to the current response code. The value will be modified if an
 * external error has occurred. \param conn the structure with the external error information. \return Returns the next
 * v2g-event.
 */
v2g_event din_validate_response_code(din_responseCodeType* const din_response_code, struct v2g_connection const* conn) {
    enum v2g_event nextEvent = V2G_EVENT_NO_EVENT;
    din_responseCodeType response_code_tmp;

    if (conn->ctx->is_connection_terminated == true) {
        dlog(DLOG_LEVEL_ERROR, "Connection is terminated. Abort charging");
        return V2G_EVENT_TERMINATE_CONNECTION;
    }

    /* If MQTT user abort or emergency shutdown has occurred */
    if ((conn->ctx->stop_hlc == true) || (conn->ctx->intl_emergency_shutdown == true)) {
        *din_response_code = din_responseCodeType_FAILED;
    }

    /* [V2G-DC-390]: at this point we must check whether the given request is valid at this step;
     * the idea is that we catch this error in each function below to respond with a valid
     * encoded message; note, that the handler functions below must not access v2g_session in
     * error path, since it might not be set, yet!
     */
    response_code_tmp = din_validate_state(conn->ctx->state, conn->ctx->current_v2g_msg);
    *din_response_code = (response_code_tmp >= din_responseCodeType_FAILED) ? response_code_tmp : *din_response_code;

    /* [V2G-DC-391]: check whether the session id matches the expected one of the active session */
    *din_response_code = ((conn->ctx->current_v2g_msg != V2G_SESSION_SETUP_MSG) &&
                          (conn->ctx->evse_v2g_data.session_id != conn->ctx->ev_v2g_data.received_session_id))
                             ? din_responseCodeType_FAILED_UnknownSession
                             : *din_response_code;

    if ((conn->ctx->terminate_connection_on_failed_response == true) &&
        (*din_response_code >= din_responseCodeType_FAILED)) {
        nextEvent = V2G_EVENT_SEND_AND_TERMINATE; // [V2G-DC-665]
    }

    /* log failed response code message */
    if (*din_response_code >= din_responseCodeType_FAILED &&
        *din_response_code <= din_responseCodeType_FAILED_WrongEnergyTransferType) {
        dlog(DLOG_LEVEL_ERROR, "Failed response code detected for message \"%s\", error: %s",
             v2g_msg_type[conn->ctx->current_v2g_msg], dinResponse[*din_response_code]);
    }

    return nextEvent;
}
} // namespace utils

/*!
 * \brief publish_DIN_DcEvStatus This function is a helper function to publish EVStatusType.
 * \param ctx is a pointer to the V2G context.
 * \param din_ev_status the structure the holds the EV Status elements.
 */
static void publish_DIN_DcEvStatus(struct v2g_context* ctx, const struct din_DC_EVStatusType& din_ev_status) {
    if ((ctx->ev_v2g_data.din_dc_ev_status.EVErrorCode != din_ev_status.EVErrorCode) ||
        (ctx->ev_v2g_data.din_dc_ev_status.EVReady != din_ev_status.EVReady) ||
        (ctx->ev_v2g_data.din_dc_ev_status.EVRESSSOC != din_ev_status.EVRESSSOC)) {
        ctx->ev_v2g_data.din_dc_ev_status.EVErrorCode = din_ev_status.EVErrorCode;
        ctx->ev_v2g_data.din_dc_ev_status.EVReady = din_ev_status.EVReady;
        ctx->ev_v2g_data.din_dc_ev_status.EVRESSSOC = din_ev_status.EVRESSSOC;

        types::iso15118::DcEvStatus ev_status;
        ev_status.dc_ev_error_code = static_cast<types::iso15118::DcEvErrorCode>(din_ev_status.EVErrorCode);
        ev_status.dc_ev_ready = din_ev_status.EVReady;
        ev_status.dc_ev_ress_soc = static_cast<float>(din_ev_status.EVRESSSOC);
        ctx->p_charger->publish_dc_ev_status(ev_status);
    }
}

//=============================================
//             Publishing request msg
//=============================================

/*!
 * \brief publish_din_service_discovery_req This function publishes the din_ServiceDiscoveryReqType message to the MQTT
 * interface. \param ctx is the V2G context. \param din_ServiceDiscoveryReqType is the request message.
 */
static void
publish_din_service_discovery_req(struct v2g_context* ctx,
                                  struct din_ServiceDiscoveryReqType const* const v2g_service_discovery_req) {
    // V2G values that can be published: ServiceCategory, ServiceScope
}

/*!
 * \brief publish_din_service_payment_selection_req This function publishes the din_ServicePaymentSelectionReqType
 * message to the MQTT interface.
 * \param ctx is the V2G context.
 * \param v2g_payment_service_selection_req is the request message.
 */
static void publish_din_service_payment_selection_req(
    struct v2g_context* ctx, struct din_ServicePaymentSelectionReqType const* const v2g_payment_service_selection_req) {
    // V2G values that can be published: selected_payment_option, SelectedServiceList
}

/*!
 * \brief publish_din_charge_parameter_discovery_req This function publishes the din_ChargeParameterDiscoveryReqType
 * message to the MQTT interface.
 * \param ctx is the V2G context.
 * \param v2g_charge_parameter_discovery_req is the request message.
 */
static void publish_din_charge_parameter_discovery_req(
    struct v2g_context* ctx,
    struct din_ChargeParameterDiscoveryReqType const* const v2g_charge_parameter_discovery_req) {
    // V2G values that can be published: DC_EVChargeParameter, MaxEntriesSAScheduleTuple
    ctx->p_charger->publish_requested_energy_transfer_mode(static_cast<types::iso15118::EnergyTransferMode>(
        v2g_charge_parameter_discovery_req->EVRequestedEnergyTransferType));
    if (v2g_charge_parameter_discovery_req->DC_EVChargeParameter_isUsed == (unsigned int)1) {

        if (v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyCapacity_isUsed == (unsigned int)1) {
            ctx->p_charger->publish_dc_ev_energy_capacity(calc_physical_value(
                v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyCapacity.Value,
                v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyCapacity.Multiplier));
        }
        if (v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyRequest_isUsed == (unsigned int)1) {
            ctx->p_charger->publish_dc_ev_energy_request(calc_physical_value(
                v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyRequest.Value,
                v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyRequest.Multiplier));
        }
        if (v2g_charge_parameter_discovery_req->DC_EVChargeParameter.FullSOC_isUsed == (unsigned int)1) {
            ctx->p_charger->publish_dc_full_soc(v2g_charge_parameter_discovery_req->DC_EVChargeParameter.FullSOC);
        }
        if (v2g_charge_parameter_discovery_req->DC_EVChargeParameter.BulkSOC_isUsed == (unsigned int)1) {
            ctx->p_charger->publish_dc_bulk_soc(v2g_charge_parameter_discovery_req->DC_EVChargeParameter.BulkSOC);
        }

        float evMaximumCurrentLimit = calc_physical_value(
            v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVMaximumCurrentLimit.Value,
            v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVMaximumCurrentLimit.Multiplier);
        float evMaximumPowerLimit = calc_physical_value(
            v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVMaximumPowerLimit.Value,
            v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVMaximumPowerLimit.Multiplier);
        float evMaximumVoltageLimit = calc_physical_value(
            v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVMaximumVoltageLimit.Value,
            v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVMaximumVoltageLimit.Multiplier);
        publish_dc_ev_maximum_limits(
            ctx, evMaximumCurrentLimit, (unsigned int)1, evMaximumPowerLimit,
            v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVMaximumPowerLimit_isUsed, evMaximumVoltageLimit,
            (unsigned int)1);
        publish_DIN_DcEvStatus(ctx, v2g_charge_parameter_discovery_req->DC_EVChargeParameter.DC_EVStatus);
    }
}

/*!
 * \brief publish_din_power_delivery_req This function publishes the din_PowerDeliveryReqType message to the MQTT
 * interface. \param ctx is the V2G context. \param din_power_delivery_req is the request message.
 */
static void publish_din_power_delivery_req(struct v2g_context* ctx,
                                           struct din_PowerDeliveryReqType const* const v2g_power_delivery_req) {
    // V2G values that can be published: ReadyToChargeState
    if (v2g_power_delivery_req->DC_EVPowerDeliveryParameter_isUsed == (unsigned int)1) {
        ctx->p_charger->publish_dc_charging_complete(
            v2g_power_delivery_req->DC_EVPowerDeliveryParameter.ChargingComplete);
        if (v2g_power_delivery_req->DC_EVPowerDeliveryParameter.BulkChargingComplete_isUsed == (unsigned int)1) {
            ctx->p_charger->publish_dc_bulk_charging_complete(
                v2g_power_delivery_req->DC_EVPowerDeliveryParameter.BulkChargingComplete);
        }
        publish_DIN_DcEvStatus(ctx, v2g_power_delivery_req->DC_EVPowerDeliveryParameter.DC_EVStatus);
    }
}

/*!
 * \brief publish_din_precharge_req This function publishes the din_PreChargeReqType message to the MQTT interface.
 * \param ctx is the V2G context.
 * \param v2g_precharge_req is the request message.
 */
static void publish_din_precharge_req(struct v2g_context* ctx,
                                      struct din_PreChargeReqType const* const v2g_precharge_req) {
    publish_dc_ev_target_voltage_current(
        ctx,
        calc_physical_value(v2g_precharge_req->EVTargetVoltage.Value, v2g_precharge_req->EVTargetVoltage.Multiplier),
        calc_physical_value(v2g_precharge_req->EVTargetCurrent.Value, v2g_precharge_req->EVTargetCurrent.Multiplier));
    publish_DIN_DcEvStatus(ctx, v2g_precharge_req->DC_EVStatus);
}

/*!
 * \brief publish_din_current_demand_req This function publishes the din_CurrentDemandReqType message to the MQTT
 * interface. \param ctx is the V2G context. \param v2g_current_demand_req is the request message.
 */
static void publish_din_current_demand_req(struct v2g_context* ctx,
                                           struct din_CurrentDemandReqType const* const v2g_current_demand_req) {
    if ((v2g_current_demand_req->BulkChargingComplete_isUsed == (unsigned int)1) &&
        (ctx->ev_v2g_data.bulk_charging_complete != v2g_current_demand_req->BulkChargingComplete)) {
        ctx->p_charger->publish_dc_bulk_charging_complete(v2g_current_demand_req->BulkChargingComplete);
        ctx->ev_v2g_data.bulk_charging_complete = v2g_current_demand_req->BulkChargingComplete;
    }
    if (ctx->ev_v2g_data.charging_complete != v2g_current_demand_req->ChargingComplete) {
        ctx->p_charger->publish_dc_charging_complete(v2g_current_demand_req->ChargingComplete);
        ctx->ev_v2g_data.charging_complete = v2g_current_demand_req->ChargingComplete;
    }

    publish_DIN_DcEvStatus(ctx, v2g_current_demand_req->DC_EVStatus);

    publish_dc_ev_target_voltage_current(ctx,
                                         calc_physical_value(v2g_current_demand_req->EVTargetVoltage.Value,
                                                             v2g_current_demand_req->EVTargetVoltage.Multiplier),
                                         calc_physical_value(v2g_current_demand_req->EVTargetCurrent.Value,
                                                             v2g_current_demand_req->EVTargetCurrent.Multiplier));

    float evMaximumCurrentLimit = calc_physical_value(v2g_current_demand_req->EVMaximumCurrentLimit.Value,
                                                      v2g_current_demand_req->EVMaximumCurrentLimit.Multiplier);
    float evMaximumPowerLimit = calc_physical_value(v2g_current_demand_req->EVMaximumPowerLimit.Value,
                                                    v2g_current_demand_req->EVMaximumPowerLimit.Multiplier);
    float evMaximumVoltageLimit = calc_physical_value(v2g_current_demand_req->EVMaximumVoltageLimit.Value,
                                                      v2g_current_demand_req->EVMaximumVoltageLimit.Multiplier);
    publish_dc_ev_maximum_limits(ctx, evMaximumCurrentLimit, v2g_current_demand_req->EVMaximumCurrentLimit_isUsed,
                                 evMaximumPowerLimit, v2g_current_demand_req->EVMaximumPowerLimit_isUsed,
                                 evMaximumVoltageLimit, v2g_current_demand_req->EVMaximumVoltageLimit_isUsed);

    float v2g_dc_ev_remaining_time_to_full_soc =
        calc_physical_value(v2g_current_demand_req->RemainingTimeToFullSoC.Value,
                            v2g_current_demand_req->RemainingTimeToFullSoC.Multiplier);
    float v2g_dc_ev_remaining_time_to_bulk_soc =
        calc_physical_value(v2g_current_demand_req->RemainingTimeToBulkSoC.Value,
                            v2g_current_demand_req->RemainingTimeToBulkSoC.Multiplier);

    publish_dc_ev_remaining_time(
        ctx, v2g_dc_ev_remaining_time_to_full_soc, v2g_current_demand_req->RemainingTimeToFullSoC_isUsed,
        v2g_dc_ev_remaining_time_to_bulk_soc, v2g_current_demand_req->RemainingTimeToBulkSoC_isUsed);
}

//=============================================
//             Request Handling
//=============================================

namespace states {

/*!
 * \brief handle_iso_session_setup This function handles the din_session_setup msg pair. It analyzes the request msg and
 * fills the response msg. The request and response msg based on the open V2G structures. This structures must be
 * provided within the \c conn structure. [V2G-DC-436]
 * \param conn holds the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
enum v2g_event handle_din_session_setup(struct v2g_connection* conn) {
    struct din_SessionSetupReqType* req = &conn->exi_in.dinEXIDocument->V2G_Message.Body.SessionSetupReq;
    struct din_SessionSetupResType* res = &conn->exi_out.dinEXIDocument->V2G_Message.Body.SessionSetupRes;
    enum v2g_event nextEvent = V2G_EVENT_NO_EVENT;
    char buffer[din_evccIDType_BYTES_SIZE * 2 + din_evccIDType_BYTES_SIZE - 1 +
                1]; /* format: (%02x:) * n - 1x ':' + 1x NUL */
    int idx;

    /* format EVCC ID */
    for (idx = 0; idx < req->EVCCID.bytesLen; idx++) {
        sprintf(&buffer[idx * 3], "%02" PRIX8 ":", req->EVCCID.bytes[idx]);
    }
    if (idx)
        buffer[idx * 3 - 1] = '\0';
    else
        buffer[0] = '\0';

    conn->ctx->p_charger->publish_evcc_id(buffer); // publish EVCC ID

    dlog(DLOG_LEVEL_INFO, "SessionSetupReq.EVCCID: %s", std::string(buffer).size() ? buffer : "(zero length provided)");

    /* Now fill the evse response message */
    res->ResponseCode = din_responseCodeType_OK_NewSessionEstablished; // [V2G-DC-393]

    /* Check and init session id */
    /* If the customer doesen't select a session id, generate one */
    srand((unsigned int)time(NULL));
    if (conn->ctx->evse_v2g_data.session_id == (uint64_t)0) {
        conn->ctx->evse_v2g_data.session_id =
            ((uint64_t)rand() << 48) | ((uint64_t)rand() << 32) | ((uint64_t)rand() << 16) | (uint64_t)rand();
        dlog(DLOG_LEVEL_INFO, "No session_id found. Generating random session id.");
    }

    dlog(DLOG_LEVEL_INFO, "Created new session with id 0x%08" PRIu64, conn->ctx->evse_v2g_data.session_id);

    res->EVSEID.bytesLen = std::min((int)conn->ctx->evse_v2g_data.evse_id.bytesLen, iso2_EVSEID_CHARACTER_SIZE);
    memcpy(res->EVSEID.bytes, conn->ctx->evse_v2g_data.evse_id.bytes, res->EVSEID.bytesLen);

    res->DateTimeNow_isUsed = conn->ctx->evse_v2g_data.date_time_now_is_used;
    res->DateTimeNow = time(NULL);

    /* Check the current response code and check if no external error has occurred */
    nextEvent = utils::din_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = WAIT_FOR_SERVICEDISCOVERY; // [V2G-DC-438]

    return nextEvent;
}

/*!
 * \brief handle_din_service_discovery This function handles the din service discovery msg pair. It analyzes the request
 * msg and fills the response msg. The request and response msg based on the open V2G structures. This structures must
 * be provided within the \c conn structure. [V2G-DC-440]
 * \param conn is the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
enum v2g_event handle_din_service_discovery(struct v2g_connection* conn) {
    struct din_ServiceDiscoveryReqType* req = &conn->exi_in.dinEXIDocument->V2G_Message.Body.ServiceDiscoveryReq;
    struct din_ServiceDiscoveryResType* res = &conn->exi_out.dinEXIDocument->V2G_Message.Body.ServiceDiscoveryRes;
    enum v2g_event nextEvent = V2G_EVENT_NO_EVENT;

    /* At first, publish the received EV request message to the MQTT interface */
    publish_din_service_discovery_req(conn->ctx, req);

    /* Now fill the evse response message */
    res->ResponseCode = din_responseCodeType_OK; // [V2G-DC-388]

    if ((conn->ctx->evse_v2g_data.charge_service.SupportedEnergyTransferMode.EnergyTransferMode.array[0] !=
         iso2_EnergyTransferModeType_DC_core) &&
        (conn->ctx->evse_v2g_data.charge_service.SupportedEnergyTransferMode.EnergyTransferMode.array[0]) !=
            iso2_EnergyTransferModeType_DC_extended) {
        conn->ctx->evse_v2g_data.charge_service.SupportedEnergyTransferMode.EnergyTransferMode.array[0] =
            iso2_EnergyTransferModeType_DC_extended;
        dlog(DLOG_LEVEL_WARNING, "Selected EnergyTransferType is not supported in DIN 70121. Correcting value of field "
                                 "SupportedEnergyTransferType0 to 'DC_extended'");
    }

    res->ChargeService.ServiceTag.ServiceID =
        conn->ctx->evse_v2g_data.charge_service.ServiceID;               // ID of the charge service
    res->ChargeService.ServiceTag.ServiceName_isUsed = (unsigned int)0;  // [V2G-DC-628] Shall not be used in DIN 70121
    res->ChargeService.ServiceTag.ServiceScope_isUsed = (unsigned int)0; // [V2G-DC-629] Shall not be used in DIN 70121
    res->ChargeService.ServiceTag.ServiceCategory = din_serviceCategoryType_EVCharging; // Is fixed
    res->ChargeService.FreeService = conn->ctx->evse_v2g_data.charge_service.FreeService;
    res->ChargeService.EnergyTransferType =
        (din_EVSESupportedEnergyTransferType)
            conn->ctx->evse_v2g_data.charge_service.SupportedEnergyTransferMode.EnergyTransferMode.array[0];

    res->ServiceList_isUsed = 0; // Shall not be used in DIN 70121

    // In the scope of DIN 70121 only ExternalPayment shall be used.
    res->PaymentOptions.PaymentOption.array[0] = din_paymentOptionType_ExternalPayment;
    res->PaymentOptions.PaymentOption.arrayLen = 1;

    /* Check the current response code and check if no external error has occurred */
    nextEvent = utils::din_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = WAIT_FOR_PAYMENTSERVICESELECTION; // [V2G-DC-441]

    return nextEvent;
}

} // namespace states

/*!
 * \brief handle_din_service_discovery This function handles the din service payment selection msg pair. It analyzes the
 * request msg and fills the response msg. The request and response msg based on the open V2G structures. This
 * structures must be provided within the \c conn structure. [V2G-DC-443]
 * \param conn is the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_din_service_payment_selection(struct v2g_connection* conn) {
    struct din_ServicePaymentSelectionReqType* req =
        &conn->exi_in.dinEXIDocument->V2G_Message.Body.ServicePaymentSelectionReq;
    struct din_ServicePaymentSelectionResType* res =
        &conn->exi_out.dinEXIDocument->V2G_Message.Body.ServicePaymentSelectionRes;
    enum v2g_event nextEvent = V2G_EVENT_NO_EVENT;

    /* At first, publish the received EV request message to the customer MQTT interface */
    publish_din_service_payment_selection_req(conn->ctx, req);

    /* Now fill the evse response message */
    res->ResponseCode = din_responseCodeType_OK; // [V2G-DC-388]

    res->ResponseCode = (req->SelectedPaymentOption != din_paymentOptionType_ExternalPayment)
                            ? din_responseCodeType_FAILED_PaymentSelectionInvalid
                            : res->ResponseCode; // [V2G-DC-395]

    res->ResponseCode = (req->SelectedServiceList.SelectedService.arrayLen == (uint16_t)1 &&
                         (req->SelectedServiceList.SelectedService.array[0].ServiceID ==
                          conn->ctx->evse_v2g_data.charge_service.ServiceID))
                            ? res->ResponseCode
                            : din_responseCodeType_FAILED_ServiceSelectionInvalid; // [V2G-DC-396] [V2G-DC-635] (List
                                                                                   // shall be limited to 1)

    /* Check the current response code and check if no external error has occurred */
    nextEvent = utils::din_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = WAIT_FOR_AUTHORIZATION; // [V2G-DC-444]

    return nextEvent;
}

/*!
 * \brief handle_din_service_discovery This function handles the din contract authentication msg pair. It analyzes the
 * request msg and fills the response msg. The request and response msg based on the open V2G structures. This
 * structures must be provided within the \c conn structure. [V2G-DC-494]
 * \param conn is the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
enum v2g_event states::handle_din_contract_authentication(struct v2g_connection* conn) {
    struct din_ContractAuthenticationResType* res =
        &conn->exi_out.dinEXIDocument->V2G_Message.Body.ContractAuthenticationRes;
    enum v2g_event nextEvent = V2G_EVENT_NO_EVENT;

    /* Fill the EVSE response message */
    res->ResponseCode = din_responseCodeType_OK; // [V2G-DC-388]
    res->EVSEProcessing = (conn->ctx->evse_v2g_data.evse_processing[PHASE_AUTH] == (uint8_t)0)
                              ? din_EVSEProcessingType_Finished
                              : din_EVSEProcessingType_Ongoing;

    /* Check the current response code and check if no external error has occurred */
    nextEvent = utils::din_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = (res->EVSEProcessing == din_EVSEProcessingType_Ongoing)
                           ? WAIT_FOR_AUTHORIZATION
                           : WAIT_FOR_CHARGEPARAMETERDISCOVERY; // [V2G-DC-444], [V2G-DC-497]

    return nextEvent;
}

/*!
 * \brief handle_din_charge_parameter This function handles the din charge parameters msg pair. It analyzes the request
 * msg and fills the response msg. The request and response msg based on the open V2G structures. This structures must
 * be provided within the \c conn structure. [V2G-DC-445]
 * \param conn is the structure with the v2g msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_din_charge_parameter(struct v2g_connection* conn) {
    struct din_ChargeParameterDiscoveryReqType* req =
        &conn->exi_in.dinEXIDocument->V2G_Message.Body.ChargeParameterDiscoveryReq;
    struct din_ChargeParameterDiscoveryResType* res =
        &conn->exi_out.dinEXIDocument->V2G_Message.Body.ChargeParameterDiscoveryRes;
    enum v2g_event nextEvent = V2G_EVENT_NO_EVENT;

    /* At first, publish the received EV request message to the customer MQTT interface */
    publish_din_charge_parameter_discovery_req(conn->ctx, req);

    /* Now fill the EVSE response message */
    res->ResponseCode = din_responseCodeType_OK; // [V2G-DC-388]
    res->AC_EVSEChargeParameter_isUsed = 0u;

    if (((req->EVRequestedEnergyTransferType != din_EVRequestedEnergyTransferType_DC_core) &&
         (req->EVRequestedEnergyTransferType != din_EVRequestedEnergyTransferType_DC_extended)) ||
        conn->ctx->evse_v2g_data.charge_service.SupportedEnergyTransferMode.EnergyTransferMode.array[0] !=
            (iso2_EnergyTransferModeType)req->EVRequestedEnergyTransferType) {
        res->ResponseCode = din_responseCodeType_FAILED_WrongEnergyTransferType; // [V2G-DC-397] Failed reponse code is
                                                                                 // logged at the end of the function
    } else {
        log_selected_energy_transfer_type((int)req->EVRequestedEnergyTransferType);
    }

    res->ResponseCode = (req->AC_EVChargeParameter_isUsed == (unsigned int)1)
                            ? din_responseCodeType_FAILED_WrongChargeParameter
                            : res->ResponseCode; // [V2G-DC-398]

    /* DC_EVSEChargeParameter */
    res->DC_EVSEChargeParameter.DC_EVSEStatus.EVSEIsolationStatus =
        (din_isolationLevelType)conn->ctx->evse_v2g_data.evse_isolation_status;
    res->DC_EVSEChargeParameter.DC_EVSEStatus.EVSEIsolationStatus_isUsed =
        conn->ctx->evse_v2g_data.evse_isolation_status_is_used;

    res->DC_EVSEChargeParameter.DC_EVSEStatus.EVSENotification =
        (din_EVSENotificationType)conn->ctx->evse_v2g_data.evse_notification;
    res->DC_EVSEChargeParameter.DC_EVSEStatus.EVSEStatusCode =
        (true == conn->ctx->intl_emergency_shutdown)
            ? din_DC_EVSEStatusCodeType_EVSE_EmergencyShutdown
            : (din_DC_EVSEStatusCodeType)conn->ctx->evse_v2g_data.evse_status_code[PHASE_PARAMETER];
    res->DC_EVSEChargeParameter.DC_EVSEStatus.NotificationMaxDelay = conn->ctx->evse_v2g_data.notification_max_delay;

    if (conn->ctx->evse_v2g_data.evse_current_regulation_tolerance_is_used) {
        load_din_physical_value(&res->DC_EVSEChargeParameter.EVSECurrentRegulationTolerance,
                                &conn->ctx->evse_v2g_data.evse_current_regulation_tolerance);
        res->DC_EVSEChargeParameter.EVSECurrentRegulationTolerance.Unit_isUsed = (unsigned int)1;
    }
    res->DC_EVSEChargeParameter.EVSECurrentRegulationTolerance_isUsed =
        conn->ctx->evse_v2g_data.evse_current_regulation_tolerance_is_used;

    load_din_physical_value(&res->DC_EVSEChargeParameter.EVSEEnergyToBeDelivered,
                            &conn->ctx->evse_v2g_data.evse_energy_to_be_delivered);
    res->DC_EVSEChargeParameter.EVSEEnergyToBeDelivered_isUsed =
        conn->ctx->evse_v2g_data.evse_energy_to_be_delivered_is_used;

    load_din_physical_value(&res->DC_EVSEChargeParameter.EVSEMaximumCurrentLimit,
                            &conn->ctx->evse_v2g_data.evse_maximum_current_limit);

    load_din_physical_value(&res->DC_EVSEChargeParameter.EVSEMaximumPowerLimit,
                            &conn->ctx->evse_v2g_data.evse_maximum_power_limit);
    res->DC_EVSEChargeParameter.EVSEMaximumPowerLimit_isUsed =
        conn->ctx->evse_v2g_data.evse_maximum_power_limit_is_used;

    load_din_physical_value(&res->DC_EVSEChargeParameter.EVSEMaximumVoltageLimit,
                            &conn->ctx->evse_v2g_data.evse_maximum_voltage_limit);

    load_din_physical_value(&res->DC_EVSEChargeParameter.EVSEMinimumCurrentLimit,
                            &conn->ctx->evse_v2g_data.evse_minimum_current_limit);

    load_din_physical_value(&res->DC_EVSEChargeParameter.EVSEMinimumVoltageLimit,
                            &conn->ctx->evse_v2g_data.evse_minimum_voltage_limit);

    load_din_physical_value(&res->DC_EVSEChargeParameter.EVSEPeakCurrentRipple,
                            &conn->ctx->evse_v2g_data.evse_peak_current_ripple);
    res->DC_EVSEChargeParameter_isUsed = (unsigned int)1;

    // res->EVSEChargeParameter.noContent
    res->EVSEChargeParameter_isUsed = (unsigned int)0;
    res->EVSEProcessing = ((uint8_t)0 == conn->ctx->evse_v2g_data.evse_processing[PHASE_PARAMETER])
                              ? din_EVSEProcessingType_Finished
                              : din_EVSEProcessingType_Ongoing;

    if ((unsigned int)1 == res->DC_EVSEChargeParameter.EVSEMaximumPowerLimit_isUsed) {
        res->SAScheduleList.SAScheduleTuple.array[0].PMaxSchedule.PMaxScheduleEntry.array[0].PMax =
            (SHRT_MAX < (conn->ctx->evse_v2g_data.evse_maximum_power_limit.Value *
                         pow(10, conn->ctx->evse_v2g_data.evse_maximum_power_limit.Multiplier)))
                ? SHRT_MAX
                : (conn->ctx->evse_v2g_data.evse_maximum_power_limit.Value *
                   pow(10, conn->ctx->evse_v2g_data.evse_maximum_power_limit.Multiplier));
    } else {
        res->SAScheduleList.SAScheduleTuple.array[0].PMaxSchedule.PMaxScheduleEntry.array[0].PMax = SHRT_MAX;
    }
    res->SAScheduleList.SAScheduleTuple.array[0].PMaxSchedule.PMaxScheduleEntry.array[0].RelativeTimeInterval.duration =
        SA_SCHEDULE_DURATION; // Must cover 24 hours
    res->SAScheduleList.SAScheduleTuple.array[0]
        .PMaxSchedule.PMaxScheduleEntry.array[0]
        .RelativeTimeInterval.duration_isUsed = 1; // Must be used in DIN
    res->SAScheduleList.SAScheduleTuple.array[0].PMaxSchedule.PMaxScheduleEntry.array[0].RelativeTimeInterval.start = 0;
    res->SAScheduleList.SAScheduleTuple.array[0].PMaxSchedule.PMaxScheduleEntry.array[0].RelativeTimeInterval_isUsed =
        1;
    res->SAScheduleList.SAScheduleTuple.array[0].PMaxSchedule.PMaxScheduleEntry.array[0].TimeInterval_isUsed =
        0; // no content

    res->SAScheduleList.SAScheduleTuple.array[0].SalesTariff_isUsed =
        0; // In the scope of DIN 70121, this optional element shall not be used. [V2G-DC-554]
    res->SAScheduleList.SAScheduleTuple.array[0].SAScheduleTupleID = SASCHEDULETUPLEID;
    res->SAScheduleList.SAScheduleTuple.array[0].PMaxSchedule.PMaxScheduleEntry.arrayLen = 1;
    res->SAScheduleList.SAScheduleTuple.array[0].PMaxSchedule.PMaxScheduleID = 1;
    res->SAScheduleList.SAScheduleTuple.arrayLen = 1;
    res->SAScheduleList_isUsed = (unsigned int)1;

    // res->SASchedules.noContent
    res->SASchedules_isUsed = (unsigned int)0;

    /* Check the current response code and check if no external error has occurred */
    nextEvent = utils::din_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    if (res->EVSEProcessing == din_EVSEProcessingType_Finished) {
        if (res->DC_EVSEChargeParameter.DC_EVSEStatus.EVSEStatusCode != din_DC_EVSEStatusCodeType_EVSE_Ready) {
            dlog(DLOG_LEVEL_WARNING,
                 "EVSE wants to finish charge parameter phase, but status code is not set to 'ready' (1)");
        }
        conn->ctx->state = WAIT_FOR_CABLECHECK; // [V2G-DC-453]
    } else {
        conn->ctx->state = WAIT_FOR_CHARGEPARAMETERDISCOVERY; // [V2G-DC-498]
    }

    return nextEvent;
}

/*!
 * \brief handle_din_service_discovery This function handles the din power delivery msg pair. It analyzes the request
 * msg and fills the response msg. The request and response msg based on the open V2G structures. This structures must
 * be provided within the \c conn structure. [V2G-DC-461]
 * \param conn is the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_din_power_delivery(struct v2g_connection* conn) {
    struct din_PowerDeliveryReqType* req = &conn->exi_in.dinEXIDocument->V2G_Message.Body.PowerDeliveryReq;
    struct din_PowerDeliveryResType* res = &conn->exi_out.dinEXIDocument->V2G_Message.Body.PowerDeliveryRes;
    enum v2g_event nextEvent = V2G_EVENT_NO_EVENT;

    /* At first, publish the received EV request message to the MQTT interface */
    publish_din_power_delivery_req(conn->ctx, req);

    if (req->ReadyToChargeState == (int)0) {
        conn->ctx->p_charger->publish_current_demand_finished(nullptr);
        conn->ctx->p_charger->publish_dc_open_contactor(nullptr);
        conn->ctx->session.is_charging = false;
    } else {
        conn->ctx->p_charger->publish_v2g_setup_finished(nullptr);
    }

    /* Now fill the evse response message */
    res->ResponseCode = din_responseCodeType_OK; // [V2G-DC-388]

    res->AC_EVSEStatus_isUsed = (unsigned int)0;
    res->DC_EVSEStatus.EVSEIsolationStatus = (din_isolationLevelType)conn->ctx->evse_v2g_data.evse_isolation_status;
    res->DC_EVSEStatus.EVSEIsolationStatus_isUsed = conn->ctx->evse_v2g_data.evse_isolation_status_is_used;
    res->DC_EVSEStatus.EVSENotification = (din_EVSENotificationType)conn->ctx->evse_v2g_data.evse_notification;
    res->DC_EVSEStatus.NotificationMaxDelay = conn->ctx->evse_v2g_data.notification_max_delay;
    res->DC_EVSEStatus.EVSEStatusCode =
        (conn->ctx->intl_emergency_shutdown == true)
            ? din_DC_EVSEStatusCodeType_EVSE_EmergencyShutdown
            : (din_DC_EVSEStatusCodeType)conn->ctx->evse_v2g_data.evse_status_code[PHASE_CHARGE];
    res->DC_EVSEStatus_isUsed = (unsigned int)1;
    res->EVSEStatus_isUsed = (unsigned int)0;
    // res->EVSEStatus.noContent

    /* Check response code */
    if (req->ChargingProfile_isUsed == (unsigned int)1) {
        /* Check the selected SAScheduleTupleID */
        res->ResponseCode = (req->ChargingProfile.SAScheduleTupleID != (int16_t)SASCHEDULETUPLEID)
                                ? din_responseCodeType_FAILED_TariffSelectionInvalid
                                : res->ResponseCode; // [V2G-DC-400]

        for (uint16_t idx = 0; idx < req->ChargingProfile.ProfileEntry.arrayLen; idx++) {
            bool entry_found = (req->ChargingProfile.ProfileEntry.array[idx].ChargingProfileEntryStart <=
                                (uint32_t)SA_SCHEDULE_DURATION);

            if ((entry_found == false) || (req->ChargingProfile.ProfileEntry.array[idx].ChargingProfileEntryMaxPower >
                                           (conn->ctx->evse_v2g_data.evse_maximum_power_limit.Value *
                                            pow(10, conn->ctx->evse_v2g_data.evse_maximum_power_limit.Multiplier)))) {
                // res->ResponseCode = din_responseCodeType_FAILED_ChargingProfileInvalid; //[V2G-DC-399]. Currently
                // commented to increase compatibility with EV'S
                dlog(DLOG_LEVEL_WARNING, "EV's charging profile is invalid (ChargingProfileEntryMaxPower %d too high)!",
                     req->ChargingProfile.ProfileEntry.array[idx].ChargingProfileEntryMaxPower);
                break;
            }
        }
    }

    res->ResponseCode = ((req->ReadyToChargeState == (int)1) &&
                         (res->DC_EVSEStatus.EVSEStatusCode != din_DC_EVSEStatusCodeType_EVSE_Ready))
                            ? din_responseCodeType_FAILED_PowerDeliveryNotApplied
                            : res->ResponseCode; // [V2G-DC-401]

    /* Check the current response code and check if no external error has occurred */
    nextEvent = utils::din_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    if ((req->ReadyToChargeState == (int)1) && (V2G_CURRENT_DEMAND_MSG != conn->ctx->last_v2g_msg)) {
        conn->ctx->state = WAIT_FOR_CURRENTDEMAND; // [V2G-DC-462]
    } else {
        /* abort charging session if EV is ready to charge after current demand phase */
        if (req->ReadyToChargeState == (int)1) {
            res->ResponseCode = din_responseCodeType_FAILED;
            nextEvent = V2G_EVENT_SEND_AND_TERMINATE;
        }
        conn->ctx->state = WAIT_FOR_WELDINGDETECTION_SESSIONSTOP; // [V2G-DC-459]
    }

    return nextEvent;
}

/*!
 * \brief handle_din_service_discovery This function handles the din cable check msg pair. It analyzes the request msg
 * and fills the response msg. The request and response msg based on the open V2G structures. This structures must be
 * provided within the \c conn structure. [V2G-DC-454]
 * \param conn is the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_din_cable_check(struct v2g_connection* conn) {
    struct din_CableCheckReqType* req = &conn->exi_in.dinEXIDocument->V2G_Message.Body.CableCheckReq;
    struct din_CableCheckResType* res = &conn->exi_out.dinEXIDocument->V2G_Message.Body.CableCheckRes;
    enum v2g_event nextEvent = V2G_EVENT_NO_EVENT;

    /* At first, publish the received EV request message to the MQTT interface */
    publish_DIN_DcEvStatus(conn->ctx, req->DC_EVStatus);

    // TODO: Wait for CP state C [V2G-DC-547]

    /* Now fill the evse response message */
    res->ResponseCode = din_responseCodeType_OK; // [V2G-DC-388]

    res->DC_EVSEStatus.EVSEIsolationStatus = (din_isolationLevelType)conn->ctx->evse_v2g_data.evse_isolation_status;
    res->DC_EVSEStatus.EVSEIsolationStatus_isUsed = conn->ctx->evse_v2g_data.evse_isolation_status_is_used;
    res->DC_EVSEStatus.EVSENotification =
        static_cast<din_EVSENotificationType>(conn->ctx->evse_v2g_data.evse_notification);
    res->DC_EVSEStatus.NotificationMaxDelay = static_cast<uint32_t>(conn->ctx->evse_v2g_data.notification_max_delay);
    res->EVSEProcessing = (conn->ctx->evse_v2g_data.evse_processing[PHASE_ISOLATION] == (uint8_t)0)
                              ? din_EVSEProcessingType_Finished
                              : din_EVSEProcessingType_Ongoing;

    if (conn->ctx->intl_emergency_shutdown == true) {
        res->DC_EVSEStatus.EVSEStatusCode = din_DC_EVSEStatusCodeType_EVSE_EmergencyShutdown;
    } else if (res->EVSEProcessing == din_EVSEProcessingType_Finished) {
        res->DC_EVSEStatus.EVSEStatusCode = din_DC_EVSEStatusCodeType_EVSE_Ready;
    } else {
        res->DC_EVSEStatus.EVSEStatusCode =
            static_cast<din_DC_EVSEStatusCodeType>(conn->ctx->evse_v2g_data.evse_status_code[PHASE_ISOLATION]);
    }

    /* Check the current response code and check if no external error has occurred */
    nextEvent = utils::din_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    if ((res->EVSEProcessing == din_EVSEProcessingType_Finished) &&
        (res->DC_EVSEStatus.EVSEIsolationStatus_isUsed == (unsigned int)1) &&
        ((res->DC_EVSEStatus.EVSEIsolationStatus == din_isolationLevelType_Valid) ||
         (res->DC_EVSEStatus.EVSEIsolationStatus == din_isolationLevelType_Warning)) &&
        (res->DC_EVSEStatus.EVSEStatusCode == din_DC_EVSEStatusCodeType_EVSE_Ready)) {
        conn->ctx->state = WAIT_FOR_PRECHARGE; // [V2G-DC-499]
    } else {
        if ((res->EVSEProcessing == din_EVSEProcessingType_Finished) &&
            ((res->DC_EVSEStatus.EVSEIsolationStatus_isUsed == (unsigned int)0) ||
             ((res->DC_EVSEStatus.EVSEIsolationStatus != din_isolationLevelType_Valid) &&
              (din_isolationLevelType_Warning != res->DC_EVSEStatus.EVSEIsolationStatus)))) {
            dlog(DLOG_LEVEL_WARNING, "EVSE wants to finish cable check phase, but either status code is not set to "
                                     "'ready' (1) or isolation status is not valid");
        }

        conn->ctx->state = WAIT_FOR_CABLECHECK; // [V2G-DC-455]
    }

    return nextEvent;
}

/*!
 * \brief handle_din_service_discovery This function handles the din pre charge msg pair. It analyzes the request msg
 * and fills the response msg. The request and response msg based on the open V2G structures. This structures must be
 * provided within the \c conn structure. [V2G-DC-457]
 * \param conn is the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_din_pre_charge(struct v2g_connection* conn) {
    struct din_PreChargeReqType* req = &conn->exi_in.dinEXIDocument->V2G_Message.Body.PreChargeReq;
    struct din_PreChargeResType* res = &conn->exi_out.dinEXIDocument->V2G_Message.Body.PreChargeRes;
    enum v2g_event nextEvent = V2G_EVENT_NO_EVENT;

    /* At first, publish the received EV request message to the customer MQTT interface */
    publish_din_precharge_req(conn->ctx, req);

    /* Now fill the EVSE response message */
    res->ResponseCode = din_responseCodeType_OK; // [V2G-DC-388]

    res->DC_EVSEStatus.EVSEIsolationStatus = (din_isolationLevelType)conn->ctx->evse_v2g_data.evse_isolation_status;
    res->DC_EVSEStatus.EVSEIsolationStatus_isUsed = conn->ctx->evse_v2g_data.evse_isolation_status_is_used;
    res->DC_EVSEStatus.EVSENotification = (din_EVSENotificationType)conn->ctx->evse_v2g_data.evse_notification;
    res->DC_EVSEStatus.EVSEStatusCode =
        (conn->ctx->intl_emergency_shutdown == true)
            ? din_DC_EVSEStatusCodeType_EVSE_EmergencyShutdown
            : (din_DC_EVSEStatusCodeType)conn->ctx->evse_v2g_data.evse_status_code[PHASE_PRECHARGE];
    res->DC_EVSEStatus.NotificationMaxDelay = conn->ctx->evse_v2g_data.notification_max_delay;

    load_din_physical_value(&res->EVSEPresentVoltage, &conn->ctx->evse_v2g_data.evse_present_voltage);

    /* Check the current response code and check if no external error has occurred */
    nextEvent = utils::din_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = WAIT_FOR_PRECHARGE_POWERDELIVERY; // [V2G-DC-458]

    return nextEvent;
}

/*!
 * \brief handle_din_service_discovery This function handles the din current demand msg pair. It analyzes the request
 * msg and fills the response msg. The request and response msg based on the open V2G structures. This structures must
 * be provided within the \c conn structure. [V2G-DC-464]
 * \param conn is the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_din_current_demand(struct v2g_connection* conn) {
    struct din_CurrentDemandReqType* req = &conn->exi_in.dinEXIDocument->V2G_Message.Body.CurrentDemandReq;
    struct din_CurrentDemandResType* res = &conn->exi_out.dinEXIDocument->V2G_Message.Body.CurrentDemandRes;
    enum v2g_event nextEvent = V2G_EVENT_NO_EVENT;

    /* At first, publish the received EV request message to the MQTT interface */
    publish_din_current_demand_req(conn->ctx, req);

    /* Now fill the evse response message */
    res->ResponseCode = din_responseCodeType_OK; // [V2G-DC-388]

    res->DC_EVSEStatus.EVSEIsolationStatus = (din_isolationLevelType)conn->ctx->evse_v2g_data.evse_isolation_status;
    res->DC_EVSEStatus.EVSEIsolationStatus_isUsed = conn->ctx->evse_v2g_data.evse_isolation_status_is_used;
    res->DC_EVSEStatus.EVSENotification = (din_EVSENotificationType)conn->ctx->evse_v2g_data.evse_notification;
    res->DC_EVSEStatus.EVSEStatusCode =
        (conn->ctx->intl_emergency_shutdown == true)
            ? din_DC_EVSEStatusCodeType_EVSE_EmergencyShutdown
            : (din_DC_EVSEStatusCodeType)conn->ctx->evse_v2g_data.evse_status_code[PHASE_CHARGE];
    res->DC_EVSEStatus.NotificationMaxDelay = (uint32_t)conn->ctx->evse_v2g_data.notification_max_delay;

    res->EVSECurrentLimitAchieved = conn->ctx->evse_v2g_data.evse_current_limit_achieved;

    res->EVSEMaximumCurrentLimit_isUsed = conn->ctx->evse_v2g_data.evse_maximum_current_limit_is_used;
    load_din_physical_value(&res->EVSEMaximumCurrentLimit, &conn->ctx->evse_v2g_data.evse_maximum_current_limit);

    res->EVSEMaximumPowerLimit_isUsed = conn->ctx->evse_v2g_data.evse_maximum_power_limit_is_used;
    load_din_physical_value(&res->EVSEMaximumPowerLimit, &conn->ctx->evse_v2g_data.evse_maximum_power_limit);

    res->EVSEMaximumVoltageLimit_isUsed = conn->ctx->evse_v2g_data.evse_maximum_voltage_limit_is_used;
    load_din_physical_value(&res->EVSEMaximumVoltageLimit, &conn->ctx->evse_v2g_data.evse_maximum_voltage_limit);

    res->EVSEPowerLimitAchieved = conn->ctx->evse_v2g_data.evse_power_limit_achieved;

    load_din_physical_value(&res->EVSEPresentCurrent, &conn->ctx->evse_v2g_data.evse_present_current);
    load_din_physical_value(&res->EVSEPresentVoltage, &conn->ctx->evse_v2g_data.evse_present_voltage);

    res->EVSEVoltageLimitAchieved = conn->ctx->evse_v2g_data.evse_voltage_limit_achieved;

    /* Check the current response code and check if no external error has occurred */
    nextEvent = utils::din_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = WAIT_FOR_CURRENTDEMAND_POWERDELIVERY; // [V2G-DC-465]

    return nextEvent;
}

/*!
 * \brief handle_din_service_discovery This function handles the din welding detection msg pair. It analyzes the request
 * msg and fills the response msg. The request and response msg based on the open V2G structures. This structures must
 * be provided within the \c conn structure. [V2G-DC-468]
 * \param conn is the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_din_welding_detection(struct v2g_connection* conn) {
    struct din_WeldingDetectionReqType* req = &conn->exi_in.dinEXIDocument->V2G_Message.Body.WeldingDetectionReq;
    struct din_WeldingDetectionResType* res = &conn->exi_out.dinEXIDocument->V2G_Message.Body.WeldingDetectionRes;
    enum v2g_event nextEvent = V2G_EVENT_NO_EVENT;

    /* At first, publish the received EV request message to the MQTT interface */
    publish_DIN_DcEvStatus(conn->ctx, req->DC_EVStatus);

    /* TODO: Waiting for CP-State B [V2G-DC-556]. */

    /* Now fill the evse response message */
    res->ResponseCode = din_responseCodeType_OK; // [V2G-DC-388]

    res->DC_EVSEStatus.EVSEIsolationStatus = (din_isolationLevelType)conn->ctx->evse_v2g_data.evse_isolation_status;
    res->DC_EVSEStatus.EVSEIsolationStatus_isUsed = conn->ctx->evse_v2g_data.evse_isolation_status_is_used;
    res->DC_EVSEStatus.EVSENotification = (din_EVSENotificationType)conn->ctx->evse_v2g_data.evse_notification;
    res->DC_EVSEStatus.EVSEStatusCode =
        (conn->ctx->intl_emergency_shutdown == true)
            ? din_DC_EVSEStatusCodeType_EVSE_EmergencyShutdown
            : (din_DC_EVSEStatusCodeType)conn->ctx->evse_v2g_data.evse_status_code[PHASE_WELDING];
    res->DC_EVSEStatus.NotificationMaxDelay = (uint32_t)conn->ctx->evse_v2g_data.notification_max_delay;

    load_din_physical_value(&res->EVSEPresentVoltage, &conn->ctx->evse_v2g_data.evse_present_voltage);

    /* Check the current response code and check if no external error has occurred */
    nextEvent = utils::din_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = WAIT_FOR_WELDINGDETECTION_SESSIONSTOP; // [V2G-DC-469]

    return nextEvent;
}

/*!
 * \brief handle_din_session_stop This function handles the din session stop msg pair. It analyzes the request msg and
 * fills the response msg. The request and response msg based on the open V2G structures. This structures must be
 * provided within the \c conn structure. [V2G-DC-450]
 * \param conn is the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_din_session_stop(struct v2g_connection* conn) {
    struct din_SessionStopResType* res = &conn->exi_out.dinEXIDocument->V2G_Message.Body.SessionStopRes;

    /* Now fill the EVSE response message */
    res->ResponseCode = din_responseCodeType_OK; // [V2G-DC-388]

    /* Check the current response code and check if no external error has occurred */
    utils::din_validate_response_code(&res->ResponseCode, conn);

    /* Setuo dlink action */
    conn->dlink_action = MQTT_DLINK_ACTION_TERMINATE;

    /* Set next expected req msg */
    conn->ctx->state = WAIT_FOR_TERMINATED_SESSION; // [V2G-DC-451]

    /* Check the current response code and check if no external error has occurred */
    return V2G_EVENT_SEND_AND_TERMINATE; // Charging must be terminated after sending the response message.
}

enum v2g_event din_handle_request(v2g_connection* conn) {
    using namespace states;

    struct din_exiDocument* exi_in = conn->exi_in.dinEXIDocument;
    struct din_exiDocument* exi_out = conn->exi_out.dinEXIDocument;
    enum v2g_event next_v2g_event = V2G_EVENT_TERMINATE_CONNECTION; // ERROR_UNEXPECTED_REQUEST_MESSAGE;

    /* extract session id */
    conn->ctx->ev_v2g_data.received_session_id = v2g_session_id_from_exi(false, exi_in);

    /* init V2G structure (document, header, body) */
    init_din_exiDocument(exi_out);
    init_din_MessageHeaderType(&exi_out->V2G_Message.Header);

    exi_out->V2G_Message.Header.SessionID.bytesLen = 8;
    init_din_BodyType(&exi_out->V2G_Message.Body);

    // === Start request handling ===
    if (exi_in->V2G_Message.Body.CurrentDemandReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling CurrentDemandReq");
        if (conn->ctx->last_v2g_msg == V2G_POWER_DELIVERY_MSG) {
            conn->ctx->p_charger->publish_current_demand_started(nullptr);
            conn->ctx->session.is_charging = true;
        }
        conn->ctx->current_v2g_msg = V2G_CURRENT_DEMAND_MSG;
        exi_out->V2G_Message.Body.CurrentDemandRes_isUsed = 1u;
        init_din_CurrentDemandResType(&exi_out->V2G_Message.Body.CurrentDemandRes);
        next_v2g_event = handle_din_current_demand(conn);
    } else if (exi_in->V2G_Message.Body.SessionSetupReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling SessionSetupReq");
        conn->ctx->current_v2g_msg = V2G_SESSION_SETUP_MSG;
        exi_out->V2G_Message.Body.SessionSetupRes_isUsed = 1u;
        init_din_SessionSetupResType(&exi_out->V2G_Message.Body.SessionSetupRes);
        /* Handle v2g msg */
        next_v2g_event = handle_din_session_setup(conn);
    } else if (exi_in->V2G_Message.Body.ServiceDiscoveryReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling ServiceDiscoveryReq");
        conn->ctx->current_v2g_msg = V2G_SERVICE_DISCOVERY_MSG;
        exi_out->V2G_Message.Body.ServiceDiscoveryRes_isUsed = 1u;
        init_din_ServiceDiscoveryResType(&exi_out->V2G_Message.Body.ServiceDiscoveryRes);
        next_v2g_event = handle_din_service_discovery(conn);
    } else if (exi_in->V2G_Message.Body.ServicePaymentSelectionReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling PaymentServiceSelectionReq");
        conn->ctx->current_v2g_msg = V2G_PAYMENT_SERVICE_SELECTION_MSG;
        exi_out->V2G_Message.Body.ServicePaymentSelectionRes_isUsed = 1u;
        init_din_ServicePaymentSelectionResType(&exi_out->V2G_Message.Body.ServicePaymentSelectionRes);
        next_v2g_event = handle_din_service_payment_selection(conn);
    } else if (exi_in->V2G_Message.Body.ContractAuthenticationReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling ContractAuthenticationReq");
        conn->ctx->current_v2g_msg = V2G_AUTHORIZATION_MSG;
        if (conn->ctx->last_v2g_msg != V2G_AUTHORIZATION_MSG) {
            dlog(DLOG_LEVEL_INFO, "Auth-phase started");
            conn->ctx->p_charger->publish_require_auth_eim(nullptr);
        }
        exi_out->V2G_Message.Body.ContractAuthenticationRes_isUsed = 1u;
        init_din_ContractAuthenticationResType(&exi_out->V2G_Message.Body.ContractAuthenticationRes);
        next_v2g_event = handle_din_contract_authentication(conn);
    } else if (exi_in->V2G_Message.Body.PaymentDetailsReq_isUsed) {
        dlog(DLOG_LEVEL_ERROR, "PaymentDetails request is not supported in DIN 70121");
        conn->ctx->current_v2g_msg = V2G_UNKNOWN_MSG;
        next_v2g_event = V2G_EVENT_IGNORE_MSG;
    } else if (exi_in->V2G_Message.Body.ServiceDetailReq_isUsed) {
        dlog(DLOG_LEVEL_ERROR, "ServiceDetail request is not supported in DIN 70121");
        conn->ctx->current_v2g_msg = V2G_UNKNOWN_MSG;
        next_v2g_event = V2G_EVENT_IGNORE_MSG;
    } else if (exi_in->V2G_Message.Body.ChargeParameterDiscoveryReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling ChargeParameterDiscoveryReq");
        conn->ctx->current_v2g_msg = V2G_CHARGE_PARAMETER_DISCOVERY_MSG;
        if (conn->ctx->last_v2g_msg == V2G_AUTHORIZATION_MSG) {
            dlog(DLOG_LEVEL_INFO, "Parameter-phase started");
        }
        exi_out->V2G_Message.Body.ChargeParameterDiscoveryRes_isUsed = 1u;
        init_din_ChargeParameterDiscoveryResType(&exi_out->V2G_Message.Body.ChargeParameterDiscoveryRes);
        next_v2g_event = handle_din_charge_parameter(conn);
    } else if (exi_in->V2G_Message.Body.CableCheckReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling CableCheckReq");
        conn->ctx->current_v2g_msg = V2G_CABLE_CHECK_MSG;
        if (conn->ctx->last_v2g_msg == V2G_CHARGE_PARAMETER_DISCOVERY_MSG) {
            conn->ctx->p_charger->publish_start_cable_check(nullptr);
            dlog(DLOG_LEVEL_INFO, "Isolation-phase started");
        }
        exi_out->V2G_Message.Body.CableCheckRes_isUsed = 1u;
        init_din_CableCheckResType(&exi_out->V2G_Message.Body.CableCheckRes);
        next_v2g_event = handle_din_cable_check(conn);
    } else if (exi_in->V2G_Message.Body.PreChargeReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling PreChargeReq");
        conn->ctx->current_v2g_msg = V2G_PRE_CHARGE_MSG;
        if (conn->ctx->last_v2g_msg == V2G_CABLE_CHECK_MSG) {
            conn->ctx->p_charger->publish_start_pre_charge(nullptr);
            dlog(DLOG_LEVEL_INFO, "Precharge-phase started");
        }
        exi_out->V2G_Message.Body.PreChargeRes_isUsed = 1u;
        init_din_PreChargeResType(&exi_out->V2G_Message.Body.PreChargeRes);
        next_v2g_event = handle_din_pre_charge(conn);
    } else if (exi_in->V2G_Message.Body.PowerDeliveryReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling PowerDeliveryReq");
        conn->ctx->current_v2g_msg = V2G_POWER_DELIVERY_MSG;
        if (conn->ctx->last_v2g_msg == V2G_PRE_CHARGE_MSG) {
            dlog(DLOG_LEVEL_INFO, "Charge-phase started");
        }
        exi_out->V2G_Message.Body.PowerDeliveryRes_isUsed = 1u;
        init_din_PowerDeliveryResType(&exi_out->V2G_Message.Body.PowerDeliveryRes);
        next_v2g_event = handle_din_power_delivery(conn);
    } else if (exi_in->V2G_Message.Body.ChargingStatusReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "ChargingStatus request is not supported in DIN 70121");
        conn->ctx->current_v2g_msg = V2G_UNKNOWN_MSG;
        exi_out->V2G_Message.Body.ChargingStatusRes_isUsed = 0u;
        init_din_ChargingStatusResType(&exi_out->V2G_Message.Body.ChargingStatusRes);
        next_v2g_event = V2G_EVENT_IGNORE_MSG;
    } else if (exi_in->V2G_Message.Body.MeteringReceiptReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "MeteringReceipt request is not supported in DIN 70121");
        conn->ctx->current_v2g_msg = V2G_UNKNOWN_MSG;
        exi_out->V2G_Message.Body.MeteringReceiptRes_isUsed = 0u;
        init_din_MeteringReceiptResType(&exi_out->V2G_Message.Body.MeteringReceiptRes);
        next_v2g_event = V2G_EVENT_IGNORE_MSG;
    } else if (exi_in->V2G_Message.Body.CertificateUpdateReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "CertificateUpdate request is not supported in DIN 70121");
        conn->ctx->current_v2g_msg = V2G_UNKNOWN_MSG;
        next_v2g_event = V2G_EVENT_IGNORE_MSG;
    } else if (exi_in->V2G_Message.Body.CertificateInstallationReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "CertificateInstallation request is not supported in DIN 70121");
        conn->ctx->current_v2g_msg = V2G_UNKNOWN_MSG;
        next_v2g_event = V2G_EVENT_IGNORE_MSG;
    } else if (exi_in->V2G_Message.Body.WeldingDetectionReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling WeldingDetectionReq");
        conn->ctx->current_v2g_msg = V2G_WELDING_DETECTION_MSG;
        if (conn->ctx->last_v2g_msg == V2G_POWER_DELIVERY_MSG) {
            dlog(DLOG_LEVEL_INFO, "Welding-phase started");
        }
        exi_out->V2G_Message.Body.WeldingDetectionRes_isUsed = 1u;
        init_din_WeldingDetectionResType(&exi_out->V2G_Message.Body.WeldingDetectionRes);
        next_v2g_event = handle_din_welding_detection(conn);
    } else if (exi_in->V2G_Message.Body.SessionStopReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling SessionStopReq");
        conn->ctx->current_v2g_msg = V2G_SESSION_STOP_MSG;

        exi_out->V2G_Message.Body.SessionStopRes_isUsed = 1u;
        init_din_SessionStopResType(&exi_out->V2G_Message.Body.SessionStopRes);
        next_v2g_event = handle_din_session_stop(conn);
    } else {
        dlog(DLOG_LEVEL_ERROR, "Create_response_message: request type not found");
        next_v2g_event = V2G_EVENT_IGNORE_MSG;
    }

    if (next_v2g_event != V2G_EVENT_IGNORE_MSG) {
        /* Configure session id */
        memcpy(exi_out->V2G_Message.Header.SessionID.bytes, &conn->ctx->evse_v2g_data.session_id, sizeof(uint64_t));

        // TODO: Set byteLen
        exi_out->V2G_Message.Header.SessionID.bytesLen = din_sessionIDType_BYTES_SIZE;

        dlog(DLOG_LEVEL_TRACE, "Current state: %s", din_states[conn->ctx->state].description);
        conn->ctx->last_v2g_msg = conn->ctx->current_v2g_msg;
    }

    return next_v2g_event;
}


// ===== din_server.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2023 chargebyte GmbH
// Copyright (C) 2023 Contributors to EVerest

#ifndef DIN_SERVER_HPP
#define DIN_SERVER_HPP

#include "v2g.hpp"

/*!
 * \brief The din_state_id enum
 */
enum din_state_id {
    WAIT_FOR_SESSIONSETUP = 0,
    WAIT_FOR_SERVICEDISCOVERY,
    WAIT_FOR_PAYMENTSERVICESELECTION,
    WAIT_FOR_AUTHORIZATION,
    WAIT_FOR_CHARGEPARAMETERDISCOVERY,
    WAIT_FOR_CABLECHECK,
    WAIT_FOR_PRECHARGE,
    WAIT_FOR_PRECHARGE_POWERDELIVERY,
    WAIT_FOR_CURRENTDEMAND,
    WAIT_FOR_CURRENTDEMAND_POWERDELIVERY,
    WAIT_FOR_WELDINGDETECTION_SESSIONSTOP,
    WAIT_FOR_SESSIONSTOP,
    WAIT_FOR_TERMINATED_SESSION
};

static const char* dinResponse[] = {"Response OK",
                                    "New Session Established",
                                    "Old Session Joined",
                                    "Certificate Expires Soon",
                                    "Response Failed",
                                    "Sequence Error",
                                    "Service ID Invalid",
                                    "Unknown Session",
                                    "Service Selection Invalid",
                                    "Payment Selection Invalid",
                                    "Certificate Expired",
                                    "Signature Error",
                                    "No Certificate Available",
                                    "Cert Chain Error",
                                    "Challenge Invalid",
                                    "Contract Canceled",
                                    "Wrong Charge Parameter",
                                    "Power Delivery Not Applied",
                                    "Tariff Selection Invalid",
                                    "Charging Profile Invalid",
                                    "EVSE Present Voltage To Low",
                                    "Metering Signature Not Valid",
                                    "Wrong Energy Transfer Type"};

/*!
 * \brief The din_state struct
 */
struct din_state {
    const char* description;
    int allowed_requests;
};

static const struct din_state din_states[] = {
    /* [V2G-DC-437]  Expected req msg after supportedAppProtocolRes */
    [WAIT_FOR_SESSIONSETUP] = {"Waiting for SessionSetupReq", 1 << V2G_SESSION_SETUP_MSG},
    /* [V2G-DC-439] Expected req msg after SessionSetupRes */
    [WAIT_FOR_SERVICEDISCOVERY] = {"Waiting for ServiceDiscoveryReq, SessionStopReq",
                                   1 << V2G_SERVICE_DISCOVERY_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-DC-441] Expected req msg after ServiceDiscoveryRes */
    [WAIT_FOR_PAYMENTSERVICESELECTION] = {"Waiting for ServicePaymentSelectionReq, SessionStopReq",
                                          1 << V2G_PAYMENT_SERVICE_SELECTION_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-DC-444] [V2G-DC-497] Expected req msg after ServicePaymentSelectionRes */
    [WAIT_FOR_AUTHORIZATION] = {"Waiting for ContractAuthenticationReq, SessionStopReq",
                                1 << V2G_AUTHORIZATION_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-DC-498], [V2G-DC-495] Expected req msg after ContractAuthenticationRes*/
    [WAIT_FOR_CHARGEPARAMETERDISCOVERY] = {"Waiting for ChargeParameterDiscoveryReq, SessionStopReq",
                                           1 << V2G_CHARGE_PARAMETER_DISCOVERY_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-DC-453], [V2G-DC-499] Expected req msg after ChargeParameterDiscoveryRes, CableCheckRes */
    [WAIT_FOR_CABLECHECK] = {"Waiting for CableCheckReq, SessionStopReq",
                             1 << V2G_CABLE_CHECK_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-DC-455] Expected req msgs after CableCheckRes */
    [WAIT_FOR_PRECHARGE] = {"Waiting for PreChargeReq, SessionStopReq",
                            1 << V2G_PRE_CHARGE_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-DC-458] Expected req msg after PreChargeRes */
    [WAIT_FOR_PRECHARGE_POWERDELIVERY] = {"Waiting for PowerDeliveryReq, PreChargeReq, SessionStopRes",
                                          1 << V2G_POWER_DELIVERY_MSG | 1 << V2G_PRE_CHARGE_MSG |
                                              1 << V2G_SESSION_STOP_MSG},
    /* [V2G-DC-462] Expected req msg after PowerDeliveryRes (Ready to Charge = true) */
    [WAIT_FOR_CURRENTDEMAND] = {"Waiting for CurrentDemandReq", 1 << V2G_CURRENT_DEMAND_MSG},
    /* [V2G-DC-462], [V2G-DC-465] Expected req msg after PowerDeliveryRes (Ready to Charge = true), CurrentDemandRes */
    [WAIT_FOR_CURRENTDEMAND_POWERDELIVERY] = {"Waiting for CurrentDemandReq, PowerDeliveryReq",
                                              1 << V2G_CURRENT_DEMAND_MSG | 1 << V2G_POWER_DELIVERY_MSG},
    /* [V2G-DC-459], [V2G-DC-469] Expected req msg after PowerDeliveryRes, WeldingDetectionRes */
    [WAIT_FOR_WELDINGDETECTION_SESSIONSTOP] = {"Waiting for WeldingDetectionReq, SessionStopReq ",
                                               1 << V2G_WELDING_DETECTION_MSG | 1 << V2G_SESSION_STOP_MSG},
    [WAIT_FOR_SESSIONSTOP] = {"Waiting for SessionStopReq", 1 << V2G_SESSION_STOP_MSG},
    [WAIT_FOR_TERMINATED_SESSION] = {"Terminate session", 0}};

/*!
 * \brief din_handle_request This function handles the incoming request message of a connected EV.
 *  It analyzes the incoming DIN request EXI stream and configures the response EXI stream
 * \param conn This structure provides the EXI streams
 * \return This function returns \c 1 if the connection must be closed immediately,
 *  when this function returns \c 0 the req handle is successful,
 *  when this function returns \c 2 the reply needs to be sent and the connection needs to be closed afterwards
 */
enum v2g_event din_handle_request(v2g_connection* conn);

namespace utils {
enum v2g_event din_validate_response_code(din_responseCodeType* const din_response_code,
                                          struct v2g_connection const* conn);
} // namespace utils

namespace states {

enum v2g_event handle_din_session_setup(struct v2g_connection* conn);
enum v2g_event handle_din_service_discovery(struct v2g_connection* conn);
enum v2g_event handle_din_contract_authentication(struct v2g_connection* conn);

} // namespace states

#endif /* DIN_SERVER_HPP */


// ===== EvseV2G.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2022-2023 chargebyte GmbH
// Copyright (C) 2022-2023 Contributors to EVerest
#include "EvseV2G.hpp"
#include "connection/connection.hpp"
#include "connection/tls_connection.hpp"
#include "log.hpp"
#include "sdp.hpp"
#include <everest/logging.hpp>

#include <csignal>
#include <openssl_util.hpp>
namespace {
void log_handler(openssl::log_level_t level, const std::string& str) {
    switch (level) {
    case openssl::log_level_t::debug:
        // ignore debug logs
        break;
    case openssl::log_level_t::info:
        EVLOG_info << str;
        break;
    case openssl::log_level_t::warning:
        EVLOG_warning << str;
        break;
    case openssl::log_level_t::error:
    default:
        EVLOG_error << str;
        break;
    }
}
} // namespace

struct v2g_context* v2g_ctx = nullptr;

namespace module {

void EvseV2G::init() {
    /* create v2g context */
    v2g_ctx = v2g_ctx_create(&(*p_charger), &(*p_extensions), &(*r_security));

    if (v2g_ctx == nullptr)
        return;

    (void)openssl::set_log_handler(log_handler);
    tls::Server::configure_signal_handler(SIGUSR1);
    v2g_ctx->tls_server = &tls_server;

    this->r_security->subscribe_certificate_store_update(
        [this](const types::evse_security::CertificateStoreUpdate& update) {
            if (!update.leaf_certificate_type.has_value()) {
                return;
            }

            if (update.leaf_certificate_type.value() != types::evse_security::LeafCertificateType::V2G) {
                return;
            }

            dlog(DLOG_LEVEL_INFO, "Certificate store update received, reconfiguring TLS server");
            auto config = std::make_unique<tls::Server::config_t>();
            if (build_config(*config, v2g_ctx)) {
                dlog(DLOG_LEVEL_INFO, "Configuration of TLS server successful, updating it");
                v2g_ctx->tls_server->update(*config);
            } else {
                dlog(DLOG_LEVEL_INFO, "Configuration of TLS server failed, suspending it");
                v2g_ctx->tls_server->suspend();
            }
        });

    invoke_init(*p_charger);
    invoke_init(*p_extensions);
}

void EvseV2G::ready() {
    int rv = 0;

    dlog(DLOG_LEVEL_DEBUG, "Starting SDP responder");

    rv = connection_init(v2g_ctx);

    if (rv == -1) {
        dlog(DLOG_LEVEL_ERROR, "Failed to initialize connection");
        goto err_out;
    }

    if (config.enable_sdp_server) {
        rv = sdp_init(v2g_ctx);

        if (rv == -1) {
            dlog(DLOG_LEVEL_ERROR, "Failed to start SDP responder");
            goto err_out;
        }
    }

    dlog(DLOG_LEVEL_DEBUG, "starting socket server(s)");
    if (connection_start_servers(v2g_ctx)) {
        dlog(DLOG_LEVEL_ERROR, "start_connection_servers() failed");
        goto err_out;
    }

    invoke_ready(*p_charger);
    invoke_ready(*p_extensions);

    rv = sdp_listen(v2g_ctx);

    if (rv == -1) {
        dlog(DLOG_LEVEL_ERROR, "sdp_listen() failed");
        goto err_out;
    }

    return;

err_out:
    v2g_ctx_free(v2g_ctx);
}

EvseV2G::~EvseV2G() {
    v2g_ctx_free(v2g_ctx);
}

} // namespace module


// ===== EvseV2G.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright Pionix GmbH and Contributors to EVerest
#ifndef EVSE_V2G_HPP
#define EVSE_V2G_HPP

//
// AUTO GENERATED - MARKED REGIONS WILL BE KEPT
// template version 2
//

#include "ld-ev.hpp"

// headers for provided interface implementations
#include <generated/interfaces/ISO15118_charger/Implementation.hpp>
#include <generated/interfaces/iso15118_extensions/Implementation.hpp>

// headers for required interface implementations
#include <generated/interfaces/evse_security/Interface.hpp>

// ev@4bf81b14-a215-475c-a1d3-0a484ae48918:v1
// insert your custom include headers here
#include "v2g_ctx.hpp"
#include <tls.hpp>
// ev@4bf81b14-a215-475c-a1d3-0a484ae48918:v1

namespace module {

struct Conf {
    std::string device;
    bool supported_DIN70121;
    bool supported_ISO15118_2;
    std::string tls_security;
    bool terminate_connection_on_failed_response;
    bool tls_key_logging;
    std::string tls_key_logging_path;
    int tls_timeout;
    bool verify_contract_cert_chain;
    int auth_timeout_pnc;
    int auth_timeout_eim;
    bool enable_sdp_server;
};

class EvseV2G : public Everest::ModuleBase {
public:
    EvseV2G() = delete;
    EvseV2G(const ModuleInfo& info, Everest::MqttProvider& mqtt_provider,
            std::unique_ptr<ISO15118_chargerImplBase> p_charger,
            std::unique_ptr<iso15118_extensionsImplBase> p_extensions, std::unique_ptr<evse_securityIntf> r_security,
            Conf& config) :
        ModuleBase(info),
        mqtt(mqtt_provider),
        p_charger(std::move(p_charger)),
        p_extensions(std::move(p_extensions)),
        r_security(std::move(r_security)),
        config(config){};

    Everest::MqttProvider& mqtt;
    const std::unique_ptr<ISO15118_chargerImplBase> p_charger;
    const std::unique_ptr<iso15118_extensionsImplBase> p_extensions;
    const std::unique_ptr<evse_securityIntf> r_security;
    const Conf& config;

    // ev@1fce4c5e-0ab8-41bb-90f7-14277703d2ac:v1
    ~EvseV2G();
    // ev@1fce4c5e-0ab8-41bb-90f7-14277703d2ac:v1

protected:
    // ev@4714b2ab-a24f-4b95-ab81-36439e1478de:v1
    // insert your protected definitions here
    // ev@4714b2ab-a24f-4b95-ab81-36439e1478de:v1

private:
    friend class LdEverest;
    void init();
    void ready();

    // ev@211cfdbe-f69a-4cd6-a4ec-f8aaa3d1b6c8:v1
    // insert your private definitions here
    tls::Server tls_server;
    // ev@211cfdbe-f69a-4cd6-a4ec-f8aaa3d1b6c8:v1
};

// ev@087e516b-124c-48df-94fb-109508c7cda9:v1
// insert other definitions here
// ev@087e516b-124c-48df-94fb-109508c7cda9:v1

} // namespace module

#endif // EVSE_V2G_HPP


// ===== extensions\iso15118_extensionsImpl.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright Pionix GmbH and Contributors to EVerest
#include "iso15118_extensionsImpl.hpp"
#include "log.hpp"
#include "v2g_ctx.hpp"

namespace module {
namespace extensions {

void iso15118_extensionsImpl::init() {
    if (!v2g_ctx) {
        dlog(DLOG_LEVEL_ERROR, "v2g_ctx not created");
        return;
    }
}

void iso15118_extensionsImpl::ready() {
}

void iso15118_extensionsImpl::handle_set_get_certificate_response(
    types::iso15118::ResponseExiStreamStatus& certificate_response) {
    pthread_mutex_lock(&v2g_ctx->mqtt_lock);
    if (certificate_response.exi_response.has_value() and not certificate_response.exi_response.value().empty()) {
        v2g_ctx->evse_v2g_data.cert_install_res_b64_buffer = std::string(certificate_response.exi_response.value());
    }
    v2g_ctx->evse_v2g_data.cert_install_status =
        (certificate_response.status == types::iso15118::Status::Accepted) ? true : false;
    pthread_cond_signal(&v2g_ctx->mqtt_cond);
    /* unlock */
    pthread_mutex_unlock(&v2g_ctx->mqtt_lock);
}

} // namespace extensions
} // namespace module


// ===== extensions\iso15118_extensionsImpl.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright Pionix GmbH and Contributors to EVerest
#ifndef EXTENSIONS_ISO15118_EXTENSIONS_IMPL_HPP
#define EXTENSIONS_ISO15118_EXTENSIONS_IMPL_HPP

//
// AUTO GENERATED - MARKED REGIONS WILL BE KEPT
// template version 3
//

#include <generated/interfaces/iso15118_extensions/Implementation.hpp>

#include "../EvseV2G.hpp"

// ev@75ac1216-19eb-4182-a85c-820f1fc2c091:v1
#include "v2g.hpp"
extern struct v2g_context* v2g_ctx;
// ev@75ac1216-19eb-4182-a85c-820f1fc2c091:v1

namespace module {
namespace extensions {

struct Conf {};

class iso15118_extensionsImpl : public iso15118_extensionsImplBase {
public:
    iso15118_extensionsImpl() = delete;
    iso15118_extensionsImpl(Everest::ModuleAdapter* ev, const Everest::PtrContainer<EvseV2G>& mod, Conf& config) :
        iso15118_extensionsImplBase(ev, "extensions"), mod(mod), config(config){};

    // ev@8ea32d28-373f-4c90-ae5e-b4fcc74e2a61:v1
    // insert your public definitions here
    // ev@8ea32d28-373f-4c90-ae5e-b4fcc74e2a61:v1

protected:
    // command handler functions (virtual)
    virtual void
    handle_set_get_certificate_response(types::iso15118::ResponseExiStreamStatus& certificate_response) override;

    // ev@d2d1847a-7b88-41dd-ad07-92785f06f5c4:v1
    // insert your protected definitions here
    // ev@d2d1847a-7b88-41dd-ad07-92785f06f5c4:v1

private:
    const Everest::PtrContainer<EvseV2G>& mod;
    const Conf& config;

    virtual void init() override;
    virtual void ready() override;

    // ev@3370e4dd-95f4-47a9-aaec-ea76f34a66c9:v1
    // insert your private definitions here
    // ev@3370e4dd-95f4-47a9-aaec-ea76f34a66c9:v1
};

// ev@3d7da0ad-02c2-493d-9920-0bbbd56b9876:v1
// insert other definitions here
// ev@3d7da0ad-02c2-493d-9920-0bbbd56b9876:v1

} // namespace extensions
} // namespace module

#endif // EXTENSIONS_ISO15118_EXTENSIONS_IMPL_HPP


// ===== iso_server.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2023 chargebyte GmbH
// Copyright (C) 2023 Contributors to EVerest
#include "openssl_util.hpp"
#include <cbv2g/common/exi_bitstream.h>
#include <cbv2g/exi_v2gtp.h> //for V2GTP_HEADER_LENGTHs
#include <cbv2g/iso_2/iso2_msgDefDatatypes.h>
#include <cbv2g/iso_2/iso2_msgDefDecoder.h>
#include <cbv2g/iso_2/iso2_msgDefEncoder.h>

#include <cstdint>
#include <inttypes.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "crypto/crypto_openssl.hpp"
using namespace openssl;
using namespace crypto::openssl;

#include "iso_server.hpp"
#include "log.hpp"
#include "tools.hpp"
#include "v2g_ctx.hpp"
#include "v2g_server.hpp"

#define MQTT_MAX_PAYLOAD_SIZE         268435455
#define V2G_SECC_MSG_CERTINSTALL_TIME 4500
#define GEN_CHALLENGE_SIZE            16

constexpr uint16_t SAE_V2H = 28472;
constexpr uint16_t SAE_V2G = 28473;

/*!
 * \brief iso_validate_state This function checks whether the received message is expected and valid at this
 * point in the communication sequence state machine. The current V2G msg type must be set with the current V2G msg
 * state. [V2G2-538]
 * \param state is the current state of the charging session.
 * \param current_v2g_msg is the current handled V2G message.
 * \param is_dc_charging is \c true if it is a DC charging session.
 * \return Returns a iso2_responseCode with sequence error if current_v2g_msg is not expected, otherwise OK.
 */
static iso2_responseCodeType iso_validate_state(int state, enum V2gMsgTypeId current_v2g_msg, bool is_dc_charging) {

    int allowed_requests =
        (true == is_dc_charging)
            ? iso_dc_states[state].allowed_requests
            : iso_ac_states[state].allowed_requests; // dc_charging is determined in charge_parameter. dc
    return (allowed_requests & (1 << current_v2g_msg)) ? iso2_responseCodeType_OK
                                                       : iso2_responseCodeType_FAILED_SequenceError;
}

/*!
 * \brief iso_validate_response_code This function checks if an external error has occurred (sequence error, user abort)
 * ... ). \param iso_response_code is a pointer to the current response code. The value will be modified if an external
 *  error has occurred.
 * \param conn the structure with the external error information.
 * \return Returns \c V2G_EVENT_SEND_AND_TERMINATE if the charging must be terminated after sending the response
 * message, returns \c V2G_EVENT_TERMINATE_CONNECTION if charging must be aborted immediately and \c V2G_EVENT_NO_EVENT
 * if no error
 */
static v2g_event iso_validate_response_code(iso2_responseCodeType* const v2g_response_code,
                                            struct v2g_connection const* const conn) {
    enum v2g_event next_event = V2G_EVENT_NO_EVENT;
    iso2_responseCodeType response_code_tmp;

    if (conn->ctx->is_connection_terminated == true) {
        dlog(DLOG_LEVEL_ERROR, "Connection is terminated. Abort charging");
        return V2G_EVENT_TERMINATE_CONNECTION;
    }

    /* If MQTT user abort or emergency shutdown has occurred */
    if ((conn->ctx->stop_hlc == true) || (conn->ctx->intl_emergency_shutdown == true)) {
        *v2g_response_code = iso2_responseCodeType_FAILED;
    }

    /* [V2G-DC-390]: at this point we must check whether the given request is valid at this step;
     * the idea is that we catch this error in each function below to respond with a valid
     * encoded message; note, that the handler functions below must not access v2g_session in
     * error path, since it might not be set, yet!
     */
    response_code_tmp =
        iso_validate_state(conn->ctx->state, conn->ctx->current_v2g_msg, conn->ctx->is_dc_charger); // [V2G2-538]

    *v2g_response_code = (response_code_tmp >= iso2_responseCodeType_FAILED) ? response_code_tmp : *v2g_response_code;

    /* [V2G2-460]: check whether the session id matches the expected one of the active session */
    *v2g_response_code = ((conn->ctx->current_v2g_msg != V2G_SESSION_SETUP_MSG) &&
                          (conn->ctx->evse_v2g_data.session_id != conn->ctx->ev_v2g_data.received_session_id))
                             ? iso2_responseCodeType_FAILED_UnknownSession
                             : *v2g_response_code;

    if ((conn->ctx->terminate_connection_on_failed_response == true) &&
        (*v2g_response_code >= iso2_responseCodeType_FAILED)) {
        next_event = V2G_EVENT_SEND_AND_TERMINATE; // [V2G2-539], [V2G2-034] Send response and terminate tcp-connection
    }

    /* log failed response code message */
    if ((*v2g_response_code >= iso2_responseCodeType_FAILED) &&
        (*v2g_response_code <= iso2_responseCodeType_FAILED_CertificateRevoked)) {
        dlog(DLOG_LEVEL_ERROR, "Failed response code detected for message \"%s\", error: %s",
             v2g_msg_type[conn->ctx->current_v2g_msg], isoResponse[*v2g_response_code]);
    }

    return next_event;
}

/*!
 * \brief populate_ac_evse_status This function configures the evse_status struct
 * \param ctx is the V2G context
 * \param evse_status is the destination struct
 */
static void populate_ac_evse_status(struct v2g_context* ctx, struct iso2_AC_EVSEStatusType* evse_status) {
    evse_status->EVSENotification = (iso2_EVSENotificationType)ctx->evse_v2g_data.evse_notification;
    evse_status->NotificationMaxDelay = ctx->evse_v2g_data.notification_max_delay;
    evse_status->RCD = ctx->evse_v2g_data.rcd;
}

/*!
 * \brief check_iso2_charging_profile_values This function checks if EV charging profile values are within permissible
 * ranges \param req is the PowerDeliveryReq \param res is the PowerDeliveryRes \param conn holds the structure with the
 * V2G msg pair \param sa_schedule_tuple_idx is the index of SA schedule tuple
 */
static void check_iso2_charging_profile_values(iso2_PowerDeliveryReqType* req, iso2_PowerDeliveryResType* res,
                                               v2g_connection* conn, uint8_t sa_schedule_tuple_idx) {
    if (req->ChargingProfile_isUsed == (unsigned int)1) {

        const struct iso2_PMaxScheduleType* evse_p_max_schedule =
            &conn->ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[sa_schedule_tuple_idx].PMaxSchedule;

        uint32_t ev_time_sum = 0;                     // Summed EV relative time interval
        uint32_t evse_time_sum = 0;                   // Summed EVSE relative time interval
        uint8_t evse_idx = 0;                         // Actual PMaxScheduleEntry index
        bool ev_time_is_within_profile_entry = false; /* Is true if the summed EV relative time interval
                                                         is within the actual EVSE time interval */

        /* Check if the EV ChargingProfileEntryStart time and PMax value fits with the provided EVSE PMaxScheduleEntry
         * list. [V2G2-293] */
        for (uint8_t ev_idx = 0;
             ev_idx < req->ChargingProfile.ProfileEntry.arrayLen && (res->ResponseCode == iso2_responseCodeType_OK);
             ev_idx++) {

            ev_time_sum += req->ChargingProfile.ProfileEntry.array[ev_idx].ChargingProfileEntryStart;

            while (evse_idx < evse_p_max_schedule->PMaxScheduleEntry.arrayLen &&
                   (ev_time_is_within_profile_entry == false)) {

                /* Check if EV ChargingProfileEntryStart value is within one EVSE schedule entry.
                 * The last element must be checked separately, because of the duration value */

                /* If we found an entry which fits in the EVSE time schedule, check if the next EV time slot fits as
                 * well Otherwise check if the next time interval fits in the EVSE time schedule */
                evse_time_sum += evse_p_max_schedule->PMaxScheduleEntry.array[evse_idx].RelativeTimeInterval.start;

                /* Check the time intervals, in the last schedule element the duration value must be considered */
                if (evse_idx < (evse_p_max_schedule->PMaxScheduleEntry.arrayLen - 1)) {
                    ev_time_is_within_profile_entry =
                        (ev_time_sum >= evse_time_sum) &&
                        (ev_time_sum <
                         (evse_time_sum +
                          evse_p_max_schedule->PMaxScheduleEntry.array[evse_idx + 1].RelativeTimeInterval.start));
                } else {
                    ev_time_is_within_profile_entry =
                        (ev_time_sum >= evse_time_sum) &&
                        (ev_time_sum <=
                         (evse_time_sum +
                          evse_p_max_schedule->PMaxScheduleEntry.array[evse_idx].RelativeTimeInterval.duration_isUsed *
                              evse_p_max_schedule->PMaxScheduleEntry.array[evse_idx].RelativeTimeInterval.duration));
                }

                if (ev_time_is_within_profile_entry == true) {
                    /* Check if ev ChargingProfileEntryMaxPower element is equal to or smaller than the limits in
                     * respective elements of the PMaxScheduleType */
                    if ((req->ChargingProfile.ProfileEntry.array[ev_idx].ChargingProfileEntryMaxPower.Value *
                         pow(10,
                             req->ChargingProfile.ProfileEntry.array[ev_idx].ChargingProfileEntryMaxPower.Multiplier)) >
                        (evse_p_max_schedule->PMaxScheduleEntry.array[evse_idx].PMax.Value *
                         pow(10, evse_p_max_schedule->PMaxScheduleEntry.array[evse_idx].PMax.Multiplier))) {
                        res->ResponseCode = iso2_responseCodeType_FAILED_ChargingProfileInvalid; // [V2G2-224]
                        // [V2G2-225] [V2G2-478]
                        //  setting response code is commented because some EVs do not support schedules correctly
                        dlog(DLOG_LEVEL_WARNING,
                             "EV's charging profile is invalid (ChargingProfileEntryMaxPower too high)!");
                        break;
                    }
                }
                /* If the last EVSE element is reached and ChargingProfileEntryStart time doesn't fit */
                else if (evse_idx == (evse_p_max_schedule->PMaxScheduleEntry.arrayLen - 1)) {
                    // res->ResponseCode = iso2_responseCodeType_FAILED_ChargingProfileInvalid; // EV charing profile
                    // time exceeds EVSE provided schedule
                    //  setting response code is commented because some EVs do not support schedules correctly
                    dlog(DLOG_LEVEL_WARNING,
                         "EV's charging profile is invalid (EV charging profile time exceeds provided schedule)!");
                } else {
                    /* Now we checked if the current EV interval fits within the EVSE interval, but it fails.
                     * Next step is to check the EVSE interval until we reached the last EVSE interval */
                    evse_idx++;
                }
            }
        }
    }
}

static void publish_DcEvStatus(struct v2g_context* ctx, const struct iso2_DC_EVStatusType& iso2_ev_status) {
    if ((ctx->ev_v2g_data.iso2_dc_ev_status.EVErrorCode != iso2_ev_status.EVErrorCode) ||
        (ctx->ev_v2g_data.iso2_dc_ev_status.EVReady != iso2_ev_status.EVReady) ||
        (ctx->ev_v2g_data.iso2_dc_ev_status.EVRESSSOC != iso2_ev_status.EVRESSSOC)) {
        ctx->ev_v2g_data.iso2_dc_ev_status.EVErrorCode = iso2_ev_status.EVErrorCode;
        ctx->ev_v2g_data.iso2_dc_ev_status.EVReady = iso2_ev_status.EVReady;
        ctx->ev_v2g_data.iso2_dc_ev_status.EVRESSSOC = iso2_ev_status.EVRESSSOC;

        types::iso15118::DcEvStatus ev_status;
        ev_status.dc_ev_error_code = static_cast<types::iso15118::DcEvErrorCode>(iso2_ev_status.EVErrorCode);
        ev_status.dc_ev_ready = iso2_ev_status.EVReady;
        ev_status.dc_ev_ress_soc = static_cast<float>(iso2_ev_status.EVRESSSOC);
        ctx->p_charger->publish_dc_ev_status(ev_status);
    }
}

static auto get_emergency_status_code(const struct v2g_context* ctx, uint8_t phase_type) {
    if (ctx->intl_emergency_shutdown)
        return iso2_DC_EVSEStatusCodeType_EVSE_EmergencyShutdown;
    else
        return static_cast<iso2_DC_EVSEStatusCodeType>(ctx->evse_v2g_data.evse_status_code[phase_type]);
}

//=============================================
//             Publishing request msg
//=============================================

/*!
 * \brief publish_iso_service_discovery_req This function publishes the iso_service_discovery_req message to the MQTT
 * interface. \param iso2_ServiceDiscoveryReqType is the request message.
 */
static void
publish_iso_service_discovery_req(struct iso2_ServiceDiscoveryReqType const* const v2g_service_discovery_req) {
    // V2G values that can be published: ServiceCategory, ServiceScope
}

/*!
 * \brief publish_iso_service_detail_req This function publishes the iso_service_detail_req message to the MQTT
 * interface. \param v2g_service_detail_req is the request message.
 */
static void publish_iso_service_detail_req(struct iso2_ServiceDetailReqType const* const v2g_service_detail_req) {
    // V2G values that can be published: ServiceID
}

/*!
 * \brief publish_iso_payment_service_selection_req This function publishes the iso_payment_service_selection_req
 * message to the MQTT interface.
 * \param v2g_payment_service_selection_req is the request message.
 */
static void publish_iso_payment_service_selection_req(
    struct iso2_PaymentServiceSelectionReqType const* const v2g_payment_service_selection_req) {
    // V2G values that can be published: selected_payment_option, SelectedServiceList
}

/*!
 * \brief publish_iso_authorization_req This function publishes the publish_iso_authorization_req message to the MQTT
 * interface. \param v2g_authorization_req is the request message.
 */
static void publish_iso_authorization_req(struct iso2_AuthorizationReqType const* const v2g_authorization_req) {
    // V2G values that can be published: Id, Id_isUsed, GenChallenge, GenChallenge_isUsed
}

/*!
 * \brief publish_iso_charge_parameter_discovery_req This function publishes the charge_parameter_discovery_req message
 * to the MQTT interface. \param ctx is the V2G context. \param v2g_charge_parameter_discovery_req is the request
 * message.
 */
static void publish_iso_charge_parameter_discovery_req(
    struct v2g_context* ctx,
    struct iso2_ChargeParameterDiscoveryReqType const* const v2g_charge_parameter_discovery_req) {
    // Charging needs for OCPP
    types::iso15118::ChargingNeeds charging_needs;

    // V2G values that can be published: DC_EVChargeParameter, MaxEntriesSAScheduleTuple
    const auto transfer_mode = static_cast<types::iso15118::EnergyTransferMode>(
        v2g_charge_parameter_discovery_req->RequestedEnergyTransferMode);

    charging_needs.requested_energy_transfer = transfer_mode;

    ctx->p_charger->publish_requested_energy_transfer_mode(transfer_mode);
    if (v2g_charge_parameter_discovery_req->AC_EVChargeParameter_isUsed == (unsigned int)1) {
        if (v2g_charge_parameter_discovery_req->AC_EVChargeParameter.DepartureTime_isUsed == (unsigned int)1) {
            const char* format = "%Y-%m-%dT%H:%M:%SZ";
            char buffer[100];
            std::time_t time_now_in_sec = time(NULL);
            std::time_t departure_time =
                time_now_in_sec + v2g_charge_parameter_discovery_req->AC_EVChargeParameter.DepartureTime;
            std::strftime(buffer, sizeof(buffer), format, std::gmtime(&departure_time));
            ctx->p_charger->publish_departure_time(buffer);
        }

        // TODO(ioan): calc physical once
        float ac_eamount =
            calc_physical_value(v2g_charge_parameter_discovery_req->AC_EVChargeParameter.EAmount.Value,
                                v2g_charge_parameter_discovery_req->AC_EVChargeParameter.EAmount.Multiplier);
        float ac_ev_max_voltage =
            calc_physical_value(v2g_charge_parameter_discovery_req->AC_EVChargeParameter.EVMaxVoltage.Value,
                                v2g_charge_parameter_discovery_req->AC_EVChargeParameter.EVMaxVoltage.Multiplier);
        float ac_ev_max_current =
            calc_physical_value(v2g_charge_parameter_discovery_req->AC_EVChargeParameter.EVMaxCurrent.Value,
                                v2g_charge_parameter_discovery_req->AC_EVChargeParameter.EVMaxCurrent.Multiplier);
        float ac_ev_min_current =
            calc_physical_value(v2g_charge_parameter_discovery_req->AC_EVChargeParameter.EVMinCurrent.Value,
                                v2g_charge_parameter_discovery_req->AC_EVChargeParameter.EVMinCurrent.Multiplier);

        ctx->p_charger->publish_ac_eamount(ac_eamount);
        ctx->p_charger->publish_ac_ev_max_voltage(ac_ev_max_voltage);
        ctx->p_charger->publish_ac_ev_max_current(ac_ev_max_current);
        ctx->p_charger->publish_ac_ev_min_current(ac_ev_min_current);

        auto& ac_charging_parameters = charging_needs.ac_charging_parameters.emplace();

        // We do not require to calc a min/max here
        ac_charging_parameters.energy_amount = ac_eamount;
        ac_charging_parameters.ev_max_voltage = ac_ev_max_voltage;
        ac_charging_parameters.ev_max_current = ac_ev_max_current;
        ac_charging_parameters.ev_min_current = ac_ev_min_current;

    } else if (v2g_charge_parameter_discovery_req->DC_EVChargeParameter_isUsed == (unsigned int)1) {
        if (v2g_charge_parameter_discovery_req->DC_EVChargeParameter.DepartureTime_isUsed == (unsigned int)1) {
            const char* format = "%Y-%m-%dT%H:%M:%SZ";
            char buffer[100];
            std::time_t time_now_in_sec = time(NULL);
            std::time_t departure_time =
                time_now_in_sec + v2g_charge_parameter_discovery_req->DC_EVChargeParameter.DepartureTime;
            std::strftime(buffer, sizeof(buffer), format, std::gmtime(&departure_time));
            ctx->p_charger->publish_departure_time(buffer);
        }

        auto& dc_charging_parameters = charging_needs.dc_charging_parameters.emplace();

        if (v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyCapacity_isUsed == (unsigned int)1) {
            ctx->p_charger->publish_dc_ev_energy_capacity(calc_physical_value(
                v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyCapacity.Value,
                v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyCapacity.Multiplier));

            dc_charging_parameters.ev_energy_capacity = calc_physical_value(
                v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyCapacity.Value,
                v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyCapacity.Multiplier);
        }
        if (v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyRequest_isUsed == (unsigned int)1) {
            ctx->p_charger->publish_dc_ev_energy_request(calc_physical_value(
                v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyRequest.Value,
                v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyRequest.Multiplier));

            // OCPP2.1 Spec: Relates to: ISO 15118-2: DC_EVChargeParameterType: EVEnergyRequest
            dc_charging_parameters.energy_amount = calc_physical_value(
                v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyRequest.Value,
                v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVEnergyRequest.Multiplier);
        }
        if (v2g_charge_parameter_discovery_req->DC_EVChargeParameter.FullSOC_isUsed == (unsigned int)1) {
            ctx->p_charger->publish_dc_full_soc(v2g_charge_parameter_discovery_req->DC_EVChargeParameter.FullSOC);
            dc_charging_parameters.full_soc = v2g_charge_parameter_discovery_req->DC_EVChargeParameter.FullSOC;
        }
        if (v2g_charge_parameter_discovery_req->DC_EVChargeParameter.BulkSOC_isUsed == (unsigned int)1) {
            ctx->p_charger->publish_dc_bulk_soc(v2g_charge_parameter_discovery_req->DC_EVChargeParameter.BulkSOC);
            dc_charging_parameters.bulk_soc = v2g_charge_parameter_discovery_req->DC_EVChargeParameter.BulkSOC;
        }
        float evMaximumCurrentLimit = calc_physical_value(
            v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVMaximumCurrentLimit.Value,
            v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVMaximumCurrentLimit.Multiplier);
        float evMaximumPowerLimit = calc_physical_value(
            v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVMaximumPowerLimit.Value,
            v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVMaximumPowerLimit.Multiplier);
        float evMaximumVoltageLimit = calc_physical_value(
            v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVMaximumVoltageLimit.Value,
            v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVMaximumVoltageLimit.Multiplier);
        publish_dc_ev_maximum_limits(
            ctx, evMaximumCurrentLimit, (unsigned int)1, evMaximumPowerLimit,
            v2g_charge_parameter_discovery_req->DC_EVChargeParameter.EVMaximumPowerLimit_isUsed, evMaximumVoltageLimit,
            (unsigned int)1);
        publish_DcEvStatus(ctx, v2g_charge_parameter_discovery_req->DC_EVChargeParameter.DC_EVStatus);

        dc_charging_parameters.ev_max_current = evMaximumCurrentLimit;
        dc_charging_parameters.ev_max_power = evMaximumPowerLimit;
        dc_charging_parameters.ev_max_voltage = evMaximumVoltageLimit;

        dc_charging_parameters.state_of_charge =
            v2g_charge_parameter_discovery_req->DC_EVChargeParameter.DC_EVStatus.EVRESSSOC;
    }

    // Publish charging needs
    ctx->p_extensions->publish_charging_needs(charging_needs);
}

/*!
 * \brief publish_iso_pre_charge_req This function publishes the iso_pre_charge_req message to the MQTT interface.
 * \param ctx is the V2G context.
 * \param v2g_precharge_req is the request message.
 */
static void publish_iso_pre_charge_req(struct v2g_context* ctx,
                                       struct iso2_PreChargeReqType const* const v2g_precharge_req) {
    publish_dc_ev_target_voltage_current(
        ctx,
        calc_physical_value(v2g_precharge_req->EVTargetVoltage.Value, v2g_precharge_req->EVTargetVoltage.Multiplier),
        calc_physical_value(v2g_precharge_req->EVTargetCurrent.Value, v2g_precharge_req->EVTargetCurrent.Multiplier));
    publish_DcEvStatus(ctx, v2g_precharge_req->DC_EVStatus);
}

/*!
 * \brief publish_iso_power_delivery_req This function publishes the iso_power_delivery_req message to the MQTT
 * interface. \param ctx is the V2G context. \param v2g_power_delivery_req is the request message.
 */
static void publish_iso_power_delivery_req(struct v2g_context* ctx,
                                           struct iso2_PowerDeliveryReqType const* const v2g_power_delivery_req) {
    // V2G values that can be published: ChargeProgress, SAScheduleTupleID
    if (v2g_power_delivery_req->DC_EVPowerDeliveryParameter_isUsed == (unsigned int)1) {
        ctx->p_charger->publish_dc_charging_complete(
            v2g_power_delivery_req->DC_EVPowerDeliveryParameter.ChargingComplete);
        if (v2g_power_delivery_req->DC_EVPowerDeliveryParameter.BulkChargingComplete_isUsed == (unsigned int)1) {
            ctx->p_charger->publish_dc_bulk_charging_complete(
                v2g_power_delivery_req->DC_EVPowerDeliveryParameter.BulkChargingComplete);
        }
        publish_DcEvStatus(ctx, v2g_power_delivery_req->DC_EVPowerDeliveryParameter.DC_EVStatus);
    }
}

/*!
 * \brief publish_iso_current_demand_req This function publishes the iso_current_demand_req message to the MQTT
 * interface. \param ctx is the V2G context \param v2g_current_demand_req is the request message.
 */
static void publish_iso_current_demand_req(struct v2g_context* ctx,
                                           struct iso2_CurrentDemandReqType const* const v2g_current_demand_req) {
    if ((v2g_current_demand_req->BulkChargingComplete_isUsed == (unsigned int)1) &&
        (ctx->ev_v2g_data.bulk_charging_complete != v2g_current_demand_req->BulkChargingComplete)) {
        ctx->p_charger->publish_dc_bulk_charging_complete(v2g_current_demand_req->BulkChargingComplete);
        ctx->ev_v2g_data.bulk_charging_complete = v2g_current_demand_req->BulkChargingComplete;
    }
    if (ctx->ev_v2g_data.charging_complete != v2g_current_demand_req->ChargingComplete) {
        ctx->p_charger->publish_dc_charging_complete(v2g_current_demand_req->ChargingComplete);
        ctx->ev_v2g_data.charging_complete = v2g_current_demand_req->ChargingComplete;
    }

    publish_DcEvStatus(ctx, v2g_current_demand_req->DC_EVStatus);

    publish_dc_ev_target_voltage_current(ctx,
                                         calc_physical_value(v2g_current_demand_req->EVTargetVoltage.Value,
                                                             v2g_current_demand_req->EVTargetVoltage.Multiplier),
                                         calc_physical_value(v2g_current_demand_req->EVTargetCurrent.Value,
                                                             v2g_current_demand_req->EVTargetCurrent.Multiplier));

    float evMaximumCurrentLimit = calc_physical_value(v2g_current_demand_req->EVMaximumCurrentLimit.Value,
                                                      v2g_current_demand_req->EVMaximumCurrentLimit.Multiplier);
    float evMaximumPowerLimit = calc_physical_value(v2g_current_demand_req->EVMaximumPowerLimit.Value,
                                                    v2g_current_demand_req->EVMaximumPowerLimit.Multiplier);
    float evMaximumVoltageLimit = calc_physical_value(v2g_current_demand_req->EVMaximumVoltageLimit.Value,
                                                      v2g_current_demand_req->EVMaximumVoltageLimit.Multiplier);

    publish_dc_ev_maximum_limits(ctx, evMaximumCurrentLimit, v2g_current_demand_req->EVMaximumCurrentLimit_isUsed,
                                 evMaximumPowerLimit, v2g_current_demand_req->EVMaximumPowerLimit_isUsed,
                                 evMaximumVoltageLimit, v2g_current_demand_req->EVMaximumVoltageLimit_isUsed);

    float v2g_dc_ev_remaining_time_to_full_soc =
        calc_physical_value(v2g_current_demand_req->RemainingTimeToFullSoC.Value,
                            v2g_current_demand_req->RemainingTimeToFullSoC.Multiplier);
    float v2g_dc_ev_remaining_time_to_bulk_soc =
        calc_physical_value(v2g_current_demand_req->RemainingTimeToBulkSoC.Value,
                            v2g_current_demand_req->RemainingTimeToBulkSoC.Multiplier);
    publish_dc_ev_remaining_time(
        ctx, v2g_dc_ev_remaining_time_to_full_soc, v2g_current_demand_req->RemainingTimeToFullSoC_isUsed,
        v2g_dc_ev_remaining_time_to_bulk_soc, v2g_current_demand_req->RemainingTimeToBulkSoC_isUsed);
}
/*!
 * \brief publish_iso_metering_receipt_req This function publishes the iso_metering_receipt_req message to the MQTT
 * interface. \param v2g_metering_receipt_req is the request message.
 */
static void publish_iso_metering_receipt_req(struct iso2_MeteringReceiptReqType const* const v2g_metering_receipt_req) {
    // TODO: publish PnC only
}

/*!
 * \brief publish_iso_welding_detection_req This function publishes the iso_welding_detection_req message to the MQTT
 * interface. \param p_charger to publish MQTT topics. \param v2g_welding_detection_req is the request message.
 */
static void
publish_iso_welding_detection_req(struct v2g_context* ctx,
                                  struct iso2_WeldingDetectionReqType const* const v2g_welding_detection_req) {
    // TODO: V2G values that can be published: EVErrorCode, EVReady, EVRESSSOC
    publish_DcEvStatus(ctx, v2g_welding_detection_req->DC_EVStatus);
}

/*!
 * \brief publish_iso_certificate_installation_exi_req This function publishes the iso_certificate_update_req message to
 * the MQTT interface. \param AExiBuffer is the exi msg where the V2G EXI msg is stored. \param AExiBufferSize is the
 * size of the V2G msg. \return Returns \c true if it was successful, otherwise \c false.
 */
static bool publish_iso_certificate_installation_exi_req(struct v2g_context* ctx, uint8_t* AExiBuffer,
                                                         size_t AExiBufferSize) {
    // PnC only

    bool rv = true;
    types::iso15118::RequestExiStreamSchema certificate_request;

    certificate_request.exi_request = openssl::base64_encode(AExiBuffer, AExiBufferSize);
    if (certificate_request.exi_request.size() > MQTT_MAX_PAYLOAD_SIZE) {
        dlog(DLOG_LEVEL_ERROR, "Mqtt payload size exceeded!");
        return false;
    }
    if (certificate_request.exi_request.size() == 0) {
        dlog(DLOG_LEVEL_ERROR, "Unable to encode contract leaf certificate");
        return false;
    }

    certificate_request.iso15118_schema_version = ISO_15118_2013_MSG_DEF;
    certificate_request.certificate_action = types::iso15118::CertificateActionEnum::Install;
    ctx->p_extensions->publish_iso15118_certificate_request(certificate_request);

    return rv;
}

//=============================================
//             Request Handling
//=============================================

/*!
 * \brief handle_iso_session_setup This function handles the iso_session_setup msg pair. It analyzes the request msg and
 * fills the response msg. \param conn holds the structure with the V2G msg pair. \return Returns the next V2G-event.
 */
static enum v2g_event handle_iso_session_setup(struct v2g_connection* conn) {
    struct iso2_SessionSetupReqType* req = &conn->exi_in.iso2EXIDocument->V2G_Message.Body.SessionSetupReq;
    struct iso2_SessionSetupResType* res = &conn->exi_out.iso2EXIDocument->V2G_Message.Body.SessionSetupRes;
    char buffer[iso2_evccIDType_BYTES_SIZE * 3 - 1 + 1]; /* format: (%02x:) * n - (1x ':') + (1x NULL) */
    int i;
    enum v2g_event next_event = V2G_EVENT_NO_EVENT;

    /* format EVCC ID */
    for (i = 0; i < req->EVCCID.bytesLen; i++) {
        sprintf(&buffer[i * 3], "%02" PRIX8 ":", req->EVCCID.bytes[i]);
    }
    if (i)
        buffer[i * 3 - 1] = '\0';
    else
        buffer[0] = '\0';

    conn->ctx->p_charger->publish_evcc_id(buffer); // publish EVCC ID

    dlog(DLOG_LEVEL_INFO, "SessionSetupReq.EVCCID: %s", std::string(buffer).size() ? buffer : "(zero length provided)");

    /* [V2G2-756]: If the SECC receives a SessionSetupReq including a SessionID value which is not
     * equal to zero (0) and not equal to the SessionID value stored from the preceding V2G
     * Communication Session, it shall send a SessionID value in the SessionSetupRes message that is
     * unequal to "0" and unequal to the SessionID value stored from the preceding V2G Communication
     * Session and indicate the new V2G Communication Session with the ResponseCode set to
     * "OK_NewSessionEstablished"
     */

    // TODO: handle resuming sessions [V2G2-463]

    /* Now fill the evse response message */
    res->ResponseCode = iso2_responseCodeType_OK_NewSessionEstablished;

    /* Check and init session id */
    /* If no session id is configured, generate one */
    srand((unsigned int)time(NULL));
    if (conn->ctx->evse_v2g_data.session_id == (uint64_t)0 ||
        conn->ctx->evse_v2g_data.session_id != conn->ctx->ev_v2g_data.received_session_id) {
        conn->ctx->evse_v2g_data.session_id =
            ((uint64_t)rand() << 48) | ((uint64_t)rand() << 32) | ((uint64_t)rand() << 16) | (uint64_t)rand();
        dlog(
            DLOG_LEVEL_INFO,
            "No session_id found or not equal to the id from the preceding v2g session. Generating random session id.");
        dlog(DLOG_LEVEL_INFO, "Created new session with id 0x%08" PRIu64, conn->ctx->evse_v2g_data.session_id);
    } else {
        dlog(DLOG_LEVEL_INFO, "Found Session_id from the old session: 0x%08" PRIu64,
             conn->ctx->evse_v2g_data.session_id);
        res->ResponseCode = iso2_responseCodeType_OK_OldSessionJoined;
    }

    /* TODO: publish EVCCID to MQTT */

    res->EVSEID.charactersLen = conn->ctx->evse_v2g_data.evse_id.bytesLen;
    memcpy(res->EVSEID.characters, conn->ctx->evse_v2g_data.evse_id.bytes, conn->ctx->evse_v2g_data.evse_id.bytesLen);

    res->EVSETimeStamp_isUsed = conn->ctx->evse_v2g_data.date_time_now_is_used;
    res->EVSETimeStamp = time(NULL);

    /* Check the current response code and check if no external error has occurred */
    next_event = (v2g_event)iso_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = (int)iso_dc_state_id::WAIT_FOR_SERVICEDISCOVERY; // [V2G-543]

    return next_event;
}

/*!
 * \brief handle_iso_service_discovery This function handles the din service discovery msg pair. It analyzes the request
 * msg and fills the response msg. The request and response msg based on the open V2G structures. This structures must
 * be provided within the \c conn structure.
 * \param conn holds the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_iso_service_discovery(struct v2g_connection* conn) {
    struct iso2_ServiceDiscoveryReqType* req = &conn->exi_in.iso2EXIDocument->V2G_Message.Body.ServiceDiscoveryReq;
    struct iso2_ServiceDiscoveryResType* res = &conn->exi_out.iso2EXIDocument->V2G_Message.Body.ServiceDiscoveryRes;
    enum v2g_event nextEvent = V2G_EVENT_NO_EVENT;
    int8_t scope_idx = -1; // To find a list entry within the evse service list */

    /* At first, publish the received ev request message to the MQTT interface */
    publish_iso_service_discovery_req(req);

    /* build up response */
    res->ResponseCode = iso2_responseCodeType_OK;

    // Checking of the charge service id
    if (conn->ctx->evse_v2g_data.charge_service.ServiceID != V2G_SERVICE_ID_CHARGING) {
        dlog(DLOG_LEVEL_WARNING,
             "Selected ServiceID is not ISO15118 conform. Correcting value to '1' (Charge service id)");
        conn->ctx->evse_v2g_data.charge_service.ServiceID = V2G_SERVICE_ID_CHARGING;
    }
    // Checking of the service category
    if (conn->ctx->evse_v2g_data.charge_service.ServiceCategory != iso2_serviceCategoryType_EVCharging) {
        dlog(DLOG_LEVEL_WARNING,
             "Selected ServiceCategory is not ISO15118 conform. Correcting value to '0' (EVCharging)");
        conn->ctx->evse_v2g_data.charge_service.ServiceCategory = iso2_serviceCategoryType_EVCharging;
    }

    res->ChargeService = conn->ctx->evse_v2g_data.charge_service;

    // Checking of the payment options
    if ((!conn->is_tls_connection) &&
        ((conn->ctx->evse_v2g_data.payment_option_list[0] == iso2_paymentOptionType_Contract) ||
         (conn->ctx->evse_v2g_data.payment_option_list[1] == iso2_paymentOptionType_Contract))) {
        conn->ctx->evse_v2g_data.payment_option_list[0] = iso2_paymentOptionType_ExternalPayment;
        conn->ctx->evse_v2g_data.payment_option_list_len = 1;
        dlog(DLOG_LEVEL_WARNING,
             "PnC is not allowed without TLS-communication. Correcting value to '1' (ExternalPayment)");
    }

    memcpy(res->PaymentOptionList.PaymentOption.array, conn->ctx->evse_v2g_data.payment_option_list,
           conn->ctx->evse_v2g_data.payment_option_list_len * sizeof(iso2_paymentOptionType));
    res->PaymentOptionList.PaymentOption.arrayLen = conn->ctx->evse_v2g_data.payment_option_list_len;

    /* Find requested scope id within evse service list */
    if (req->ServiceScope_isUsed) {
        /* Check if ServiceScope is in evse ServiceList */
        for (uint8_t idx = 0; idx < conn->ctx->evse_v2g_data.evse_service_list.size(); idx++) {
            if ((conn->ctx->evse_v2g_data.evse_service_list[idx].ServiceScope_isUsed == (unsigned int)1) &&
                (strcmp(conn->ctx->evse_v2g_data.evse_service_list[idx].ServiceScope.characters,
                        req->ServiceScope.characters) == 0)) {
                scope_idx = idx;
                break;
            }
        }
    }

    /*  The SECC always returns all supported services for all scopes if no specific ServiceScope has been
        indicated in request message. */
    if (scope_idx == (int8_t)-1) {
        std::copy(conn->ctx->evse_v2g_data.evse_service_list.begin(), conn->ctx->evse_v2g_data.evse_service_list.end(),
                  res->ServiceList.Service.array);
        res->ServiceList.Service.arrayLen = conn->ctx->evse_v2g_data.evse_service_list.size();
    } else {
        /* Offer only the requested ServiceScope entry */
        res->ServiceList.Service.array[0] = conn->ctx->evse_v2g_data.evse_service_list[scope_idx];
        res->ServiceList.Service.arrayLen = 1;
    }

    res->ServiceList_isUsed =
        ((uint16_t)0 < conn->ctx->evse_v2g_data.evse_service_list.size()) ? (unsigned int)1 : (unsigned int)0;

    /* Check the current response code and check if no external error has occurred */
    nextEvent = (v2g_event)iso_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = (int)iso_dc_state_id::WAIT_FOR_SVCDETAIL_PAYMENTSVCSEL; // [V2G-545]

    return nextEvent;
}

/*!
 * \brief handle_iso_service_detail This function handles the iso_service_detail msg pair. It analyzes the request msg
 * and fills the response msg. The request and response msg based on the open V2G structures. This structures must be
 * provided within the \c conn structure. (Optional VAS)
 * \param conn holds the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_iso_service_detail(struct v2g_connection* conn) {
    struct iso2_ServiceDetailReqType* req = &conn->exi_in.iso2EXIDocument->V2G_Message.Body.ServiceDetailReq;
    struct iso2_ServiceDetailResType* res = &conn->exi_out.iso2EXIDocument->V2G_Message.Body.ServiceDetailRes;
    enum v2g_event next_event = V2G_EVENT_NO_EVENT;

    /* At first, publish the received ev request message to the MQTT interface */
    publish_iso_service_detail_req(req);

    res->ResponseCode = iso2_responseCodeType_OK;

    /* ServiceID reported back always matches the requested one */
    res->ServiceID = req->ServiceID;

    bool service_id_found = false;

    for (uint8_t idx = 0; idx < conn->ctx->evse_v2g_data.evse_service_list.size(); idx++) {

        if (req->ServiceID == conn->ctx->evse_v2g_data.evse_service_list[idx].ServiceID) {
            service_id_found = true;

            /* Fill parameter list of the requested service id [V2G2-549] */
            for (uint8_t idx2 = 0; idx2 < conn->ctx->evse_v2g_data.service_parameter_list[idx].ParameterSet.arrayLen;
                 idx2++) {
                res->ServiceParameterList.ParameterSet.array[idx2] =
                    conn->ctx->evse_v2g_data.service_parameter_list[idx].ParameterSet.array[idx2];
            }
            res->ServiceParameterList.ParameterSet.arrayLen =
                conn->ctx->evse_v2g_data.service_parameter_list[idx].ParameterSet.arrayLen;
            res->ServiceParameterList_isUsed = (res->ServiceParameterList.ParameterSet.arrayLen != 0) ? 1 : 0;
        }
    }
    service_id_found = (req->ServiceID == V2G_SERVICE_ID_CHARGING) ? true : service_id_found;

    if (false == service_id_found) {
        res->ResponseCode = iso2_responseCodeType_FAILED_ServiceIDInvalid; // [V2G2-464]
    }

    /* Check the current response code and check if no external error has occurred */
    next_event = (v2g_event)iso_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = (int)iso_dc_state_id::WAIT_FOR_SVCDETAIL_PAYMENTSVCSEL; // [V2G-DC-548]

    return next_event;
}

/*!
 * \brief handle_iso_payment_service_selection This function handles the iso_payment_service_selection msg pair. It
 * analyzes the request msg and fills the response msg. The request and response msg based on the open V2G structures.
 * This structures must be provided within the \c conn structure.
 * \param conn holds the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_iso_payment_service_selection(struct v2g_connection* conn) {
    struct iso2_PaymentServiceSelectionReqType* req =
        &conn->exi_in.iso2EXIDocument->V2G_Message.Body.PaymentServiceSelectionReq;
    struct iso2_PaymentServiceSelectionResType* res =
        &conn->exi_out.iso2EXIDocument->V2G_Message.Body.PaymentServiceSelectionRes;
    enum v2g_event next_event = V2G_EVENT_NO_EVENT;
    uint8_t idx = 0;
    bool list_element_found = false;

    /* At first, publish the received ev request message to the customer mqtt interface */
    publish_iso_payment_service_selection_req(req);

    res->ResponseCode = iso2_responseCodeType_OK;

    /* check whether the selected payment option was announced at all;
     * this also covers the case that the peer sends any invalid/unknown payment option
     * in the message; if we are not happy -> bail out
     */
    for (idx = 0; idx < conn->ctx->evse_v2g_data.payment_option_list_len; idx++) {
        if (conn->ctx->evse_v2g_data.payment_option_list[idx] == req->SelectedPaymentOption) {
            list_element_found = true;
            conn->ctx->p_charger->publish_selected_payment_option(
                static_cast<types::iso15118::PaymentOption>(req->SelectedPaymentOption));
            break;
        }
    }
    res->ResponseCode = (list_element_found == true)
                            ? res->ResponseCode
                            : iso2_responseCodeType_FAILED_PaymentSelectionInvalid; // [V2G2-465]

    /* Check the selected services */
    bool charge_service_found = false;
    bool selected_services_found = true;

    for (uint8_t req_idx = 0;
         (req_idx < req->SelectedServiceList.SelectedService.arrayLen) && (selected_services_found == true);
         req_idx++) {

        /* Check if it's a charging service */
        if (req->SelectedServiceList.SelectedService.array[req_idx].ServiceID == V2G_SERVICE_ID_CHARGING) {
            charge_service_found = true;
        }
        /* Otherwise check if the selected service is in the stored in the service list */
        else {
            bool entry_found = false;
            for (uint8_t ci_idx = 0;
                 (ci_idx < conn->ctx->evse_v2g_data.evse_service_list.size()) && (entry_found == false); ci_idx++) {

                if (req->SelectedServiceList.SelectedService.array[req_idx].ServiceID ==
                    conn->ctx->evse_v2g_data.evse_service_list[ci_idx].ServiceID) {
                    /* If it's stored, search for the next requested SelectedService entry */
                    dlog(DLOG_LEVEL_INFO, "Selected service id %i found",
                         conn->ctx->evse_v2g_data.evse_service_list[ci_idx].ServiceID);

                    if (conn->ctx->evse_v2g_data.evse_service_list[ci_idx].ServiceID == SAE_V2H) {
                        conn->ctx->evse_v2g_data.sae_bidi_data.enabled_sae_v2h = true;
                        conn->ctx->evse_v2g_data.sae_bidi_data.enabled_sae_v2g = false;
                        conn->ctx->p_charger->publish_sae_bidi_mode_active(nullptr);
                    } else if (conn->ctx->evse_v2g_data.evse_service_list[ci_idx].ServiceID == SAE_V2G) {
                        conn->ctx->evse_v2g_data.sae_bidi_data.enabled_sae_v2h = false;
                        conn->ctx->evse_v2g_data.sae_bidi_data.enabled_sae_v2g = true;
                        conn->ctx->p_charger->publish_sae_bidi_mode_active(nullptr);
                    }
                    entry_found = true;
                    break;
                }
            }
            if (entry_found == false) {
                /* If the requested SelectedService entry was not found, break up service list check */
                selected_services_found = false;
                break;
            }
        }
    }

    res->ResponseCode = (selected_services_found == false) ? iso2_responseCodeType_FAILED_ServiceSelectionInvalid
                                                           : res->ResponseCode; // [V2G2-467]
    res->ResponseCode = (charge_service_found == false) ? iso2_responseCodeType_FAILED_NoChargeServiceSelected
                                                        : res->ResponseCode; // [V2G2-804]

    /* Check the current response code and check if no external error has occurred */
    next_event = (v2g_event)iso_validate_response_code(&res->ResponseCode, conn);

    if (req->SelectedPaymentOption == iso2_paymentOptionType_Contract) {
        dlog(DLOG_LEVEL_INFO, "SelectedPaymentOption: Contract");
        conn->ctx->session.iso_selected_payment_option = iso2_paymentOptionType_Contract;
        /* Set next expected req msg */
        conn->ctx->state =
            (int)iso_dc_state_id::WAIT_FOR_PAYMENTDETAILS_CERTINST_CERTUPD; // [V2G-551] (iso specification describes
                                                                            // only the ac case... )
    } else {
        dlog(DLOG_LEVEL_INFO, "SelectedPaymentOption: ExternalPayment");
        conn->ctx->evse_v2g_data.evse_processing[PHASE_AUTH] =
            (uint8_t)iso2_EVSEProcessingType_Ongoing_WaitingForCustomerInteraction; // [V2G2-854]
        /* Set next expected req msg */
        conn->ctx->state = (int)
            iso_dc_state_id::WAIT_FOR_AUTHORIZATION; // [V2G-551] (iso specification describes only the ac case... )
        conn->ctx->session.auth_start_timeout = getmonotonictime();
    }

    return next_event;
}

/*!
 * \brief handle_iso_payment_details This function handles the iso_payment_details msg pair. It analyzes the request msg
 * and fills the response msg. The request and response msg based on the open V2G structures. This structures must be
 * provided within the \c conn structure.
 * \param conn holds the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_iso_payment_details(struct v2g_connection* conn) {
    struct iso2_PaymentDetailsReqType* req = &conn->exi_in.iso2EXIDocument->V2G_Message.Body.PaymentDetailsReq;
    struct iso2_PaymentDetailsResType* res = &conn->exi_out.iso2EXIDocument->V2G_Message.Body.PaymentDetailsRes;
    enum v2g_event nextEvent = V2G_EVENT_NO_EVENT;
    int err;

    // === For the contract certificate, the certificate chain should be checked ===
    if (conn->ctx->session.iso_selected_payment_option == iso2_paymentOptionType_Contract) {
        // Free old stuff if it exists
        free_connection_crypto_data(conn);

        // Parse contract leaf certificate

        certificate_ptr contract_crt{nullptr, nullptr};
        certificate_list chain{};

        if (req->ContractSignatureCertChain.Certificate.bytesLen != 0) {
            err = parse_contract_certificate(contract_crt, req->ContractSignatureCertChain.Certificate.bytes,
                                             req->ContractSignatureCertChain.Certificate.bytesLen);
        } else {
            dlog(DLOG_LEVEL_ERROR, "No certificate received!");
            res->ResponseCode = iso2_responseCodeType_FAILED_CertChainError;
            goto error_out;
        }

        auto cert_emaid = getEmaidFromContractCert(contract_crt);
        std::string req_emaid{&req->eMAID.characters[0], req->eMAID.charactersLen};

        /* Filter '-' character */
        cert_emaid.erase(std::remove(cert_emaid.begin(), cert_emaid.end(), '-'), cert_emaid.end());
        req_emaid.erase(std::remove(req_emaid.begin(), req_emaid.end(), '-'), req_emaid.end());

        dlog(DLOG_LEVEL_TRACE, "emaid-v2g: %s emaid-cert: %s", req_emaid.c_str(), cert_emaid.c_str());

        if ((req_emaid.size() != cert_emaid.size()) ||
            (strncasecmp(req_emaid.c_str(), cert_emaid.c_str(), req_emaid.size()) != 0)) {
            dlog(DLOG_LEVEL_ERROR, "emaid of the contract certificate doesn't match with the received v2g-emaid");
            res->ResponseCode = iso2_responseCodeType_FAILED_CertChainError;
            goto error_out;
        }

        if (err != 0) {
            memset(res, 0, sizeof(*res));
            res->ResponseCode = iso2_responseCodeType_FAILED_CertChainError;
            goto error_out;
        }

        assert(conn->pubkey != nullptr);
        *conn->pubkey = certificate_public_key(contract_crt.get());
        err = (*conn->pubkey == nullptr) ? -1 : 0;

        if (err != 0) {
            memset(res, 0, sizeof(*res));
            res->ResponseCode = iso2_responseCodeType_FAILED_CertChainError;
            goto error_out;
        }

        // Parse contract sub certificates
        if (req->ContractSignatureCertChain.SubCertificates_isUsed == 1) {
            for (int i = 0; i < req->ContractSignatureCertChain.SubCertificates.Certificate.arrayLen; i++) {
                err =
                    load_certificate(&chain, req->ContractSignatureCertChain.SubCertificates.Certificate.array[i].bytes,
                                     req->ContractSignatureCertChain.SubCertificates.Certificate.array[i].bytesLen);
                if (err != 0) {
                    res->ResponseCode = iso2_responseCodeType_FAILED_CertChainError;
                    goto error_out;
                }
            }
        }

        // initialize contract cert chain to retrieve ocsp request data

        // Save the certificate chain in a variable in PEM format to publish it
        std::string contract_cert_chain_pem = chain_to_pem(contract_crt, &chain);

        std::optional<std::vector<types::iso15118::CertificateHashDataInfo>> iso15118_certificate_hash_data;

        /* Only if certificate chain verification should be done locally by the EVSE */
        if (conn->ctx->session.verify_contract_cert_chain == true) {
            std::string v2g_root_cert_path =
                conn->ctx->r_security->call_get_verify_file(types::evse_security::CaCertificateType::V2G);
            std::string mo_root_cert_path =
                conn->ctx->r_security->call_get_verify_file(types::evse_security::CaCertificateType::MO);

            crypto::verify_result_t vRes = verify_certificate(contract_crt, &chain, v2g_root_cert_path.c_str(),
                                                              mo_root_cert_path.c_str(), conn->ctx->debugMode);

            err = -1;
            bool forward_contract = false;
            switch (vRes) {
            case crypto::verify_result_t::Verified:
                err = 0;
                break;
            case crypto::verify_result_t::CertificateExpired:
                res->ResponseCode = iso2_responseCodeType_FAILED_CertificateExpired;
                break;
            case crypto::verify_result_t::CertificateRevoked:
                // forward to csms if central_contract_validation_allowed is true
                if (conn->ctx->evse_v2g_data.central_contract_validation_allowed) {
                    forward_contract = true;
                } else {
                    res->ResponseCode = iso2_responseCodeType_FAILED_CertificateRevoked;
                }
                break;
            case crypto::verify_result_t::NoCertificateAvailable:
                // forward to csms if central_contract_validation_allowed is true
                if (conn->ctx->evse_v2g_data.central_contract_validation_allowed) {
                    forward_contract = true;
                } else {
                    res->ResponseCode = iso2_responseCodeType_FAILED_NoCertificateAvailable;
                }
                break;
            case crypto::verify_result_t::CertificateNotAllowed:
                // forward to csms if central_contract_validation_allowed is true
                if (conn->ctx->evse_v2g_data.central_contract_validation_allowed) {
                    forward_contract = true;
                } else {
                    res->ResponseCode = iso2_responseCodeType_FAILED_CertificateNotAllowedAtThisEVSE;
                }
                break;
            case crypto::verify_result_t::CertChainError:
            default:
                res->ResponseCode = iso2_responseCodeType_FAILED_CertChainError;
                break;
            }

            if (err == -1) {
                dlog(DLOG_LEVEL_ERROR, "Validation of the contract certificate failed!");
                if (!forward_contract) {
                    dlog(DLOG_LEVEL_ERROR, "Central contract validation is not allowed.");
                    // EVSETimeStamp and GenChallenge are mandatory, GenChallenge has fixed size
                    res->EVSETimeStamp = time(NULL);
                    memset(res->GenChallenge.bytes, 0, GEN_CHALLENGE_SIZE);
                    res->GenChallenge.bytesLen = GEN_CHALLENGE_SIZE;
                    goto error_out;
                } else {
                    dlog(DLOG_LEVEL_INFO, "Central contract validation is allowed: Forwarding contract");
                }
            } else {
                dlog(DLOG_LEVEL_INFO, "Validation of the contract certificate was successful!");

                // contract chain ocsp data can only be retrieved if the MO root is present and the chain could be
                // verified
                const auto ocsp_response =
                    conn->ctx->r_security->call_get_mo_ocsp_request_data(contract_cert_chain_pem);
                iso15118_certificate_hash_data = convert_to_certificate_hash_data_info_vector(ocsp_response);
            }
        }

        generate_random_data(&conn->ctx->session.gen_challenge, GEN_CHALLENGE_SIZE);
        memcpy(res->GenChallenge.bytes, conn->ctx->session.gen_challenge, GEN_CHALLENGE_SIZE);
        res->GenChallenge.bytesLen = GEN_CHALLENGE_SIZE;

        // Publish the provided signature certificate chain and eMAID from EVCC
        // to receive PnC authorization
        types::authorization::ProvidedIdToken ProvidedIdToken;
        ProvidedIdToken.id_token = {std::string(cert_emaid), types::authorization::IdTokenType::eMAID};
        ProvidedIdToken.authorization_type = types::authorization::AuthorizationType::PlugAndCharge;
        ProvidedIdToken.iso15118CertificateHashData = iso15118_certificate_hash_data;
        ProvidedIdToken.certificate = contract_cert_chain_pem;
        conn->ctx->session.provided_id_token.emplace(ProvidedIdToken);

    } else {
        res->ResponseCode = iso2_responseCodeType_FAILED;
        goto error_out;
    }
    res->EVSETimeStamp = time(NULL);
    res->ResponseCode = iso2_responseCodeType_OK;

error_out:

    /* Check the current response code and check if no external error has occurred */
    nextEvent = iso_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = (int)iso_dc_state_id::WAIT_FOR_AUTHORIZATION; // [V2G-560]
    conn->ctx->session.auth_start_timeout = getmonotonictime();

    return nextEvent;
}

/*!
 * \brief handle_iso_authorization This function handles the iso_authorization msg pair. It analyzes the request msg and
 * fills the response msg. The request and response msg based on the open v2g structures. This structures must be
 * provided within the \c conn structure.
 * \param conn holds the structure with the v2g msg pair.
 * \return Returns the next v2g-event.
 */
static enum v2g_event handle_iso_authorization(struct v2g_connection* conn) {
    struct iso2_AuthorizationReqType* req = &conn->exi_in.iso2EXIDocument->V2G_Message.Body.AuthorizationReq;
    struct iso2_AuthorizationResType* res = &conn->exi_out.iso2EXIDocument->V2G_Message.Body.AuthorizationRes;
    enum v2g_event next_event = V2G_EVENT_NO_EVENT;
    bool is_payment_option_contract = conn->ctx->session.iso_selected_payment_option == iso2_paymentOptionType_Contract;

    /* At first, publish the received ev request message to the customer mqtt interface */
    publish_iso_authorization_req(req);

    res->ResponseCode = iso2_responseCodeType_OK;

    if (conn->ctx->last_v2g_msg != V2G_AUTHORIZATION_MSG &&
        (conn->ctx->session.iso_selected_payment_option == iso2_paymentOptionType_Contract)) { /* [V2G2-684] */
        if (req->GenChallenge_isUsed == 0 ||
            req->GenChallenge.bytesLen != 16 // [V2G2-697]  The GenChallenge field shall be exactly 128 bits long.
            || memcmp(req->GenChallenge.bytes, conn->ctx->session.gen_challenge, 16) != 0) {
            dlog(DLOG_LEVEL_ERROR, "Challenge invalid or not present");
            res->ResponseCode = iso2_responseCodeType_FAILED_ChallengeInvalid; // [V2G2-475]
            goto error_out;
        }
        if (conn->exi_in.iso2EXIDocument->V2G_Message.Header.Signature_isUsed == 0) {
            dlog(DLOG_LEVEL_ERROR, "Missing signature (Signature_isUsed == 0)");
            res->ResponseCode = iso2_responseCodeType_FAILED_SignatureError;
            goto error_out;
        }

        /* Validation of the received signature */
        struct iso2_exiFragment iso2_fragment;
        init_iso2_exiFragment(&iso2_fragment);

        iso2_fragment.AuthorizationReq_isUsed = 1u;
        memcpy(&iso2_fragment.AuthorizationReq, req, sizeof(*req));

        assert(conn->pubkey != nullptr);
        const bool bSigRes = check_iso2_signature(&conn->exi_in.iso2EXIDocument->V2G_Message.Header.Signature,
                                                  conn->pubkey->get(), &iso2_fragment);

        if (!bSigRes) {
            res->ResponseCode = iso2_responseCodeType_FAILED_SignatureError;
            goto error_out;
        }
        if (conn->ctx->session.provided_id_token.has_value()) {
            conn->ctx->p_charger->publish_require_auth_pnc(conn->ctx->session.provided_id_token.value());
            conn->ctx->session.provided_id_token.reset();
        } else {
            // this should never happen, since the contract certificate is set in handle_iso_payment_details in case
            // contract is selected
            dlog(DLOG_LEVEL_ERROR, "No contract certificate could be retrieved!");
            res->ResponseCode = iso2_responseCodeType_FAILED;
            goto error_out;
        }
    }
    res->EVSEProcessing = (iso2_EVSEProcessingType)conn->ctx->evse_v2g_data.evse_processing[PHASE_AUTH];

    if (conn->ctx->evse_v2g_data.evse_processing[PHASE_AUTH] != iso2_EVSEProcessingType_Finished) {
        if (((is_payment_option_contract == false) && (conn->ctx->session.auth_timeout_eim == 0)) ||
            ((is_payment_option_contract == true) && (conn->ctx->session.auth_timeout_pnc == 0))) {
            dlog(DLOG_LEVEL_DEBUG, "Waiting for authorization forever!");
        } else if ((getmonotonictime() - conn->ctx->session.auth_start_timeout) >=
                   1000 * (is_payment_option_contract ? conn->ctx->session.auth_timeout_pnc
                                                      : conn->ctx->session.auth_timeout_eim)) {
            conn->ctx->session.auth_start_timeout = getmonotonictime();
            res->ResponseCode = iso2_responseCodeType_FAILED;
        }
    } else if (conn->ctx->session.authorization_rejected == true) {
        if (conn->ctx->session.certificate_status == types::authorization::CertificateStatus::CertificateRevoked) {
            res->ResponseCode = iso2_responseCodeType_FAILED_CertificateRevoked;
        } else {
            res->ResponseCode = iso2_responseCodeType_FAILED;
        }
    }

error_out:
    /* Check the current response code and check if no external error has occurred */
    next_event = (v2g_event)iso_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = (res->EVSEProcessing == iso2_EVSEProcessingType_Finished)
                           ? (int)iso_dc_state_id::WAIT_FOR_CHARGEPARAMETERDISCOVERY
                           : (int)iso_dc_state_id::WAIT_FOR_AUTHORIZATION; // [V2G-573] (AC) , [V2G-687] (DC)

    return next_event;
}

/*!
 * \brief handle_iso_charge_parameter_discovery This function handles the iso_charge_parameter_discovery msg pair. It
 * analyzes the request msg and fills the response msg. The request and response msg based on the open V2G structures.
 * This structures must be provided within the \c conn structure.
 * \param conn holds the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_iso_charge_parameter_discovery(struct v2g_connection* conn) {
    struct iso2_ChargeParameterDiscoveryReqType* req =
        &conn->exi_in.iso2EXIDocument->V2G_Message.Body.ChargeParameterDiscoveryReq;
    struct iso2_ChargeParameterDiscoveryResType* res =
        &conn->exi_out.iso2EXIDocument->V2G_Message.Body.ChargeParameterDiscoveryRes;
    enum v2g_event next_event = V2G_EVENT_NO_EVENT;

    /* At first, publish the received ev request message to the MQTT interface */
    publish_iso_charge_parameter_discovery_req(conn->ctx, req);

    /* First, check requested energy transfer mode, because this information is necessary for futher configuration */
    res->ResponseCode = iso2_responseCodeType_FAILED_WrongEnergyTransferMode;
    for (uint8_t idx = 0;
         idx < conn->ctx->evse_v2g_data.charge_service.SupportedEnergyTransferMode.EnergyTransferMode.arrayLen; idx++) {
        if (req->RequestedEnergyTransferMode ==
            conn->ctx->evse_v2g_data.charge_service.SupportedEnergyTransferMode.EnergyTransferMode.array[idx]) {
            res->ResponseCode = iso2_responseCodeType_OK; // [V2G2-476]
            log_selected_energy_transfer_type((int)req->RequestedEnergyTransferMode);
            break;
        }
    }

    res->EVSEChargeParameter_isUsed = 0;
    res->EVSEProcessing = (iso2_EVSEProcessingType)conn->ctx->evse_v2g_data.evse_processing[PHASE_PARAMETER];

    /* Configure SA-schedules*/
    if (res->EVSEProcessing == iso2_EVSEProcessingType_Finished) {
        /* If processing is finished, configure SASchedule list */
        if (conn->ctx->evse_v2g_data.evse_sa_schedule_list_is_used == false) {
            /* If not configured, configure SA-schedule automatically for AC charging */
            if (conn->ctx->is_dc_charger == false) {
                /* Determin max current and nominal voltage */
                float max_current = conn->ctx->basic_config.evse_ac_current_limit;
                int64_t nom_voltage =
                    conn->ctx->evse_v2g_data.evse_nominal_voltage.Value *
                    pow(10, conn->ctx->evse_v2g_data.evse_nominal_voltage.Multiplier); /* nominal voltage */

                /* Calculate pmax based on max current, nominal voltage and phase count (which the car has selected
                 * above) */
                int64_t pmax =
                    max_current * nom_voltage *
                    ((req->RequestedEnergyTransferMode == iso2_EnergyTransferModeType_AC_single_phase_core) ? 1 : 3);
                populate_physical_value(&conn->ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0]
                                             .PMaxSchedule.PMaxScheduleEntry.array[0]
                                             .PMax,
                                        pmax, iso2_unitSymbolType_W);
            } else {
                conn->ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0]
                    .PMaxSchedule.PMaxScheduleEntry.array[0]
                    .PMax = conn->ctx->evse_v2g_data.evse_maximum_power_limit;
            }
            conn->ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0]
                .PMaxSchedule.PMaxScheduleEntry.array[0]
                .RelativeTimeInterval.start = 0;
            conn->ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0]
                .PMaxSchedule.PMaxScheduleEntry.array[0]
                .RelativeTimeInterval.duration_isUsed = 1;
            conn->ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0]
                .PMaxSchedule.PMaxScheduleEntry.array[0]
                .RelativeTimeInterval.duration = SA_SCHEDULE_DURATION;
            conn->ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0]
                .PMaxSchedule.PMaxScheduleEntry.arrayLen = 1;
            conn->ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.arrayLen = 1;
        }

        res->SAScheduleList = conn->ctx->evse_v2g_data.evse_sa_schedule_list;
        res->SAScheduleList_isUsed = (unsigned int)1; //  The SECC shall only omit the parameter 'SAScheduleList' in
                                                      //  case EVSEProcessing is set to 'Ongoing'.

        if ((req->MaxEntriesSAScheduleTuple_isUsed == (unsigned int)1) &&
            (req->MaxEntriesSAScheduleTuple < res->SAScheduleList.SAScheduleTuple.arrayLen)) {
            dlog(DLOG_LEVEL_WARNING, "EV's max. SA-schedule-tuple entries exceeded");
        }
    } else {
        res->EVSEProcessing = iso2_EVSEProcessingType_Ongoing;
        res->SAScheduleList_isUsed = (unsigned int)0;
    }

    /* Checking SAScheduleTupleID */
    for (uint8_t idx = 0; idx < res->SAScheduleList.SAScheduleTuple.arrayLen; idx++) {
        if (res->SAScheduleList.SAScheduleTuple.array[idx].SAScheduleTupleID == (uint8_t)0) {
            dlog(DLOG_LEVEL_WARNING, "Selected SAScheduleTupleID is not ISO15118 conform. The SECC shall use the "
                                     "values 1 to 255"); // [V2G2-773]  The SECC shall use the values 1 to 255 for the
                                                         // parameter SAScheduleTupleID.
        }
    }

    res->SASchedules_isUsed = 0;

    // TODO: For DC charging wait for CP state B , before transmitting of the response ([V2G2-921], [V2G2-922]). CP
    // state is checked by other module

    /* reset our internal reminder that renegotiation was requested */
    conn->ctx->session.renegotiation_required = false; // Reset renegotiation flag

    if (conn->ctx->is_dc_charger == false) {
        /* Configure AC stucture elements */
        res->AC_EVSEChargeParameter_isUsed = 1;
        res->DC_EVSEChargeParameter_isUsed = 0;

        populate_ac_evse_status(conn->ctx, &res->AC_EVSEChargeParameter.AC_EVSEStatus);

        /* Max current */
        float max_current = conn->ctx->basic_config.evse_ac_current_limit;
        populate_physical_value_float(&res->AC_EVSEChargeParameter.EVSEMaxCurrent, max_current, 1,
                                      iso2_unitSymbolType_A);

        /* Nominal voltage */
        res->AC_EVSEChargeParameter.EVSENominalVoltage = conn->ctx->evse_v2g_data.evse_nominal_voltage;
        int64_t nom_voltage = conn->ctx->evse_v2g_data.evse_nominal_voltage.Value *
                              pow(10, conn->ctx->evse_v2g_data.evse_nominal_voltage.Multiplier);

        /* Calculate pmax based on max current, nominal voltage and phase count (which the car has selected above) */
        int64_t pmax = max_current * nom_voltage *
                       ((iso2_EnergyTransferModeType_AC_single_phase_core == req->RequestedEnergyTransferMode) ? 1 : 3);

        /* Check the SASchedule */
        if (res->SAScheduleList_isUsed == (unsigned int)1) {
            for (uint8_t idx = 0; idx < res->SAScheduleList.SAScheduleTuple.arrayLen; idx++) {
                for (uint8_t idx2 = 0;
                     idx2 < res->SAScheduleList.SAScheduleTuple.array[idx].PMaxSchedule.PMaxScheduleEntry.arrayLen;
                     idx2++)
                    if ((res->SAScheduleList.SAScheduleTuple.array[idx]
                             .PMaxSchedule.PMaxScheduleEntry.array[idx2]
                             .PMax.Value *
                         pow(10, res->SAScheduleList.SAScheduleTuple.array[idx]
                                     .PMaxSchedule.PMaxScheduleEntry.array[idx2]
                                     .PMax.Multiplier)) > pmax) {
                        dlog(DLOG_LEVEL_WARNING,
                             "Provided SA-schedule-list doesn't match with the physical value limits");
                    }
            }
        }

        if (req->DC_EVChargeParameter_isUsed == (unsigned int)1) {
            res->ResponseCode = iso2_responseCodeType_FAILED_WrongChargeParameter; // [V2G2-477]
        }
    } else {

        if (conn->ctx->evse_v2g_data.sae_bidi_data.enabled_sae_v2h == true) {
            static bool first_req = true;

            if (first_req == true) {
                res->EVSEProcessing = iso2_EVSEProcessingType_Ongoing;
                first_req = false;
            } else {
                // Check if second req message contains neg values
                // Check if bulk soc is set
                if (req->DC_EVChargeParameter.BulkSOC_isUsed == 1 &&
                    req->DC_EVChargeParameter.EVMaximumCurrentLimit.Value < 0 &&
                    req->DC_EVChargeParameter.EVMaximumPowerLimit_isUsed == 1 &&
                    req->DC_EVChargeParameter.EVMaximumPowerLimit.Value < 0) {
                    // Save bulk soc for minimal soc to stop
                    conn->ctx->evse_v2g_data.sae_bidi_data.sae_v2h_minimal_soc = req->DC_EVChargeParameter.BulkSOC;
                } else {
                    res->ResponseCode = iso2_responseCodeType::iso2_responseCodeType_FAILED_WrongEnergyTransferMode;
                }
                res->EVSEProcessing = iso2_EVSEProcessingType_Finished;
                // reset first_req
                first_req = true;
            }
        }

        /* Configure DC stucture elements */
        res->DC_EVSEChargeParameter_isUsed = 1;
        res->AC_EVSEChargeParameter_isUsed = 0;

        res->DC_EVSEChargeParameter.DC_EVSEStatus.EVSEIsolationStatus =
            (iso2_isolationLevelType)conn->ctx->evse_v2g_data.evse_isolation_status;
        res->DC_EVSEChargeParameter.DC_EVSEStatus.EVSEIsolationStatus_isUsed =
            conn->ctx->evse_v2g_data.evse_isolation_status_is_used;
        res->DC_EVSEChargeParameter.DC_EVSEStatus.EVSENotification =
            (iso2_EVSENotificationType)conn->ctx->evse_v2g_data.evse_notification;
        res->DC_EVSEChargeParameter.DC_EVSEStatus.EVSEStatusCode =
            get_emergency_status_code(conn->ctx, PHASE_PARAMETER);
        res->DC_EVSEChargeParameter.DC_EVSEStatus.NotificationMaxDelay =
            (uint16_t)conn->ctx->evse_v2g_data.notification_max_delay;

        res->DC_EVSEChargeParameter.EVSECurrentRegulationTolerance =
            conn->ctx->evse_v2g_data.evse_current_regulation_tolerance;
        res->DC_EVSEChargeParameter.EVSECurrentRegulationTolerance_isUsed =
            conn->ctx->evse_v2g_data.evse_current_regulation_tolerance_is_used;
        res->DC_EVSEChargeParameter.EVSEEnergyToBeDelivered = conn->ctx->evse_v2g_data.evse_energy_to_be_delivered;
        res->DC_EVSEChargeParameter.EVSEEnergyToBeDelivered_isUsed =
            conn->ctx->evse_v2g_data.evse_energy_to_be_delivered_is_used;
        res->DC_EVSEChargeParameter.EVSEMaximumCurrentLimit = conn->ctx->evse_v2g_data.evse_maximum_current_limit;
        res->DC_EVSEChargeParameter.EVSEMaximumPowerLimit = conn->ctx->evse_v2g_data.evse_maximum_power_limit;
        res->DC_EVSEChargeParameter.EVSEMaximumVoltageLimit = conn->ctx->evse_v2g_data.evse_maximum_voltage_limit;
        res->DC_EVSEChargeParameter.EVSEMinimumCurrentLimit = conn->ctx->evse_v2g_data.evse_minimum_current_limit;
        res->DC_EVSEChargeParameter.EVSEMinimumVoltageLimit = conn->ctx->evse_v2g_data.evse_minimum_voltage_limit;
        res->DC_EVSEChargeParameter.EVSEPeakCurrentRipple = conn->ctx->evse_v2g_data.evse_peak_current_ripple;

        if ((unsigned int)1 == req->AC_EVChargeParameter_isUsed) {
            res->ResponseCode = iso2_responseCodeType_FAILED_WrongChargeParameter; // [V2G2-477]
        }
        if (req->DC_EVChargeParameter.EVMaximumCurrentLimit.Value < 0 ||
            req->DC_EVChargeParameter.EVMaximumPowerLimit.Value < 0 ||
            req->DC_EVChargeParameter.EVMaximumVoltageLimit.Value < 0) {
            res->ResponseCode = iso2_responseCodeType_FAILED_WrongChargeParameter; // [V2G2-477]
        }

        constexpr auto physical_value_to_float = [](const iso2_PhysicalValueType& pv) {
            return calc_physical_value(pv.Value, pv.Multiplier);
        };

        const auto ev_maximum_current_limit = physical_value_to_float(req->DC_EVChargeParameter.EVMaximumCurrentLimit);
        const auto ev_maximum_voltage_limit = physical_value_to_float(req->DC_EVChargeParameter.EVMaximumVoltageLimit);
        const auto evse_minimum_current_limit =
            physical_value_to_float(conn->ctx->evse_v2g_data.evse_minimum_current_limit);
        const auto evse_minimum_voltage_limit =
            physical_value_to_float(conn->ctx->evse_v2g_data.evse_minimum_voltage_limit);

        if (ev_maximum_current_limit < evse_minimum_current_limit ||
            ev_maximum_voltage_limit < evse_minimum_voltage_limit) {
            res->ResponseCode = iso2_responseCodeType_FAILED_WrongChargeParameter;
        }
    }

    /* Check the current response code and check if no external error has occurred */
    next_event = (v2g_event)iso_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    if (conn->ctx->is_dc_charger == true) {
        conn->ctx->state = (iso2_EVSEProcessingType_Finished == res->EVSEProcessing)
                               ? (int)iso_dc_state_id::WAIT_FOR_CABLECHECK
                               : (int)iso_dc_state_id::WAIT_FOR_CHARGEPARAMETERDISCOVERY; // [V2G-582], [V2G-688]
    } else {
        conn->ctx->state = (iso2_EVSEProcessingType_Finished == res->EVSEProcessing)
                               ? (int)iso_ac_state_id::WAIT_FOR_POWERDELIVERY
                               : (int)iso_ac_state_id::WAIT_FOR_CHARGEPARAMETERDISCOVERY;
    }

    if (res->ResponseCode >= iso2_responseCodeType_FAILED) {
        res->DC_EVSEChargeParameter.EVSECurrentRegulationTolerance_isUsed = 0;
        res->DC_EVSEChargeParameter.EVSEEnergyToBeDelivered_isUsed = 0;
        res->DC_EVSEChargeParameter.DC_EVSEStatus.EVSEIsolationStatus_isUsed = 0;
        res->SAScheduleList_isUsed = 0;
    }

    return next_event;
}

/*!
 * \brief handle_iso_power_delivery This function handles the iso_power_delivery msg pair. It analyzes the request msg
 * and fills the response msg. The request and response msg based on the open V2G structures. This structures must be
 * provided within the \c conn structure.
 * \param conn holds the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_iso_power_delivery(struct v2g_connection* conn) {
    struct iso2_PowerDeliveryReqType* req = &conn->exi_in.iso2EXIDocument->V2G_Message.Body.PowerDeliveryReq;
    struct iso2_PowerDeliveryResType* res = &conn->exi_out.iso2EXIDocument->V2G_Message.Body.PowerDeliveryRes;
    struct timespec ts_abs_timeout;
    uint8_t sa_schedule_tuple_idx = 0;
    bool entry_found = false;
    enum v2g_event next_event = V2G_EVENT_NO_EVENT;

    /* At first, publish the received EV request message to the MQTT interface */
    publish_iso_power_delivery_req(conn->ctx, req);

    /* build up response */
    res->ResponseCode = iso2_responseCodeType_OK;

    switch (req->ChargeProgress) {
    case iso2_chargeProgressType_Start:
        conn->ctx->p_charger->publish_v2g_setup_finished(nullptr);

        if (conn->ctx->is_dc_charger == false) {
            // TODO: For AC charging wait for CP state C or D , before transmitting of the response. CP state is checked
            // by other module
            if (conn->ctx->contactor_is_closed == false) {
                // TODO: Signal closing contactor with MQTT if no timeout while waiting for state C or D
                conn->ctx->p_charger->publish_ac_close_contactor(nullptr);
                conn->ctx->session.is_charging = true;

                /* determine timeout for contactor */
                clock_gettime(CLOCK_MONOTONIC, &ts_abs_timeout);
                timespec_add_ms(&ts_abs_timeout, V2G_CONTACTOR_CLOSE_TIMEOUT);

                /* wait for contactor to really close or timeout */
                dlog(DLOG_LEVEL_INFO, "Waiting for contactor is closed");

                int rv = 0;
                while ((rv == 0) && (conn->ctx->contactor_is_closed == false) &&
                       (conn->ctx->intl_emergency_shutdown == false) && (conn->ctx->stop_hlc == false) &&
                       (conn->ctx->is_connection_terminated == false)) {
                    pthread_mutex_lock(&conn->ctx->mqtt_lock);
                    rv = pthread_cond_timedwait(&conn->ctx->mqtt_cond, &conn->ctx->mqtt_lock, &ts_abs_timeout);
                    if (rv == EINTR)
                        rv = 0; /* restart */
                    if (rv == ETIMEDOUT) {
                        dlog(DLOG_LEVEL_ERROR, "timeout while waiting for contactor to close, signaling error");
                        res->ResponseCode = iso2_responseCodeType_FAILED_ContactorError;
                    }
                    pthread_mutex_unlock(&conn->ctx->mqtt_lock);
                }
            }
        }
        break;

    case iso2_chargeProgressType_Stop:
        conn->ctx->session.is_charging = false;

        if (conn->ctx->is_dc_charger == false) {
            // TODO: For AC charging wait for CP state change from C/D to B , before transmitting of the response. CP
            // state is checked by other module
            conn->ctx->p_charger->publish_ac_open_contactor(nullptr);
        } else {
            conn->ctx->p_charger->publish_current_demand_finished(nullptr);
            conn->ctx->p_charger->publish_dc_open_contactor(nullptr);
        }
        break;

    case iso2_chargeProgressType_Renegotiate:
        conn->ctx->session.renegotiation_required = true;
        break;

    default:
        dlog(DLOG_LEVEL_ERROR, "Unknown ChargeProgress %d received, signaling error", req->ChargeProgress);
        res->ResponseCode = iso2_responseCodeType_FAILED;
    }

    if (conn->ctx->is_dc_charger == false) {
        res->AC_EVSEStatus_isUsed = 1;
        res->DC_EVSEStatus_isUsed = 0;
        populate_ac_evse_status(conn->ctx, &res->AC_EVSEStatus);
    } else {
        res->DC_EVSEStatus_isUsed = 1;
        res->AC_EVSEStatus_isUsed = 0;
        res->DC_EVSEStatus.EVSEIsolationStatus =
            (iso2_isolationLevelType)conn->ctx->evse_v2g_data.evse_isolation_status;
        res->DC_EVSEStatus.EVSEIsolationStatus_isUsed = conn->ctx->evse_v2g_data.evse_isolation_status_is_used;
        res->DC_EVSEStatus.EVSENotification =
            static_cast<iso2_EVSENotificationType>(conn->ctx->evse_v2g_data.evse_notification);
        res->DC_EVSEStatus.EVSEStatusCode = get_emergency_status_code(conn->ctx, PHASE_CHARGE);
        res->DC_EVSEStatus.NotificationMaxDelay = (uint16_t)conn->ctx->evse_v2g_data.notification_max_delay;

        res->ResponseCode = (req->ChargeProgress == iso2_chargeProgressType_Start) &&
                                    (res->DC_EVSEStatus.EVSEStatusCode != iso2_DC_EVSEStatusCodeType_EVSE_Ready)
                                ? iso2_responseCodeType_FAILED_PowerDeliveryNotApplied
                                : res->ResponseCode; // [V2G2-480]
    }

    res->EVSEStatus_isUsed = 0;

    /* Check the selected SAScheduleTupleID */
    for (sa_schedule_tuple_idx = 0;
         sa_schedule_tuple_idx < conn->ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.arrayLen;
         sa_schedule_tuple_idx++) {
        if (conn->ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[sa_schedule_tuple_idx]
                .SAScheduleTupleID == req->SAScheduleTupleID) {
            entry_found = true;
            conn->ctx->session.sa_schedule_tuple_id = req->SAScheduleTupleID;
            break;
        }
    }

    res->ResponseCode =
        (entry_found == false) ? iso2_responseCodeType_FAILED_TariffSelectionInvalid : res->ResponseCode; // [V2G2-479]

    /* Check EV charging profile values [V2G2-478] */
    check_iso2_charging_profile_values(req, res, conn, sa_schedule_tuple_idx);

    const auto last_v2g_msg = conn->ctx->last_v2g_msg;

    /* abort charging session if EV is ready to charge after current demand phase */
    if ((req->ChargeProgress == iso2_chargeProgressType_Start and
         (last_v2g_msg == V2G_CURRENT_DEMAND_MSG or last_v2g_msg == V2G_CHARGING_STATUS_MSG)) or
        (req->ChargeProgress == iso2_chargeProgressType_Renegotiate and
         (last_v2g_msg != V2G_CURRENT_DEMAND_MSG and last_v2g_msg != V2G_CHARGING_STATUS_MSG))) {
        res->ResponseCode = iso2_responseCodeType_FAILED; // (/*[V2G2-812]*/
    }

    /* Check the current response code and check if no external error has occurred */
    next_event = (v2g_event)iso_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    if ((req->ChargeProgress == iso2_chargeProgressType_Renegotiate) &&
        ((conn->ctx->last_v2g_msg == V2G_CURRENT_DEMAND_MSG) || (conn->ctx->last_v2g_msg == V2G_CHARGING_STATUS_MSG))) {
        conn->ctx->state = (int)iso_dc_state_id::WAIT_FOR_CHARGEPARAMETERDISCOVERY; // [V2G-813]

        if (conn->ctx->is_dc_charger == false) {
            // Reset AC relevant parameter to start the renegotation process
            conn->ctx->evse_v2g_data.evse_notification =
                (conn->ctx->evse_v2g_data.evse_notification == iso2_EVSENotificationType_ReNegotiation)
                    ? iso2_EVSENotificationType_None
                    : conn->ctx->evse_v2g_data.evse_notification;
        } else {
            // Reset DC relevant parameter to start the renegotation process
            conn->ctx->evse_v2g_data.evse_processing[PHASE_ISOLATION] = iso2_EVSEProcessingType_Ongoing;
            conn->ctx->evse_v2g_data.evse_notification =
                (iso2_EVSENotificationType_ReNegotiation == conn->ctx->evse_v2g_data.evse_notification)
                    ? iso2_EVSENotificationType_None
                    : conn->ctx->evse_v2g_data.evse_notification;
            conn->ctx->evse_v2g_data.evse_isolation_status = iso2_isolationLevelType_Invalid;
        }
    } else if ((req->ChargeProgress == iso2_chargeProgressType_Start) &&
               (conn->ctx->last_v2g_msg != V2G_CURRENT_DEMAND_MSG) &&
               (conn->ctx->last_v2g_msg != V2G_CHARGING_STATUS_MSG)) {
        conn->ctx->state = (conn->ctx->is_dc_charger == true)
                               ? (int)iso_dc_state_id::WAIT_FOR_CURRENTDEMAND
                               : (int)iso_ac_state_id::WAIT_FOR_CHARGINGSTATUS; // [V2G-590], [V2G2-576]
    } else {
        conn->ctx->state = (conn->ctx->is_dc_charger == true)
                               ? (int)iso_dc_state_id::WAIT_FOR_WELDINGDETECTION_SESSIONSTOP
                               : (int)iso_ac_state_id::WAIT_FOR_SESSIONSTOP; // [V2G-601], [V2G2-568]
    }

    if (res->ResponseCode >= iso2_responseCodeType_FAILED) {
        res->DC_EVSEStatus.EVSEIsolationStatus_isUsed = 0;
    }

    return next_event;
}

/*!
 * \brief handle_iso_charging_status This function handles the iso_charging_status msg pair. It analyzes the request msg
 * and fills the response msg. The request and response msg based on the open V2G structures. This structures must be
 * provided within the \c conn structure.
 * \param conn holds the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_iso_charging_status(struct v2g_connection* conn) {
    struct iso2_ChargingStatusResType* res = &conn->exi_out.iso2EXIDocument->V2G_Message.Body.ChargingStatusRes;
    enum v2g_event next_event = V2G_EVENT_NO_EVENT;
    /* build up response */
    res->ResponseCode = iso2_responseCodeType_OK;

    res->ReceiptRequired = false; // [V2G2-691] ReceiptRequired shall be false in case of EIM
    if (conn->ctx->session.iso_selected_payment_option == iso2_paymentOptionType_Contract) {
        res->ReceiptRequired = conn->ctx->evse_v2g_data.receipt_required;
    }
    res->ReceiptRequired_isUsed = true; // [V2G2-691] ChargingStatusRes shall always include ReceiptRequired

    if (conn->ctx->meter_info.meter_info_is_used == true) {
        res->MeterInfo.MeterID.charactersLen = conn->ctx->meter_info.meter_id.bytesLen;
        memcpy(res->MeterInfo.MeterID.characters, conn->ctx->meter_info.meter_id.bytes, iso2_MeterID_CHARACTER_SIZE);
        res->MeterInfo.MeterReading = conn->ctx->meter_info.meter_reading;
        res->MeterInfo.MeterReading_isUsed = 1;
        res->MeterInfo_isUsed = 1;
        // Reset the signal for the next time handle_set_MeterInfo is signaled
        conn->ctx->meter_info.meter_info_is_used = false;
    } else {
        res->MeterInfo_isUsed = 0;
    }

    res->EVSEMaxCurrent_isUsed = (conn->ctx->session.iso_selected_payment_option == iso2_paymentOptionType_Contract)
                                     ? (unsigned int)0
                                     : (unsigned int)1; // This element is not included in the message if any AC PnC
                                                        // Message Set has been selected.

    if ((unsigned int)1 == res->EVSEMaxCurrent_isUsed) {
        populate_physical_value_float(&res->EVSEMaxCurrent, conn->ctx->basic_config.evse_ac_current_limit, 1,
                                      iso2_unitSymbolType_A);
    }

    conn->exi_out.iso2EXIDocument->V2G_Message.Body.ChargingStatusRes_isUsed = 1;

    /* the following field can also be set in error path */
    res->EVSEID.charactersLen = conn->ctx->evse_v2g_data.evse_id.bytesLen;
    memcpy(res->EVSEID.characters, conn->ctx->evse_v2g_data.evse_id.bytes, conn->ctx->evse_v2g_data.evse_id.bytesLen);

    /* in error path the session might not be available */
    res->SAScheduleTupleID = conn->ctx->session.sa_schedule_tuple_id;
    populate_ac_evse_status(conn->ctx, &res->AC_EVSEStatus);

    /* Check the current response code and check if no external error has occurred */
    next_event = (enum v2g_event)iso_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = (((int)1 == res->ReceiptRequired))
                           ? (int)iso_ac_state_id::WAIT_FOR_METERINGRECEIPT
                           : (int)iso_ac_state_id::WAIT_FOR_CHARGINGSTATUS_POWERDELIVERY; // [V2G2-577], [V2G2-575]

    return next_event;
}

/*!
 * \brief handle_iso_metering_receipt This function handles the iso_metering_receipt msg pair. It analyzes the request
 * msg and fills the response msg. The request and response msg based on the open V2G structures. This structures must
 * be provided within the \c conn structure. \param conn holds the structure with the V2G msg pair. \return Returns the
 * next V2G-event.
 */
static enum v2g_event handle_iso_metering_receipt(struct v2g_connection* conn) {
    struct iso2_MeteringReceiptReqType* req = &conn->exi_in.iso2EXIDocument->V2G_Message.Body.MeteringReceiptReq;
    struct iso2_MeteringReceiptResType* res = &conn->exi_out.iso2EXIDocument->V2G_Message.Body.MeteringReceiptRes;
    enum v2g_event next_event = V2G_EVENT_NO_EVENT;

    /* At first, publish the received ev request message to the MQTTinterface */
    publish_iso_metering_receipt_req(req);

    dlog(DLOG_LEVEL_TRACE, "EVSE side: meteringReceipt called");
    dlog(DLOG_LEVEL_TRACE, "\tReceived data:");

    dlog(DLOG_LEVEL_TRACE, "\t\t ID=%c%c%c", req->Id.characters[0], req->Id.characters[1], req->Id.characters[2]);
    dlog(DLOG_LEVEL_TRACE, "\t\t SAScheduleTupleID=%d", req->SAScheduleTupleID);
    dlog(DLOG_LEVEL_TRACE, "\t\t SessionID=%d", req->SessionID.bytes[1]);
    dlog(DLOG_LEVEL_TRACE, "\t\t MeterInfo.MeterStatus=%d", req->MeterInfo.MeterStatus);
    dlog(DLOG_LEVEL_TRACE, "\t\t MeterInfo.MeterID=%d", req->MeterInfo.MeterID.characters[0]);
    dlog(DLOG_LEVEL_TRACE, "\t\t MeterInfo.isused.MeterReading=%d", req->MeterInfo.MeterReading_isUsed);
    dlog(DLOG_LEVEL_TRACE, "\t\t MeterReading.Value=%lu", (long unsigned int)req->MeterInfo.MeterReading);
    dlog(DLOG_LEVEL_TRACE, "\t\t MeterInfo.TMeter=%li", (long int)req->MeterInfo.TMeter);

    res->ResponseCode = iso2_responseCodeType_OK;

    if (conn->ctx->is_dc_charger == false) {
        /* for AC charging we respond with AC_EVSEStatus */
        res->EVSEStatus_isUsed = 0;
        res->AC_EVSEStatus_isUsed = 1;
        res->DC_EVSEStatus_isUsed = 0;
        populate_ac_evse_status(conn->ctx, &res->AC_EVSEStatus);
    } else {
        res->DC_EVSEStatus_isUsed = 1;
        res->AC_EVSEStatus_isUsed = 0;
    }

    /* Check the current response code and check if no external error has occurred */
    next_event = (v2g_event)iso_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = (conn->ctx->is_dc_charger == false)
                           ? (int)iso_ac_state_id::WAIT_FOR_CHARGINGSTATUS_POWERDELIVERY
                           : (int)iso_dc_state_id::WAIT_FOR_CURRENTDEMAND_POWERDELIVERY; // [V2G2-580]/[V2G-797]

    return next_event;
}

/*!
 * \brief handle_iso_certificate_update This function handles the iso_certificate_update msg pair. It analyzes the
 * request msg and fills the response msg. The request and response msg based on the open V2G structures. This
 * structures must be provided within the \c conn structure.
 * \param conn holds the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_iso_certificate_update(struct v2g_connection* conn) {
    // TODO: implement CertificateUpdate handling
    return V2G_EVENT_NO_EVENT;
}

/*!
 * \brief handle_iso_certificate_installation This function handles the iso_certificate_installation msg pair. It
 * analyzes the request msg and fills the response msg. The request and response msg based on the open V2G structures.
 * This structures must be provided within the \c conn structure.
 * \param conn holds the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_iso_certificate_installation(struct v2g_connection* conn) {
    struct iso2_CertificateInstallationResType* res =
        &conn->exi_out.iso2EXIDocument->V2G_Message.Body.CertificateInstallationRes;
    enum v2g_event nextEvent = V2G_EVENT_SEND_AND_TERMINATE;
    struct timespec ts_abs_timeout;
    int rv = 0;
    /* At first, publish the received EV request message to the customer MQTT interface */
    if (publish_iso_certificate_installation_exi_req(conn->ctx, conn->buffer + V2GTP_HEADER_LENGTH,
                                                     conn->stream.data_size - V2GTP_HEADER_LENGTH) == false) {
        dlog(DLOG_LEVEL_ERROR, "Failed to send CertificateInstallationExiReq");
        goto exit;
    }
    /* Waiting for the CertInstallationExiRes msg */
    clock_gettime(CLOCK_MONOTONIC, &ts_abs_timeout);
    timespec_add_ms(&ts_abs_timeout, V2G_SECC_MSG_CERTINSTALL_TIME);
    dlog(DLOG_LEVEL_INFO, "Waiting for the CertInstallationExiRes msg");
    while ((rv == 0) && (conn->ctx->evse_v2g_data.cert_install_res_b64_buffer.empty() == true) &&
           (conn->ctx->intl_emergency_shutdown == false) && (conn->ctx->stop_hlc == false) &&
           (conn->ctx->is_connection_terminated == false)) { // [V2G2-917]
        pthread_mutex_lock(&conn->ctx->mqtt_lock);
        rv = pthread_cond_timedwait(&conn->ctx->mqtt_cond, &conn->ctx->mqtt_lock, &ts_abs_timeout);
        if (rv == EINTR)
            rv = 0; /* restart */
        if (rv == ETIMEDOUT) {
            dlog(DLOG_LEVEL_ERROR, "CertificateInstallationRes timeout occurred");
            conn->ctx->intl_emergency_shutdown = true; // [V2G2-918] Initiating emergency shutdown, response code faild
                                                       // will be set in iso_validate_response_code() function
        }
        pthread_mutex_unlock(&conn->ctx->mqtt_lock);
    }

    if ((conn->ctx->evse_v2g_data.cert_install_res_b64_buffer.empty() == false) &&
        (conn->ctx->evse_v2g_data.cert_install_status == true)) {
        const auto data = openssl::base64_decode(conn->ctx->evse_v2g_data.cert_install_res_b64_buffer.data(),
                                                 conn->ctx->evse_v2g_data.cert_install_res_b64_buffer.size());
        if (data.empty() || (data.size() > DEFAULT_BUFFER_SIZE)) {
            dlog(DLOG_LEVEL_ERROR, "Failed to decode base64 stream");
            goto exit;
        } else {
            std::memcpy(conn->buffer + V2GTP_HEADER_LENGTH, data.data(), data.size());
            conn->stream.byte_pos = data.size();
        }
        nextEvent = V2G_EVENT_SEND_RECV_EXI_MSG;
        res->ResponseCode =
            iso2_responseCodeType_OK; // Is irrelevant but must be valid to serve the internal validation
        conn->stream.byte_pos +=
            V2GTP_HEADER_LENGTH; // byte_pos had only the payload, so increase it to be header + payload
    } else {
        res->ResponseCode = iso2_responseCodeType_FAILED;
    }

exit:
    if (V2G_EVENT_SEND_RECV_EXI_MSG != nextEvent) {
        /* Check the current response code and check if no external error has occurred */
        nextEvent = (enum v2g_event)iso_validate_response_code(&res->ResponseCode, conn);
    } else {
        /* Reset v2g-msg If there, in case of an error */
        init_iso2_CertificateInstallationResType(res);
    }

    /* Set next expected req msg */
    conn->ctx->state = (int)iso_dc_state_id::WAIT_FOR_PAYMENTDETAILS; // [V2G-554]

    return nextEvent;
}

/*!
 * \brief handle_iso_cable_check This function handles the iso_cable_check msg pair. It analyzes the request msg and
 * fills the response msg. The request and response msg based on the open V2G structures. This structures must be
 * provided within the \c conn structure.
 * \param conn holds the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_iso_cable_check(struct v2g_connection* conn) {
    struct iso2_CableCheckReqType* req = &conn->exi_in.iso2EXIDocument->V2G_Message.Body.CableCheckReq;
    struct iso2_CableCheckResType* res = &conn->exi_out.iso2EXIDocument->V2G_Message.Body.CableCheckRes;
    enum v2g_event next_event = V2G_EVENT_NO_EVENT;

    /* At first, publish the received EV request message to the MQTT interface */
    publish_DcEvStatus(conn->ctx, req->DC_EVStatus);

    // TODO: For DC charging wait for CP state C or D , before transmitting of the response ([V2G2-917], [V2G2-918]). CP
    // state is checked by other module

    /* Fill the CableCheckRes */
    res->ResponseCode = iso2_responseCodeType_OK;
    res->DC_EVSEStatus.EVSEIsolationStatus = (iso2_isolationLevelType)conn->ctx->evse_v2g_data.evse_isolation_status;
    res->DC_EVSEStatus.EVSEIsolationStatus_isUsed = conn->ctx->evse_v2g_data.evse_isolation_status_is_used;
    res->DC_EVSEStatus.EVSENotification =
        static_cast<iso2_EVSENotificationType>(conn->ctx->evse_v2g_data.evse_notification);
    res->DC_EVSEStatus.NotificationMaxDelay = (uint16_t)conn->ctx->evse_v2g_data.notification_max_delay;
    res->EVSEProcessing =
        static_cast<iso2_EVSEProcessingType>(conn->ctx->evse_v2g_data.evse_processing[PHASE_ISOLATION]);

    if (conn->ctx->intl_emergency_shutdown == false && res->EVSEProcessing == iso2_EVSEProcessingType_Finished) {
        res->DC_EVSEStatus.EVSEStatusCode = iso2_DC_EVSEStatusCodeType_EVSE_Ready;
    } else {
        res->DC_EVSEStatus.EVSEStatusCode = get_emergency_status_code(conn->ctx, PHASE_ISOLATION);
    }

    /* Check the current response code and check if no external error has occurred */
    next_event = (v2g_event)iso_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = (res->EVSEProcessing == iso2_EVSEProcessingType_Finished)
                           ? (int)iso_dc_state_id::WAIT_FOR_PRECHARGE
                           : (int)iso_dc_state_id::WAIT_FOR_CABLECHECK; // [V2G-584], [V2G-621]

    if (res->ResponseCode >= iso2_responseCodeType_FAILED) {
        res->DC_EVSEStatus.EVSEIsolationStatus_isUsed = 0;
    }

    return next_event;
}

/*!
 * \brief handle_iso_pre_charge This function handles the iso_pre_charge msg pair. It analyzes the request msg and fills
 * the response msg. The request and response msg based on the open V2G structures. This structures must be provided
 * within the \c conn structure.
 * \param conn holds the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_iso_pre_charge(struct v2g_connection* conn) {
    struct iso2_PreChargeReqType* req = &conn->exi_in.iso2EXIDocument->V2G_Message.Body.PreChargeReq;
    struct iso2_PreChargeResType* res = &conn->exi_out.iso2EXIDocument->V2G_Message.Body.PreChargeRes;
    enum v2g_event next_event = V2G_EVENT_NO_EVENT;

    /* At first, publish the received EV request message to the MQTT interface */
    publish_iso_pre_charge_req(conn->ctx, req);

    /* Fill the PreChargeRes*/
    res->DC_EVSEStatus.EVSEIsolationStatus = (iso2_isolationLevelType)conn->ctx->evse_v2g_data.evse_isolation_status;
    res->DC_EVSEStatus.EVSEIsolationStatus_isUsed = conn->ctx->evse_v2g_data.evse_isolation_status_is_used;
    res->DC_EVSEStatus.EVSENotification =
        static_cast<iso2_EVSENotificationType>(conn->ctx->evse_v2g_data.evse_notification);
    res->DC_EVSEStatus.EVSEStatusCode = get_emergency_status_code(conn->ctx, PHASE_PRECHARGE);
    res->DC_EVSEStatus.NotificationMaxDelay = (uint16_t)conn->ctx->evse_v2g_data.notification_max_delay;
    res->EVSEPresentVoltage = (iso2_PhysicalValueType)conn->ctx->evse_v2g_data.evse_present_voltage;
    res->ResponseCode = iso2_responseCodeType_OK;

    /* Check the current response code and check if no external error has occurred */
    next_event = (v2g_event)iso_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = (int)iso_dc_state_id::WAIT_FOR_PRECHARGE_POWERDELIVERY; // [V2G-587]

    if (res->ResponseCode >= iso2_responseCodeType_FAILED) {
        res->DC_EVSEStatus.EVSEIsolationStatus_isUsed = 0;
    }

    return next_event;
}

/*!
 * \brief handle_iso_current_demand This function handles the iso_current_demand msg pair. It analyzes the request msg
 * and fills the response msg. The request and response msg based on the open V2G structures. This structures must be
 * provided within the \c conn structure.
 * \param conn holds the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_iso_current_demand(struct v2g_connection* conn) {
    struct iso2_CurrentDemandReqType* req = &conn->exi_in.iso2EXIDocument->V2G_Message.Body.CurrentDemandReq;
    struct iso2_CurrentDemandResType* res = &conn->exi_out.iso2EXIDocument->V2G_Message.Body.CurrentDemandRes;
    enum v2g_event next_event = V2G_EVENT_NO_EVENT;

    /* At first, publish the received EV request message to the MQTT interface */
    publish_iso_current_demand_req(conn->ctx, req);

    res->DC_EVSEStatus.EVSEIsolationStatus = (iso2_isolationLevelType)conn->ctx->evse_v2g_data.evse_isolation_status;
    res->DC_EVSEStatus.EVSEIsolationStatus_isUsed = conn->ctx->evse_v2g_data.evse_isolation_status_is_used;
    res->DC_EVSEStatus.EVSENotification =
        static_cast<iso2_EVSENotificationType>(conn->ctx->evse_v2g_data.evse_notification);
    res->DC_EVSEStatus.EVSEStatusCode = get_emergency_status_code(conn->ctx, PHASE_CHARGE);
    res->DC_EVSEStatus.NotificationMaxDelay = (uint16_t)conn->ctx->evse_v2g_data.notification_max_delay;
    if ((conn->ctx->evse_v2g_data.evse_maximum_current_limit_is_used == 1) &&
        (calc_physical_value(req->EVTargetCurrent.Value, req->EVTargetCurrent.Multiplier) >=
         calc_physical_value(conn->ctx->evse_v2g_data.evse_maximum_current_limit.Value,
                             conn->ctx->evse_v2g_data.evse_maximum_current_limit.Multiplier))) {
        conn->ctx->evse_v2g_data.evse_current_limit_achieved = (int)1;
    } else {
        conn->ctx->evse_v2g_data.evse_current_limit_achieved = (int)0;
    }
    res->EVSECurrentLimitAchieved = conn->ctx->evse_v2g_data.evse_current_limit_achieved;
    memcpy(res->EVSEID.characters, conn->ctx->evse_v2g_data.evse_id.bytes, conn->ctx->evse_v2g_data.evse_id.bytesLen);
    res->EVSEID.charactersLen = conn->ctx->evse_v2g_data.evse_id.bytesLen;
    res->EVSEMaximumCurrentLimit = conn->ctx->evse_v2g_data.evse_maximum_current_limit;
    res->EVSEMaximumCurrentLimit_isUsed = conn->ctx->evse_v2g_data.evse_maximum_current_limit_is_used;
    res->EVSEMaximumPowerLimit = conn->ctx->evse_v2g_data.evse_maximum_power_limit;
    res->EVSEMaximumPowerLimit_isUsed = conn->ctx->evse_v2g_data.evse_maximum_power_limit_is_used;
    res->EVSEMaximumVoltageLimit = conn->ctx->evse_v2g_data.evse_maximum_voltage_limit;
    res->EVSEMaximumVoltageLimit_isUsed = conn->ctx->evse_v2g_data.evse_maximum_voltage_limit_is_used;
    double EVTargetPower = calc_physical_value(req->EVTargetCurrent.Value, req->EVTargetCurrent.Multiplier) *
                           calc_physical_value(req->EVTargetVoltage.Value, req->EVTargetVoltage.Multiplier);
    if ((conn->ctx->evse_v2g_data.evse_maximum_power_limit_is_used == 1) &&
        (EVTargetPower >= calc_physical_value(conn->ctx->evse_v2g_data.evse_maximum_power_limit.Value,
                                              conn->ctx->evse_v2g_data.evse_maximum_power_limit.Multiplier))) {
        conn->ctx->evse_v2g_data.evse_power_limit_achieved = (int)1;
    } else {
        conn->ctx->evse_v2g_data.evse_power_limit_achieved = (int)0;
    }
    res->EVSEPowerLimitAchieved = conn->ctx->evse_v2g_data.evse_power_limit_achieved;
    res->EVSEPresentCurrent = conn->ctx->evse_v2g_data.evse_present_current;
    res->EVSEPresentVoltage = conn->ctx->evse_v2g_data.evse_present_voltage;
    if ((conn->ctx->evse_v2g_data.evse_maximum_voltage_limit_is_used == 1) &&
        (calc_physical_value(req->EVTargetVoltage.Value, req->EVTargetVoltage.Multiplier) >=
         calc_physical_value(conn->ctx->evse_v2g_data.evse_maximum_voltage_limit.Value,
                             conn->ctx->evse_v2g_data.evse_maximum_voltage_limit.Multiplier))) {
        conn->ctx->evse_v2g_data.evse_voltage_limit_achieved = (int)1;
    } else {
        conn->ctx->evse_v2g_data.evse_voltage_limit_achieved = (int)0;
    }
    res->EVSEVoltageLimitAchieved = conn->ctx->evse_v2g_data.evse_voltage_limit_achieved;
    if (conn->ctx->meter_info.meter_info_is_used == true) {
        res->MeterInfo.MeterID.charactersLen = conn->ctx->meter_info.meter_id.bytesLen;
        memcpy(res->MeterInfo.MeterID.characters, conn->ctx->meter_info.meter_id.bytes, iso2_MeterID_CHARACTER_SIZE);
        res->MeterInfo.MeterReading = conn->ctx->meter_info.meter_reading;
        res->MeterInfo.MeterReading_isUsed = 1;
        res->MeterInfo_isUsed = 1;
        // Reset the signal for the next time handle_set_MeterInfo is signaled
        conn->ctx->meter_info.meter_info_is_used = false;
    } else {
        res->MeterInfo_isUsed = 0;
    }
    res->ReceiptRequired = conn->ctx->evse_v2g_data.receipt_required; // TODO: PNC only
    res->ReceiptRequired_isUsed = (conn->ctx->session.iso_selected_payment_option == iso2_paymentOptionType_Contract)
                                      ? (unsigned int)conn->ctx->evse_v2g_data.receipt_required
                                      : (unsigned int)0;
    res->ResponseCode = iso2_responseCodeType_OK;
    res->SAScheduleTupleID = conn->ctx->session.sa_schedule_tuple_id;

    static uint8_t req_pos_value_count = 0;

    if (conn->ctx->evse_v2g_data.sae_bidi_data.enabled_sae_v2g == true) {

        // case: evse initiated -> Negative PresentCurrent, EvseMaxCurrentLimit, EvseMaxCurrentLimit
        if (conn->ctx->evse_v2g_data.sae_bidi_data.discharging == false &&
            conn->ctx->evse_v2g_data.evse_present_current.Value < 0 &&
            conn->ctx->evse_v2g_data.evse_maximum_current_limit_is_used == true &&
            conn->ctx->evse_v2g_data.evse_maximum_current_limit.Value < 0 &&
            conn->ctx->evse_v2g_data.evse_maximum_power_limit_is_used == true &&
            conn->ctx->evse_v2g_data.evse_maximum_power_limit.Value < 0) {
            if (req->EVTargetCurrent.Value > 0) {
                if (req_pos_value_count++ >= 1) {
                    dlog(DLOG_LEVEL_WARNING, "SAE V2G Bidi handshake was not recognized by the ev side. Instead of "
                                             "shutting down, it is better to wait for a correct response");
                    req_pos_value_count = 0;
                } else {
                    req_pos_value_count = 0;
                    conn->ctx->evse_v2g_data.sae_bidi_data.discharging = true;
                }
            }
        } else if (conn->ctx->evse_v2g_data.sae_bidi_data.discharging == true &&
                   conn->ctx->evse_v2g_data.evse_present_current.Value > 0 &&
                   conn->ctx->evse_v2g_data.evse_maximum_current_limit_is_used == true &&
                   conn->ctx->evse_v2g_data.evse_maximum_current_limit.Value > 0 &&
                   conn->ctx->evse_v2g_data.evse_maximum_power_limit_is_used == true &&
                   conn->ctx->evse_v2g_data.evse_maximum_power_limit.Value > 0) {
            if (req->EVTargetCurrent.Value < 0) {
                if (req_pos_value_count++ >= 1) {
                    dlog(DLOG_LEVEL_WARNING, "SAE V2G Bidi handshake was not recognized by the ev side. Instead of "
                                             "shutting down, it is better to wait for a correct response");
                    req_pos_value_count = 0;
                } else {
                    req_pos_value_count = 0;
                    conn->ctx->evse_v2g_data.sae_bidi_data.discharging = false;
                }
            }
        }

        // case: ev initiated -> Negative EvTargetCurrent, EVMaxCurrentLimit, EVMaxPowerLimit
        // Todo(SL): Is it necessary to notify the evse_manager that the ev want to give power/current?
        // Or is it obvious because of the negative target current request.

    } else if (conn->ctx->evse_v2g_data.sae_bidi_data.enabled_sae_v2h == true) {
        if (req->DC_EVStatus.EVRESSSOC <= conn->ctx->evse_v2g_data.sae_bidi_data.sae_v2h_minimal_soc) {
            res->DC_EVSEStatus.EVSEStatusCode = iso2_DC_EVSEStatusCodeType_EVSE_Shutdown;
        }
    }

    /* Check the current response code and check if no external error has occurred */
    next_event = (v2g_event)iso_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = ((res->ReceiptRequired_isUsed == (unsigned int)1) && (res->ReceiptRequired == (int)1))
                           ? (int)iso_dc_state_id::WAIT_FOR_METERINGRECEIPT
                           : (int)iso_dc_state_id::WAIT_FOR_CURRENTDEMAND_POWERDELIVERY; // [V2G-795], [V2G-593]

    if (res->ResponseCode >= iso2_responseCodeType_FAILED) {
        res->DC_EVSEStatus.EVSEIsolationStatus_isUsed = 0;
        res->MeterInfo_isUsed = 0;
        res->MeterInfo.MeterReading_isUsed = 0;
        res->EVSEMaximumVoltageLimit_isUsed = 0;
        res->EVSEMaximumCurrentLimit_isUsed = 0;
        res->EVSEMaximumPowerLimit_isUsed = 0;
    }

    return next_event;
}

/*!
 * \brief handle_iso_welding_detection This function handles the iso_welding_detection msg pair. It analyzes the request
 * msg and fills the response msg. The request and response msg based on the open V2G structures. This structures must
 * be provided within the \c conn structure.
 * \param conn holds the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_iso_welding_detection(struct v2g_connection* conn) {
    struct iso2_WeldingDetectionReqType* req = &conn->exi_in.iso2EXIDocument->V2G_Message.Body.WeldingDetectionReq;
    struct iso2_WeldingDetectionResType* res = &conn->exi_out.iso2EXIDocument->V2G_Message.Body.WeldingDetectionRes;
    enum v2g_event next_event = V2G_EVENT_NO_EVENT;

    /* At first, publish the received EV request message to the MQTT interface */
    publish_iso_welding_detection_req(conn->ctx, req);

    // TODO: Wait for CP state B, before transmitting of the response, or signal intl_emergency_shutdown in conn->ctx
    // ([V2G2-920], [V2G2-921]).

    res->DC_EVSEStatus.EVSEIsolationStatus = (iso2_isolationLevelType)conn->ctx->evse_v2g_data.evse_isolation_status;
    res->DC_EVSEStatus.EVSEIsolationStatus_isUsed = conn->ctx->evse_v2g_data.evse_isolation_status_is_used;
    res->DC_EVSEStatus.EVSENotification =
        static_cast<iso2_EVSENotificationType>(conn->ctx->evse_v2g_data.evse_notification);
    res->DC_EVSEStatus.EVSEStatusCode = get_emergency_status_code(conn->ctx, PHASE_WELDING);
    res->DC_EVSEStatus.NotificationMaxDelay = (uint16_t)conn->ctx->evse_v2g_data.notification_max_delay;
    res->EVSEPresentVoltage = conn->ctx->evse_v2g_data.evse_present_voltage;
    res->ResponseCode = iso2_responseCodeType_OK;

    /* Check the current response code and check if no external error has occurred */
    next_event = (v2g_event)iso_validate_response_code(&res->ResponseCode, conn);

    /* Set next expected req msg */
    conn->ctx->state = (int)iso_dc_state_id::WAIT_FOR_WELDINGDETECTION_SESSIONSTOP; // [V2G-597]

    if (res->ResponseCode >= iso2_responseCodeType_FAILED) {
        res->DC_EVSEStatus.EVSEIsolationStatus_isUsed = 0;
    }

    return next_event;
}

/*!
 * \brief handle_iso_session_stop This function handles the iso_session_stop msg pair. It analyses the request msg and
 * fills the response msg. The request and response msg based on the open V2G structures. This structures must be
 * provided within the \c conn structure.
 * \param conn holds the structure with the V2G msg pair.
 * \return Returns the next V2G-event.
 */
static enum v2g_event handle_iso_session_stop(struct v2g_connection* conn) {
    struct iso2_SessionStopReqType* req = &conn->exi_in.iso2EXIDocument->V2G_Message.Body.SessionStopReq;
    struct iso2_SessionStopResType* res = &conn->exi_out.iso2EXIDocument->V2G_Message.Body.SessionStopRes;

    res->ResponseCode = iso2_responseCodeType_OK;

    /* Check the current response code and check if no external error has occurred */
    iso_validate_response_code(&res->ResponseCode, conn);

    /* Set the next charging state */
    switch (req->ChargingSession) {
    case iso2_chargingSessionType_Terminate:
        conn->dlink_action = MQTT_DLINK_ACTION_TERMINATE;
        conn->ctx->hlc_pause_active = false;
        /* Set next expected req msg */
        conn->ctx->state = (int)iso_dc_state_id::WAIT_FOR_TERMINATED_SESSION;
        break;

    case iso2_chargingSessionType_Pause:
        /* Set next expected req msg */
        /* Check if the EV is allowed to request the sleep mode. TODO: Remove "true" if sleep mode is supported */
        if (((conn->ctx->last_v2g_msg != V2G_POWER_DELIVERY_MSG) &&
             (conn->ctx->last_v2g_msg != V2G_WELDING_DETECTION_MSG))) {
            conn->dlink_action = MQTT_DLINK_ACTION_TERMINATE;
            res->ResponseCode = iso2_responseCodeType_FAILED;
            conn->ctx->hlc_pause_active = false;
            conn->ctx->state = (int)iso_dc_state_id::WAIT_FOR_TERMINATED_SESSION;
        } else {
            /* Init sleep mode for the EV */
            conn->dlink_action = MQTT_DLINK_ACTION_PAUSE;
            conn->ctx->hlc_pause_active = true;
            conn->ctx->state = (int)iso_dc_state_id::WAIT_FOR_SESSIONSETUP;
        }
        break;

    default:
        /* Set next expected req msg */
        conn->dlink_action = MQTT_DLINK_ACTION_TERMINATE;
        conn->ctx->state = (int)iso_dc_state_id::WAIT_FOR_TERMINATED_SESSION;
    }

    return V2G_EVENT_SEND_AND_TERMINATE; // Charging must be terminated after sending the response message [V2G2-571]
}

enum v2g_event iso_handle_request(v2g_connection* conn) {
    struct iso2_exiDocument* exi_in = conn->exi_in.iso2EXIDocument;
    struct iso2_exiDocument* exi_out = conn->exi_out.iso2EXIDocument;
    enum v2g_event next_v2g_event = V2G_EVENT_TERMINATE_CONNECTION;

    /* extract session id */
    conn->ctx->ev_v2g_data.received_session_id = v2g_session_id_from_exi(true, exi_in);

    /* init V2G structure (document, header, body) */
    init_iso2_exiDocument(exi_out);
    init_iso2_MessageHeaderType(&exi_out->V2G_Message.Header);

    exi_out->V2G_Message.Header.SessionID.bytesLen = 8;
    init_iso2_BodyType(&exi_out->V2G_Message.Body);

    /* handle each message type individually;
     * we use a none-usual source code formatting here to optically group the individual
     * request a little bit
     */
    if (exi_in->V2G_Message.Body.CurrentDemandReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling CurrentDemandReq");
        if (conn->ctx->last_v2g_msg == V2G_POWER_DELIVERY_MSG) {
            conn->ctx->p_charger->publish_current_demand_started(nullptr);
            conn->ctx->session.is_charging = true;
        }
        conn->ctx->current_v2g_msg = V2G_CURRENT_DEMAND_MSG;
        exi_out->V2G_Message.Body.CurrentDemandRes_isUsed = 1u;
        init_iso2_CurrentDemandResType(&exi_out->V2G_Message.Body.CurrentDemandRes);
        next_v2g_event = handle_iso_current_demand(conn); //  [V2G2-592]
    } else if (exi_in->V2G_Message.Body.SessionSetupReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling SessionSetupReq");
        conn->ctx->current_v2g_msg = V2G_SESSION_SETUP_MSG;
        exi_out->V2G_Message.Body.SessionSetupRes_isUsed = 1u;
        init_iso2_SessionSetupResType(&exi_out->V2G_Message.Body.SessionSetupRes);
        next_v2g_event = handle_iso_session_setup(conn); // [V2G2-542]
    } else if (exi_in->V2G_Message.Body.ServiceDiscoveryReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling ServiceDiscoveryReq");
        conn->ctx->current_v2g_msg = V2G_SERVICE_DISCOVERY_MSG;
        exi_out->V2G_Message.Body.ServiceDiscoveryRes_isUsed = 1u;
        init_iso2_ServiceDiscoveryResType(&exi_out->V2G_Message.Body.ServiceDiscoveryRes);
        next_v2g_event = handle_iso_service_discovery(conn); // [V2G2-544]
    } else if (exi_in->V2G_Message.Body.ServiceDetailReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling ServiceDetailReq");
        conn->ctx->current_v2g_msg = V2G_SERVICE_DETAIL_MSG;
        exi_out->V2G_Message.Body.ServiceDetailRes_isUsed = 1u;
        init_iso2_ServiceDetailResType(&exi_out->V2G_Message.Body.ServiceDetailRes);
        next_v2g_event = handle_iso_service_detail(conn); // [V2G2-547]
    } else if (exi_in->V2G_Message.Body.PaymentServiceSelectionReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling PaymentServiceSelectionReq");
        conn->ctx->current_v2g_msg = V2G_PAYMENT_SERVICE_SELECTION_MSG;
        exi_out->V2G_Message.Body.PaymentServiceSelectionRes_isUsed = 1u;
        init_iso2_PaymentServiceSelectionResType(&exi_out->V2G_Message.Body.PaymentServiceSelectionRes);
        next_v2g_event = handle_iso_payment_service_selection(conn); // [V2G2-550]
    } else if (exi_in->V2G_Message.Body.PaymentDetailsReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling PaymentDetailsReq");
        conn->ctx->current_v2g_msg = V2G_PAYMENT_DETAILS_MSG;
        exi_out->V2G_Message.Body.PaymentDetailsRes_isUsed = 1u;
        init_iso2_PaymentDetailsResType(&exi_out->V2G_Message.Body.PaymentDetailsRes);
        next_v2g_event = handle_iso_payment_details(conn); // [V2G2-559]
    } else if (exi_in->V2G_Message.Body.AuthorizationReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling AuthorizationReq");
        conn->ctx->current_v2g_msg = V2G_AUTHORIZATION_MSG;
        if (conn->ctx->last_v2g_msg != V2G_AUTHORIZATION_MSG) {
            if (conn->ctx->session.iso_selected_payment_option == iso2_paymentOptionType_ExternalPayment) {
                conn->ctx->p_charger->publish_require_auth_eim(nullptr);
            }
        }
        exi_out->V2G_Message.Body.AuthorizationRes_isUsed = 1u;
        init_iso2_AuthorizationResType(&exi_out->V2G_Message.Body.AuthorizationRes);
        next_v2g_event = handle_iso_authorization(conn); // [V2G2-562]
    } else if (exi_in->V2G_Message.Body.ChargeParameterDiscoveryReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling ChargeParameterDiscoveryReq");
        conn->ctx->current_v2g_msg = V2G_CHARGE_PARAMETER_DISCOVERY_MSG;
        if (conn->ctx->last_v2g_msg == V2G_AUTHORIZATION_MSG) {
            dlog(DLOG_LEVEL_INFO, "Parameter-phase started");
        }
        exi_out->V2G_Message.Body.ChargeParameterDiscoveryRes_isUsed = 1u;
        init_iso2_ChargeParameterDiscoveryResType(&exi_out->V2G_Message.Body.ChargeParameterDiscoveryRes);
        next_v2g_event = handle_iso_charge_parameter_discovery(conn); // [V2G2-565]
    } else if (exi_in->V2G_Message.Body.PowerDeliveryReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling PowerDeliveryReq");
        conn->ctx->current_v2g_msg = V2G_POWER_DELIVERY_MSG;
        exi_out->V2G_Message.Body.PowerDeliveryRes_isUsed = 1u;
        init_iso2_PowerDeliveryResType(&exi_out->V2G_Message.Body.PowerDeliveryRes);
        next_v2g_event = handle_iso_power_delivery(conn); // [V2G2-589]
    } else if (exi_in->V2G_Message.Body.ChargingStatusReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling ChargingStatusReq");
        conn->ctx->current_v2g_msg = V2G_CHARGING_STATUS_MSG;

        exi_out->V2G_Message.Body.ChargingStatusRes_isUsed = 1u;
        init_iso2_ChargingStatusResType(&exi_out->V2G_Message.Body.ChargingStatusRes);
        next_v2g_event = handle_iso_charging_status(conn);
    } else if (exi_in->V2G_Message.Body.MeteringReceiptReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling MeteringReceiptReq");
        conn->ctx->current_v2g_msg = V2G_METERING_RECEIPT_MSG;
        exi_out->V2G_Message.Body.MeteringReceiptRes_isUsed = 1u;
        init_iso2_MeteringReceiptResType(&exi_out->V2G_Message.Body.MeteringReceiptRes);
        next_v2g_event = handle_iso_metering_receipt(conn); // [V2G2-796]
    } else if (exi_in->V2G_Message.Body.CertificateUpdateReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling CertificateUpdateReq");
        conn->ctx->current_v2g_msg = V2G_CERTIFICATE_UPDATE_MSG;

        exi_out->V2G_Message.Body.CertificateUpdateRes_isUsed = 1u;
        init_iso2_CertificateUpdateResType(&exi_out->V2G_Message.Body.CertificateUpdateRes);
        next_v2g_event = handle_iso_certificate_update(conn); // [V2G2-556]
    } else if (exi_in->V2G_Message.Body.CertificateInstallationReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling CertificateInstallationReq");
        conn->ctx->current_v2g_msg = V2G_CERTIFICATE_INSTALLATION_MSG;
        dlog(DLOG_LEVEL_INFO, "CertificateInstallation-phase started");

        exi_out->V2G_Message.Body.CertificateInstallationRes_isUsed = 1u;
        init_iso2_CertificateInstallationResType(&exi_out->V2G_Message.Body.CertificateInstallationRes);
        next_v2g_event = handle_iso_certificate_installation(conn); // [V2G2-553]
    } else if (exi_in->V2G_Message.Body.CableCheckReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling CableCheckReq");
        conn->ctx->current_v2g_msg = V2G_CABLE_CHECK_MSG;
        /* At first send mqtt charging phase signal to the customer interface */
        if (V2G_CHARGE_PARAMETER_DISCOVERY_MSG == conn->ctx->last_v2g_msg) {
            conn->ctx->p_charger->publish_start_cable_check(nullptr);
        }

        exi_out->V2G_Message.Body.CableCheckRes_isUsed = 1u;
        init_iso2_CableCheckResType(&exi_out->V2G_Message.Body.CableCheckRes);
        next_v2g_event = handle_iso_cable_check(conn); // [V2G2-583
    } else if (exi_in->V2G_Message.Body.PreChargeReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling PreChargeReq");
        conn->ctx->current_v2g_msg = V2G_PRE_CHARGE_MSG;
        /* At first send  mqtt charging phase signal to the customer interface */
        if (conn->ctx->last_v2g_msg == V2G_CABLE_CHECK_MSG) {
            conn->ctx->p_charger->publish_start_pre_charge(nullptr);
            dlog(DLOG_LEVEL_INFO, "Precharge-phase started");
        }

        exi_out->V2G_Message.Body.PreChargeRes_isUsed = 1u;
        init_iso2_PreChargeResType(&exi_out->V2G_Message.Body.PreChargeRes);
        next_v2g_event = handle_iso_pre_charge(conn); // [V2G2-586]
    } else if (exi_in->V2G_Message.Body.WeldingDetectionReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling WeldingDetectionReq");
        conn->ctx->current_v2g_msg = V2G_WELDING_DETECTION_MSG;
        if (conn->ctx->last_v2g_msg != V2G_WELDING_DETECTION_MSG) {
            dlog(DLOG_LEVEL_INFO, "Welding-phase started");
        }
        exi_out->V2G_Message.Body.WeldingDetectionRes_isUsed = 1u;
        init_iso2_WeldingDetectionResType(&exi_out->V2G_Message.Body.WeldingDetectionRes);
        next_v2g_event = handle_iso_welding_detection(conn); // [V2G2-596]
    } else if (exi_in->V2G_Message.Body.SessionStopReq_isUsed) {
        dlog(DLOG_LEVEL_TRACE, "Handling SessionStopReq");
        conn->ctx->current_v2g_msg = V2G_SESSION_STOP_MSG;
        exi_out->V2G_Message.Body.SessionStopRes_isUsed = 1u;
        init_iso2_SessionStopResType(&exi_out->V2G_Message.Body.SessionStopRes);
        next_v2g_event = handle_iso_session_stop(conn); // [V2G2-570]
    } else {
        dlog(DLOG_LEVEL_ERROR, "create_response_message: request type not found");
        next_v2g_event = V2G_EVENT_IGNORE_MSG;
    }
    dlog(DLOG_LEVEL_TRACE, "Current state: %s",
         conn->ctx->is_dc_charger ? iso_dc_states[conn->ctx->state].description
                                  : iso_ac_states[conn->ctx->state].description);

    // If next_v2g_event == V2G_EVENT_IGNORE_MSG, keep the current state and ignore msg
    if (next_v2g_event != V2G_EVENT_IGNORE_MSG) {
        conn->ctx->last_v2g_msg = conn->ctx->current_v2g_msg;

        /* Configure session id */
        memcpy(exi_out->V2G_Message.Header.SessionID.bytes, &conn->ctx->evse_v2g_data.session_id,
               iso2_sessionIDType_BYTES_SIZE);

        /* We always set bytesLen to iso2_MessageHeaderType_SessionID_BYTES_SIZE */
        exi_out->V2G_Message.Header.SessionID.bytesLen = iso2_sessionIDType_BYTES_SIZE;
    }

    return next_v2g_event;
}


// ===== iso_server.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2023 chargebyte GmbH
// Copyright (C) 2023 Contributors to EVerest

#ifndef ISO_SERVER_HPP
#define ISO_SERVER_HPP

#include "v2g.hpp"

struct iso_state {
    const char* description;
    int allowed_requests;
};

enum class iso_ac_state_id {
    WAIT_FOR_SESSIONSETUP = 0,
    WAIT_FOR_SERVICEDISCOVERY,
    WAIT_FOR_SVCDETAIL_PAYMENTSVCSEL,
    WAIT_FOR_PAYMENTDETAILS_CERTINST_CERTUPD,
    WAIT_FOR_PAYMENTDETAILS,
    WAIT_FOR_AUTHORIZATION,
    WAIT_FOR_CHARGEPARAMETERDISCOVERY,
    WAIT_FOR_POWERDELIVERY,
    WAIT_FOR_CHARGINGSTATUS,
    WAIT_FOR_CHARGINGSTATUS_POWERDELIVERY,
    WAIT_FOR_METERINGRECEIPT,
    WAIT_FOR_SESSIONSTOP,
    WAIT_FOR_TERMINATED_SESSION
};

enum class iso_dc_state_id {
    WAIT_FOR_SESSIONSETUP = 0,
    WAIT_FOR_SERVICEDISCOVERY,
    WAIT_FOR_SVCDETAIL_PAYMENTSVCSEL,
    WAIT_FOR_PAYMENTDETAILS_CERTINST_CERTUPD,
    WAIT_FOR_PAYMENTDETAILS,
    WAIT_FOR_AUTHORIZATION,
    WAIT_FOR_CHARGEPARAMETERDISCOVERY,
    WAIT_FOR_CABLECHECK,
    WAIT_FOR_PRECHARGE,
    WAIT_FOR_PRECHARGE_POWERDELIVERY,
    WAIT_FOR_CURRENTDEMAND_POWERDELIVERY,
    WAIT_FOR_CURRENTDEMAND,
    WAIT_FOR_METERINGRECEIPT,
    WAIT_FOR_WELDINGDETECTION_SESSIONSTOP,
    WAIT_FOR_TERMINATED_SESSION
};

static const char* isoResponse[] = {
    "Response OK",
    "New Session Established",
    "Old Session Joined",
    "Certificate Expires Soon",
    "Response FAILED",
    "Sequence Error",
    "Service ID Invalid",
    "Unknown Session",
    "Service Selection Invalid",
    "Payment Selection Invalid",
    "Certificate Expired",
    "Signature Error",
    "No Certificate Available",
    "Cert Chain Error",
    "Challenge Invalid",
    "Contract Canceled",
    "Wrong Charge Parameter",
    "Power Delivery Not Applied",
    "Tariff Selection Invalid",
    "Charging Profile Invalid",
    "Metering Signature Not Valid",
    "No Charge Service Selected",
    "Wrong Energy Transfer Mode",
    "Contactor Error",
    "Certificate Not Allowed At This EVSE",
    "Certificate Revoked",
};

static const struct iso_state iso_ac_states[] = {
    {"Waiting for SessionSetupReq", 1 << V2G_SESSION_SETUP_MSG},
    /* [V2G-543] Expected req msg after SessionSetupRes */
    {"Waiting for ServiceDiscoveryReq, SessionStopReq", 1 << V2G_SERVICE_DISCOVERY_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-545] Expected req msg after ServiceDiscoveryRes */
    {"Waiting for ServiceDetailReq, PaymentServiceSelectionReq, SessionStopReq",
     1 << V2G_SERVICE_DETAIL_MSG | 1 << V2G_PAYMENT_SERVICE_SELECTION_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-551] Expected req msg after ServicePaymentSelectionRes */
    {"Waiting for PaymentDetailsReq, CertificateInstallationReq, CertificateUpdateReq, SessionStopReq",
     1 << V2G_PAYMENT_DETAILS_MSG | 1 << V2G_CERTIFICATE_INSTALLATION_MSG | 1 << V2G_CERTIFICATE_UPDATE_MSG |
         1 << V2G_SESSION_STOP_MSG},
    {"Waiting for PaymentDetailsReq, SessionStopReq", 1 << V2G_PAYMENT_DETAILS_MSG | 1 << V2G_SESSION_STOP_MSG},
    {"Waiting for AuthorizationReq, SessionStopReq", 1 << V2G_AUTHORIZATION_MSG | 1 << V2G_SESSION_STOP_MSG},
    {"Waiting for ChargeParameterDiscoveryReq, SessionStopReq",
     1 << V2G_CHARGE_PARAMETER_DISCOVERY_MSG | 1 << V2G_SESSION_STOP_MSG},
    {"Waiting for PowerDeliveryReq, SessionStopReq", 1 << V2G_POWER_DELIVERY_MSG | 1 << V2G_SESSION_STOP_MSG},
    {"Waiting for ChargingStatusReq", 1 << V2G_CHARGING_STATUS_MSG},
    {"Waiting for ChargingStatusReq, PowerDeliveryReq", 1 << V2G_CHARGING_STATUS_MSG | 1 << V2G_POWER_DELIVERY_MSG},
    {"Waiting for MeteringReceiptReq", 1 << V2G_METERING_RECEIPT_MSG},
    {"Waiting for SessionStopReq", 1 << V2G_SESSION_STOP_MSG},
    {"Closing session", 0}};

static const struct iso_state iso_dc_states[] = {
    /* [V2G-541] Expected req msg after SupportedAppProtocolRes */
    {"Waiting for SessionSetupReq", 1 << V2G_SESSION_SETUP_MSG},
    /* [V2G-543] Expected req msg after SessionSetupRes */
    {"Waiting for ServiceDiscoveryReq, SessionStopReq", 1 << V2G_SERVICE_DISCOVERY_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-545] Expected req msg after ServiceDiscoveryRes */
    {"Waiting for ServiceDetailReq, ServicePaymentSelectionReq, SessionStopReq",
     1 << V2G_SERVICE_DETAIL_MSG | 1 << V2G_PAYMENT_SERVICE_SELECTION_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-551] Expected req msg after ServicePaymentSelectionRes */
    {"Waiting for PaymentDetailsReq, AuthorizationReq, CertificateInstallationReq, CertificateUpdateReq, "
     "SessionStopReq",
     1 << V2G_PAYMENT_DETAILS_MSG | 1 << V2G_AUTHORIZATION_MSG | 1 << V2G_CERTIFICATE_INSTALLATION_MSG |
         1 << V2G_CERTIFICATE_UPDATE_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-557], [V2G-554], [V2G-558] Expected req msg after CertificateInstallationRes or CertificateUpdateRes */
    {"Waiting for PaymentDetailsReq, SessionStopReq", 1 << V2G_PAYMENT_DETAILS_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-560], [V2G-687] Expected req msg after PaymentDetailsRes, ContractAuthenticationRes */
    {"Waiting for AuthorizationReq, SessionStopReq", 1 << V2G_AUTHORIZATION_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-573], [V2G-813],[V2G-688] Expected req msg after AuthorizationRes or PowerDeliveryRes or
       ChargeParameterDiscoveryRes */
    {"Waiting for ChargeParameterDiscoveryReq, SessionStopReq",
     1 << V2G_CHARGE_PARAMETER_DISCOVERY_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-582], [V2G-621] Expected req msg after CableCheckRes or ChargeParameterDiscoveryRes */
    {"Waiting for CableCheckReq, SessionStopReq", 1 << V2G_CABLE_CHECK_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-584] Expected req msg after CableCheckRes */
    {"Waiting for PreChargeReq, SessionStopReq", 1 << V2G_PRE_CHARGE_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-587] Expected req msg after PreChargeRes */
    {"Waiting for PreChargeReq, PowerDeliveryReq, SessionStopReq",
     1 << V2G_PRE_CHARGE_MSG | 1 << V2G_POWER_DELIVERY_MSG | 1 << V2G_SESSION_STOP_MSG},
    /* [V2G-797] Expected req msg after CurrentDemandRes or MeteringReceiptRes*/
    {"Waiting for CurrentDemandReq, PowerDeliveryReq", 1 << V2G_CURRENT_DEMAND_MSG | 1 << V2G_POWER_DELIVERY_MSG},
    /* [V2G-590] Expected req msg after PowerDeliveryRes or CurrentDemandRes or MeteringReceiptRes*/
    {"Waiting for CurrentDemandReq", 1 << V2G_CURRENT_DEMAND_MSG},
    /* [V2G-795] Expected req msg after CurrentDemandRes */
    {"Waiting for MeteringReceiptReq", 1 << V2G_METERING_RECEIPT_MSG},
    /* [V2G-597], [V2G-601] Expected req msg after PowerDeliveryRes or WeldingDetectionRes*/
    {"Waiting for WeldingDetectionReq, SessionStopReq", 1 << V2G_WELDING_DETECTION_MSG | 1 << V2G_SESSION_STOP_MSG},
    {"Closing session", 0}};

/*!
 * \brief iso_handle_request This is the main protocol handler. This function analyzes the received
 *  request msg and configures the next response msg.
 * \param conn \c v2g_connection struct and holds the v2g_connection information
 * \return when this function returns -1 then the connection is aborted without sending the reply,
 *  when this function returns 0 then the reply is sent,
 *  when this function returns 1 then the reply is sent and the connection is closed afterwards,
 *  when this function returns 2 then no reply is sent but the connection is kept open
 */
enum v2g_event iso_handle_request(v2g_connection* conn);

#endif /* ISO_SERVER_HPP */


// ===== log.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2022-2023 chargebyte GmbH
// Copyright (C) 2022-2023 Contributors to EVerest
#include "log.hpp"
#include <everest/logging.hpp> // for logging
#include <stdarg.h>            // for va_list, va_{start,end}()
#include <stdio.h>             // for v*printf()
#include <stdlib.h>            // for atoi()
#include <string.h>            // for strlen()
#include <sys/time.h>          // for gettimeofday()
#include <time.h>              // for strftime()

dloglevel_t minloglevel_current = DLOG_LEVEL_INFO;

static const char* debug_level_logstring_map[DLOG_LEVEL_NUMLEVELS] = {
    // tailing space, no need to add it later when printing
    // try to keep the strings almost same length, looks better
    "[(LOG)] ", "[ERROR] ", "[WARN]  ", "[INFO]  ", "[DEBUG] ", "[TRACE] "};

const char* debug_level_mqtt_string_map[DLOG_LEVEL_NUMLEVELS] = {"always", "error", "warning",
                                                                 "info",   "debug", "trace"};

// FIXME: inline?
void dlog_func(const dloglevel_t loglevel, const char* filename, const int linenumber, const char* functionname,
               const char* format, ...) {
    // fast exit
    if (loglevel > minloglevel_current) {
        return;
    }
    char* format_copy = NULL;
    FILE* outstream = stderr; // change output target here, if desired

    struct timeval debug_tval;
    struct tm tm;
    char log_datetimestamp[16];      // length due to format [00:00:00.000], rounded up to fit 32-bit alignment
    gettimeofday(&debug_tval, NULL); // ignore return value
    size_t offset =
        strftime(log_datetimestamp, sizeof(log_datetimestamp), "[%H:%M:%S", gmtime_r(&debug_tval.tv_sec, &tm));
    if (offset < 1) {
        // in our use of strftime(), this is an error
        return;
    }

    snprintf(log_datetimestamp + offset, sizeof(log_datetimestamp) - offset, ".%03ld] ", debug_tval.tv_usec / 1000);

    va_list args;
    va_start(args, format);

    // print the user given part
    // strip possible newline character from user-given string
    // FIXME: could be skipped
    if (format) {
        size_t formatlen = std::string(format).size();
        format_copy = static_cast<char*>(calloc(1, formatlen + 1)); // additional byte for terminating \0
        memcpy(format_copy, format, formatlen);
        if ((formatlen >= 1) && (format_copy[formatlen - 1] == '\n')) {
            format_copy[formatlen - 1] = '\0';
        }
    }
    char output[256];
    if (format_copy != NULL) {
        vsnprintf(output, sizeof(output), format_copy, args);
    }
    // force EOL
    fputs("\n", outstream);
    fflush(outstream);
    va_end(args);
    if (format_copy) {
        free(format_copy);
    }

    switch (loglevel) {
    case DLOG_LEVEL_ERROR:
        EVLOG_error << output;
        break;
    case DLOG_LEVEL_WARNING:
        EVLOG_warning << output;
        break;
    case DLOG_LEVEL_INFO:
        EVLOG_info << output;
        break;
    case DLOG_LEVEL_DEBUG:
        EVLOG_debug << output;
        break;
    case DLOG_LEVEL_TRACE:
        EVLOG_verbose << output;
        break;
    default:
        EVLOG_critical << "Unknown log level";
        break;
    }
}

void dlog_level_inc(void) {
    dloglevel_t minloglevel_new = (dloglevel_t)((int)minloglevel_current + 1);
    if (minloglevel_new == DLOG_LEVEL_NUMLEVELS) {
        // wrap to bottom, but not DLOG_LEVEL_ALWAYS
        minloglevel_new = DLOG_LEVEL_ERROR;
    }
    dlog_level_set(minloglevel_new);
}

void dlog_level_set(const dloglevel_t loglevel) {
    // no sanity checks currently
    const dloglevel_t minloglevel_old = minloglevel_current;
    dloglevel_t newloglevel = loglevel;
    if (newloglevel >= DLOG_LEVEL_NUMLEVELS) {
        // set something illegally high
        newloglevel = (dloglevel_t)(int)(DLOG_LEVEL_NUMLEVELS - 1);
    }
    if (newloglevel <= DLOG_LEVEL_ALWAYS) {
        // set something illegally low
        newloglevel = (dloglevel_t)(int)(DLOG_LEVEL_ALWAYS + 1);
    }
    if (newloglevel != minloglevel_current) {
        minloglevel_current = newloglevel;
        dlog(DLOG_LEVEL_ALWAYS, "switched log level from %d (\"%s\") to %d (\"%s\")", minloglevel_old,
             debug_level_logstring_map[minloglevel_old], newloglevel, debug_level_logstring_map[newloglevel]);
    }
}

dloglevel_t dlog_level_get(void) {
    return minloglevel_current;
}

static const char* dlog_level_get_string(const dloglevel_t loglevel) {
    if ((loglevel < 1) || loglevel >= DLOG_LEVEL_NUMLEVELS) {
        return "invalid_level";
    }
    return debug_level_mqtt_string_map[loglevel];
}


// ===== log.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2022-2023 chargebyte GmbH
// Copyright (C) 2022-2023 Contributors to EVerest
#ifndef LOG_H
#define LOG_H

/**
 * @brief Describe the intended log level of a message, or the maximum level a message must have to be displayed.
 */
typedef enum dloglevel_t {
    DLOG_LEVEL_ALWAYS = 0, ///< internal use only, for notification of log level change
    DLOG_LEVEL_ERROR,      ///< error
    DLOG_LEVEL_WARNING,    ///< warning, not leading to unexpected behavior such as termination
    DLOG_LEVEL_INFO,       ///< informational message
    DLOG_LEVEL_DEBUG,      ///< message to help debug daemon activity
    DLOG_LEVEL_TRACE,      ///< message to provide extra internal information
    DLOG_LEVEL_NUMLEVELS,  ///< don't use, only for internal detection of upper range
} dloglevel_t;

/**
 * @brief Internal: Issue a log message. Please use the dlog() macro instead.
 *
 * @return void
 */
void dlog_func(const dloglevel_t loglevel, const char* filename, const int linenumber, const char* functionname,
               const char* format, ...);

/**
 * @brief Increase the log level to the next higher step (more messages). At the highest step, the level rolls over to
 * the lowest.
 *
 * @return void
 */
void dlog_level_inc(void);

/**
 * @brief Set the log level.
 * @param[in] loglevel the log level the logger shall use, of type enum dloglevel
 *
 * @return void
 */
void dlog_level_set(const dloglevel_t loglevel);

/**
 * @brief Get the log level.
 *
 * @return dloglevel_t the currently valid log level
 */
dloglevel_t dlog_level_get(void);

/**
 * @brief Set the log level from an MQTT topic string.
 * @param[in] loglevel the log level the logger shall use, as an MQTT string
 *
 * @return void
 */
// dloglevel_t dlog_level_set_from_mqtt_string(const char *level_string);

/**
 * @brief Issue a log message.
 *
 * @param[in] level the log level this message belongs to (type enum dloglevel)
 * @param[in] printf()-like format string and parameters, without tailing '\n'
 *
 * @return void
 */
// this is a macro, so that when dlog() is used, it gets expanded at the caller's location
#define dlog(level, ...)                                                                                               \
    do {                                                                                                               \
        dlog_func((level), __FILE__, __LINE__, __func__, ##__VA_ARGS__);                                               \
    } while (0)

#endif /* LOG_H */


// ===== sdp.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2022-2023 chargebyte GmbH
// Copyright (C) 2022-2023 Contributors to EVerest
#include "sdp.hpp"
#include "log.hpp"

#include <arpa/inet.h>
#include <errno.h>
#include <ifaddrs.h>
#include <inttypes.h>
#include <net/if.h>
#include <netinet/in.h>
#include <poll.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#define DEBUG 1

/* defines for V2G SDP implementation */
#define SDP_SRV_PORT 15118

#define SDP_VERSION         0x01
#define SDP_INVERSE_VERSION 0xfe

#define SDP_HEADER_LEN           8
#define SDP_REQUEST_PAYLOAD_LEN  2
#define SDP_RESPONSE_PAYLOAD_LEN 20

#define SDP_REQUEST_TYPE  0x9000
#define SDP_RESPONSE_TYPE 0x9001

#define POLL_TIMEOUT 20

/* link-local multicast address ff02::1 aka ip6-allnodes */
#define IN6ADDR_ALLNODES                                                                                               \
    { 0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01 }

/* bundles various aspects of a SDP query */
struct sdp_query {
    struct v2g_context* v2g_ctx;

    struct sockaddr_in6 remote_addr;

    enum sdp_security security_requested;
    enum sdp_transport_protocol proto_requested;
};

/*
 * Fills the SDP header into a given buffer
 */
int sdp_write_header(uint8_t* buffer, uint16_t payload_type, uint32_t payload_len) {
    int offset = 0;

    buffer[offset++] = SDP_VERSION;
    buffer[offset++] = SDP_INVERSE_VERSION;

    /* payload is network byte order */
    buffer[offset++] = (payload_type >> 8) & 0xff;
    buffer[offset++] = payload_type & 0xff;

    /* payload_length is network byte order */
    buffer[offset++] = (payload_len >> 24) & 0xff;
    buffer[offset++] = (payload_len >> 16) & 0xff;
    buffer[offset++] = (payload_len >> 8) & 0xff;
    buffer[offset++] = payload_len & 0xff;

    return offset;
}

int sdp_validate_header(uint8_t* buffer, uint16_t expected_payload_type, uint32_t expected_payload_len) {
    uint16_t payload_type;
    uint32_t payload_len;

    if (buffer[0] != SDP_VERSION) {
        dlog(DLOG_LEVEL_ERROR, "Invalid SDP version");
        return -1;
    }

    if (buffer[1] != SDP_INVERSE_VERSION) {
        dlog(DLOG_LEVEL_ERROR, "Invalid SDP inverse version");
        return -1;
    }

    payload_type = (buffer[2] << 8) + buffer[3];
    if (payload_type != expected_payload_type) {
        dlog(DLOG_LEVEL_ERROR, "Invalid payload type: expected %" PRIu16 ", received %" PRIu16, expected_payload_type,
             payload_type);
        return -1;
    }

    payload_len = (buffer[4] << 24) + (buffer[5] << 16) + (buffer[6] << 8) + buffer[7];
    if (payload_len != expected_payload_len) {
        dlog(DLOG_LEVEL_ERROR, "Invalid payload length: expected %" PRIu32 ", received %" PRIu32, expected_payload_len,
             payload_len);
        return -1;
    }

    return 0;
}

int sdp_create_response(uint8_t* buffer, struct sockaddr_in6* addr, enum sdp_security security,
                        enum sdp_transport_protocol proto) {
    int offset = SDP_HEADER_LEN;

    /* fill in first the payload */

    /* address is already network byte order */
    memcpy(&buffer[offset], &addr->sin6_addr, sizeof(addr->sin6_addr));
    offset += sizeof(addr->sin6_addr);

    memcpy(&buffer[offset], &addr->sin6_port, sizeof(addr->sin6_port));
    offset += sizeof(addr->sin6_port);

    buffer[offset++] = security;
    buffer[offset++] = proto;

    /* now fill in the header with payload length */
    sdp_write_header(buffer, SDP_RESPONSE_TYPE, offset - SDP_HEADER_LEN);

    return offset;
}
/*
 * Sends a SDP response packet
 */
int sdp_send_response(int sdp_socket, struct sdp_query* sdp_query) {
    uint8_t buffer[SDP_HEADER_LEN + SDP_RESPONSE_PAYLOAD_LEN];
    int rv = 0;

    /* at the moment we only understand TCP protocol */
    if (sdp_query->proto_requested != SDP_TRANSPORT_PROTOCOL_TCP) {
        dlog(DLOG_LEVEL_ERROR, "SDP requested unsupported protocol 0x%02x, announcing nothing",
             sdp_query->proto_requested);
        return 1;
    }

    using state_t = tls::Server::state_t;
    const auto tls_server_state = sdp_query->v2g_ctx->tls_server->state();

    const auto tls_server_available =
        (tls_server_state == state_t::init_complete or tls_server_state == state_t::running);

    switch (sdp_query->security_requested) {
    case SDP_SECURITY_TLS:
        if (sdp_query->v2g_ctx->local_tls_addr and tls_server_available) {
            dlog(DLOG_LEVEL_INFO, "SDP requested TLS, announcing TLS");
            sdp_create_response(buffer, sdp_query->v2g_ctx->local_tls_addr, SDP_SECURITY_TLS,
                                SDP_TRANSPORT_PROTOCOL_TCP);
            break;
        }
        if (sdp_query->v2g_ctx->local_tcp_addr) {
            dlog(DLOG_LEVEL_INFO, "SDP requested TLS, announcing NO-TLS");
            sdp_create_response(buffer, sdp_query->v2g_ctx->local_tcp_addr, SDP_SECURITY_NONE,
                                SDP_TRANSPORT_PROTOCOL_TCP);
            break;
        }
        dlog(DLOG_LEVEL_ERROR, "SDP requested TLS, announcing nothing");
        return 1;

    case SDP_SECURITY_NONE:
        if (sdp_query->v2g_ctx->local_tcp_addr) {
            dlog(DLOG_LEVEL_INFO, "SDP requested NO-TLS, announcing NO-TLS");
            sdp_create_response(buffer, sdp_query->v2g_ctx->local_tcp_addr, SDP_SECURITY_NONE,
                                SDP_TRANSPORT_PROTOCOL_TCP);
            break;
        }
        if (sdp_query->v2g_ctx->local_tls_addr and tls_server_available) {
            dlog(DLOG_LEVEL_INFO, "SDP requested NO-TLS, announcing TLS");
            sdp_create_response(buffer, sdp_query->v2g_ctx->local_tls_addr, SDP_SECURITY_TLS,
                                SDP_TRANSPORT_PROTOCOL_TCP);
            break;
        }
        dlog(DLOG_LEVEL_ERROR, "SDP requested NO-TLS, announcing nothing");
        return 1;

    default:
        dlog(DLOG_LEVEL_ERROR, "SDP requested unsupported security 0x%02x, announcing nothing",
             sdp_query->security_requested);
        return 1;
    }

    if (sendto(sdp_socket, buffer, sizeof(buffer), 0, (struct sockaddr*)&sdp_query->remote_addr,
               sizeof(struct sockaddr_in6)) != sizeof(buffer)) {
        rv = -1;
    }
    if (DEBUG) {
        char addrbuf[INET6_ADDRSTRLEN] = {0};
        const char* addr;
        int saved_errno = errno;

        addr = inet_ntop(AF_INET6, &sdp_query->remote_addr.sin6_addr, addrbuf, sizeof(addrbuf));
        if (rv == 0) {
            dlog(DLOG_LEVEL_INFO, "sendto([%s]:%" PRIu16 ") succeeded", addr, ntohs(sdp_query->remote_addr.sin6_port));
        } else {
            dlog(DLOG_LEVEL_ERROR, "sendto([%s]:%" PRIu16 ") failed: %s", addr, ntohs(sdp_query->remote_addr.sin6_port),
                 strerror(saved_errno));
        }
    }

    return rv;
}

int sdp_init(struct v2g_context* v2g_ctx) {
    struct sockaddr_in6 sdp_addr = {AF_INET6, htons(SDP_SRV_PORT)};
    struct ipv6_mreq mreq = {{IN6ADDR_ALLNODES}, 0};
    int enable = 1;

    mreq.ipv6mr_interface = if_nametoindex(v2g_ctx->if_name);
    if (!mreq.ipv6mr_interface) {
        dlog(DLOG_LEVEL_ERROR, "No such interface: %s", v2g_ctx->if_name);
        return -1;
    }

    /* create receiving socket */
    v2g_ctx->sdp_socket = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
    if (v2g_ctx->sdp_socket == -1) {
        dlog(DLOG_LEVEL_ERROR, "socket() failed: %s", strerror(errno));
        return -1;
    }

    if (setsockopt(v2g_ctx->sdp_socket, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable)) == -1) {
        dlog(DLOG_LEVEL_ERROR, "setsockopt(SO_REUSEPORT) failed: %s", strerror(errno));
        close(v2g_ctx->sdp_socket);
        return -1;
    }

    sdp_addr.sin6_addr = in6addr_any;

    if (bind(v2g_ctx->sdp_socket, (struct sockaddr*)&sdp_addr, sizeof(sdp_addr)) == -1) {
        dlog(DLOG_LEVEL_ERROR, "bind() failed: %s", strerror(errno));
        close(v2g_ctx->sdp_socket);
        return -1;
    }

    dlog(DLOG_LEVEL_INFO, "SDP socket setup succeeded");

    /* bind only to specified device */
    if (setsockopt(v2g_ctx->sdp_socket, SOL_SOCKET, SO_BINDTODEVICE, v2g_ctx->if_name, strlen(v2g_ctx->if_name)) ==
        -1) {
        dlog(DLOG_LEVEL_ERROR, "setsockopt(SO_BINDTODEVICE) failed: %s", strerror(errno));
        close(v2g_ctx->sdp_socket);
        return -1;
    }

    dlog(DLOG_LEVEL_TRACE, "bind only to specified device");

    /* join multicast group */
    if (setsockopt(v2g_ctx->sdp_socket, IPPROTO_IPV6, IPV6_JOIN_GROUP, &mreq, sizeof(mreq)) == -1) {
        dlog(DLOG_LEVEL_ERROR, "setsockopt(IPV6_JOIN_GROUP) failed: %s", strerror(errno));
        close(v2g_ctx->sdp_socket);
        return -1;
    }

    dlog(DLOG_LEVEL_TRACE, "joined multicast group");

    return 0;
}

int sdp_listen(struct v2g_context* v2g_ctx) {
    /* Init pollfd struct */
    struct pollfd pollfd = {v2g_ctx->sdp_socket, POLLIN, 0};

    while (!v2g_ctx->shutdown) {
        uint8_t buffer[SDP_HEADER_LEN + SDP_REQUEST_PAYLOAD_LEN];
        char addrbuf[INET6_ADDRSTRLEN] = {0};
        const char* addr = addrbuf;
        struct sdp_query sdp_query = {
            .v2g_ctx = v2g_ctx,
        };
        socklen_t addrlen = sizeof(sdp_query.remote_addr);

        /* Check if data was received on socket */
        signed status = poll(&pollfd, 1, POLL_TIMEOUT);

        if (status == -1) {
            if (errno == EINTR) { // If the call did not succeed because it was interrupted
                continue;
            } else {
                dlog(DLOG_LEVEL_ERROR, "poll() failed: %s", strerror(errno));
                continue;
            }
        }
        /* If new data was received, handle sdp request */
        if (status > 0) {
            ssize_t len = recvfrom(v2g_ctx->sdp_socket, buffer, sizeof(buffer), 0,
                                   (struct sockaddr*)&sdp_query.remote_addr, &addrlen);
            if (len == -1) {
                if (errno != EINTR)
                    dlog(DLOG_LEVEL_ERROR, "recvfrom() failed: %s", strerror(errno));
                continue;
            }

            addr = inet_ntop(AF_INET6, &sdp_query.remote_addr.sin6_addr, addrbuf, sizeof(addrbuf));

            if (len != sizeof(buffer)) {
                dlog(DLOG_LEVEL_WARNING, "Discarded packet from [%s]:%" PRIu16 " due to unexpected length %zd", addr,
                     ntohs(sdp_query.remote_addr.sin6_port), len);
                continue;
            }

            if (sdp_validate_header(buffer, SDP_REQUEST_TYPE, SDP_REQUEST_PAYLOAD_LEN)) {
                dlog(DLOG_LEVEL_WARNING, "Packet with invalid SDP header received from [%s]:%" PRIu16, addr,
                     ntohs(sdp_query.remote_addr.sin6_port));
                continue;
            }

            sdp_query.security_requested = (sdp_security)buffer[SDP_HEADER_LEN + 0];
            sdp_query.proto_requested = (sdp_transport_protocol)buffer[SDP_HEADER_LEN + 1];

            dlog(DLOG_LEVEL_INFO, "Received packet from [%s]:%" PRIu16 " with security 0x%02x and protocol 0x%02x",
                 addr, ntohs(sdp_query.remote_addr.sin6_port), sdp_query.security_requested, sdp_query.proto_requested);

            sdp_send_response(v2g_ctx->sdp_socket, &sdp_query);
        }
    }

    if (close(v2g_ctx->sdp_socket) == -1) {
        dlog(DLOG_LEVEL_ERROR, "close() failed: %s", strerror(errno));
    }

    return 0;
}


// ===== sdp.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2022-2023 chargebyte GmbH
// Copyright (C) 2022-2023 Contributors to EVerest
#ifndef SDP_H
#define SDP_H

#include "v2g.hpp"

enum sdp_security {
    SDP_SECURITY_TLS = 0x00,
    SDP_SECURITY_NONE = 0x10,
};

enum sdp_transport_protocol {
    SDP_TRANSPORT_PROTOCOL_TCP = 0x00,
    SDP_TRANSPORT_PROTOCOL_UDP = 0x10,
};

int sdp_write_header(uint8_t* buffer, uint16_t payload_type, uint32_t payload_len);
int sdp_validate_header(uint8_t* buffer, uint16_t expected_payload_type, uint32_t expected_payload_len);
int sdp_create_response(uint8_t* buffer, struct sockaddr_in6* addr, enum sdp_security security,
                        enum sdp_transport_protocol proto);
int sdp_init(struct v2g_context* v2g_ctx);
int sdp_listen(struct v2g_context* v2g_ctx);

#endif /* SDP_H */


// ===== tests\din_server_test.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright Pionix GmbH and Contributors to EVerest
#include <din_server.hpp>

#include <cstring>
#include <gtest/gtest.h>

#include "ISO15118_chargerImplStub.hpp"
#include "cbv2g/din/din_msgDefDatatypes.h"
#include "utest_log.hpp"
#include "v2g.hpp"

#include <memory>

void publish_dc_ev_maximum_limits(struct v2g_context* ctx, const float& v2g_dc_ev_max_current_limit,
                                  const unsigned int& v2g_dc_ev_max_current_limit_is_used,
                                  const float& v2g_dc_ev_max_power_limit,
                                  const unsigned int& v2g_dc_ev_max_power_limit_is_used,
                                  const float& v2g_dc_ev_max_voltage_limit,
                                  const unsigned int& v2g_dc_ev_max_voltage_limit_is_used) {
}

void stop_timer(struct event** event_timer, char const* const timer_name, struct v2g_context* ctx) {
}

void log_selected_energy_transfer_type(int selected_energy_transfer_mode) {
}

uint64_t v2g_session_id_from_exi(bool is_iso, void* exi_in) {
    return 0;
}

void publish_dc_ev_target_voltage_current(struct v2g_context* ctx, const float& v2g_dc_ev_target_voltage,
                                          const float& v2g_dc_ev_target_current) {
}

void publish_dc_ev_remaining_time(struct v2g_context* ctx, const float& v2g_dc_ev_remaining_time_to_full_soc,
                                  const unsigned int& v2g_dc_ev_remaining_time_to_full_soc_is_used,
                                  const float& v2g_dc_ev_remaining_time_to_bulk_soc,
                                  const unsigned int& v2g_dc_ev_remaining_time_to_bulk_soc_is_used) {
}

namespace {
class DinServerTest : public testing::Test {
protected:
    std::unique_ptr<v2g_connection> conn;
    std::unique_ptr<v2g_context> ctx;
    std::unique_ptr<din_exiDocument> exi_in;
    std::unique_ptr<din_exiDocument> exi_out;

    module::stub::ModuleAdapterStub adapter;
    module::stub::ISO15118_chargerImplStub charger;

    DinServerTest() : charger(adapter) {
    }

    void SetUp() override {
        conn = std::make_unique<v2g_connection>();
        ctx = std::make_unique<v2g_context>();
        exi_in = std::make_unique<din_exiDocument>();
        exi_out = std::make_unique<din_exiDocument>();

        module::stub::clear_logs();
        conn->ctx = ctx.get();
        conn->ctx->p_charger = &charger;

        conn->exi_in.dinEXIDocument = exi_in.get();
        conn->exi_out.dinEXIDocument = exi_out.get();
    }

    void TearDown() override {
    }
};

class DinServerTestValidateResponseCode
    : public DinServerTest,
      public testing::WithParamInterface<
          std::tuple<int /*din_responseCodeType*/, bool, bool, bool, int /*V2gMsgTypeId*/, uint64_t, uint64_t, bool>> {
};

// For all test cases:
// TODO: Define helper functions to set the conn and ctx variables

// ----------------------------------------------------------------

// Potential test for SessionSetup:
// Bad Case:
// Setting no EvseID -> A check should be added -> But a default value is in ctx provided.
TEST_F(DinServerTest, session_setup_generating_new_session_id) {
    // Setting up session_setup_req
    auto& session_setup_req = exi_in->V2G_Message.Body.SessionSetupReq;
    exi_in->V2G_Message.Body.SessionSetupReq_isUsed = true;
    init_din_SessionSetupReqType(&session_setup_req);

    const uint8_t evcc_id[8] = {0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11};
    memcpy(session_setup_req.EVCCID.bytes, evcc_id, sizeof(evcc_id));
    session_setup_req.EVCCID.bytesLen = sizeof(evcc_id);

    // Setting up conn
    ctx->current_v2g_msg = V2G_SESSION_SETUP_MSG;

    ctx->evse_v2g_data.session_id = 0;
    ctx->evse_v2g_data.date_time_now_is_used = 0;

    ctx->ev_v2g_data.received_session_id = 0;

    std::string evse_id = std::string("DE*PNX*TET1*234");
    strcpy(reinterpret_cast<char*>(ctx->evse_v2g_data.evse_id.bytes), evse_id.data());
    ctx->evse_v2g_data.evse_id.bytesLen = evse_id.size();

    // Setting up session_setup_res
    auto& session_setup_res = exi_out->V2G_Message.Body.SessionSetupRes;
    exi_out->V2G_Message.Body.SessionSetupRes_isUsed = 1u;
    init_din_SessionSetupResType(&session_setup_res);

    EXPECT_EQ(states::handle_din_session_setup(conn.get()), V2G_EVENT_NO_EVENT);
    EXPECT_EQ(module::stub::get_logs(dloglevel_t::DLOG_LEVEL_ERROR).size(), 0);
    EXPECT_EQ(module::stub::get_logs(dloglevel_t::DLOG_LEVEL_INFO).size(), 3);

    EXPECT_EQ(session_setup_res.DateTimeNow_isUsed, false);
    // Checking if session id is generated
    EXPECT_GT(ctx->evse_v2g_data.session_id, 0);
    // Checking if evse id was set correctly
    EXPECT_EQ(evse_id, std::string(reinterpret_cast<char*>(session_setup_res.EVSEID.bytes)));
}

TEST_F(DinServerTest, session_setup_old_session_id) {
    // Setting up session_setup_req
    auto& session_setup_req = exi_in->V2G_Message.Body.SessionSetupReq;
    exi_in->V2G_Message.Body.SessionSetupReq_isUsed = true;
    init_din_SessionSetupReqType(&session_setup_req);

    const uint8_t evcc_id[8] = {0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11};
    memcpy(session_setup_req.EVCCID.bytes, evcc_id, sizeof(evcc_id));
    session_setup_req.EVCCID.bytesLen = sizeof(evcc_id);

    // Setting up conn
    ctx->current_v2g_msg = V2G_SESSION_SETUP_MSG;

    ctx->evse_v2g_data.session_id = 4158610156;
    ctx->evse_v2g_data.date_time_now_is_used = 0;

    ctx->ev_v2g_data.received_session_id = 0;

    std::string evse_id = std::string("DE*PNX*TET1*234");
    strcpy(reinterpret_cast<char*>(ctx->evse_v2g_data.evse_id.bytes), evse_id.data());
    ctx->evse_v2g_data.evse_id.bytesLen = evse_id.size();

    // Setting up session_setup_res
    auto& session_setup_res = exi_out->V2G_Message.Body.SessionSetupRes;
    exi_out->V2G_Message.Body.SessionSetupRes_isUsed = 1u;
    init_din_SessionSetupResType(&session_setup_res);

    EXPECT_EQ(states::handle_din_session_setup(conn.get()), V2G_EVENT_NO_EVENT);
    EXPECT_EQ(module::stub::get_logs(dloglevel_t::DLOG_LEVEL_ERROR).size(), 0);
    EXPECT_EQ(module::stub::get_logs(dloglevel_t::DLOG_LEVEL_INFO).size(), 2);

    EXPECT_EQ(session_setup_res.DateTimeNow_isUsed, false);
    // Checking if session id is generated
    EXPECT_EQ(ctx->evse_v2g_data.session_id, 4158610156);
    // Checking if evse id was set correctly
    EXPECT_EQ(evse_id, std::string(reinterpret_cast<char*>(session_setup_res.EVSEID.bytes)));
}

TEST_F(DinServerTest, session_setup_datetime_is_used) {
    // Setting up session_setup_req
    auto& session_setup_req = exi_in->V2G_Message.Body.SessionSetupReq;
    exi_in->V2G_Message.Body.SessionSetupReq_isUsed = true;
    init_din_SessionSetupReqType(&session_setup_req);

    const uint8_t evcc_id[8] = {0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11};
    memcpy(session_setup_req.EVCCID.bytes, evcc_id, sizeof(evcc_id));
    session_setup_req.EVCCID.bytesLen = sizeof(evcc_id);

    // Setting up conn
    ctx->current_v2g_msg = V2G_SESSION_SETUP_MSG;

    ctx->evse_v2g_data.session_id = 0;
    ctx->evse_v2g_data.date_time_now_is_used = true;

    ctx->ev_v2g_data.received_session_id = 0;

    std::string evse_id = std::string("DE*PNX*TET1*234");
    strcpy(reinterpret_cast<char*>(ctx->evse_v2g_data.evse_id.bytes), evse_id.data());
    ctx->evse_v2g_data.evse_id.bytesLen = evse_id.size();

    // Setting up session_setup_res
    auto& session_setup_res = exi_out->V2G_Message.Body.SessionSetupRes;
    exi_out->V2G_Message.Body.SessionSetupRes_isUsed = 1u;
    init_din_SessionSetupResType(&session_setup_res);

    EXPECT_EQ(states::handle_din_session_setup(conn.get()), V2G_EVENT_NO_EVENT);
    EXPECT_EQ(module::stub::get_logs(dloglevel_t::DLOG_LEVEL_ERROR).size(), 0);
    EXPECT_EQ(module::stub::get_logs(dloglevel_t::DLOG_LEVEL_INFO).size(), 3);

    EXPECT_EQ(session_setup_res.DateTimeNow_isUsed, true);
    EXPECT_GT(session_setup_res.DateTimeNow, 0);
    // Checking if session id is generated
    EXPECT_GT(ctx->evse_v2g_data.session_id, 0);
    // Checking if evse id was set correctly
    EXPECT_EQ(evse_id, std::string(reinterpret_cast<char*>(session_setup_res.EVSEID.bytes)));
}

TEST_F(DinServerTest, din_service_discovery_good_case) {

    // TODO(sl): Maybe add this to check exi_out proberly
    exi_out->V2G_Message.Body.ServiceDiscoveryRes_isUsed = true;
    init_din_ServiceDiscoveryResType(&exi_out->V2G_Message.Body.ServiceDiscoveryRes);

    // TODO: Setting the correct session_id + received_session_id via functions

    EXPECT_EQ(states::handle_din_service_discovery(conn.get()), V2G_EVENT_NO_EVENT);
    EXPECT_EQ(module::stub::get_logs(dloglevel_t::DLOG_LEVEL_ERROR).size(), 1);
    EXPECT_EQ(module::stub::get_logs(dloglevel_t::DLOG_LEVEL_INFO).size(), 0);
}

TEST_F(DinServerTest, handle_din_contract_authentication_check_evse_processing_finished) {

    // TODO: set a prober session id
    ctx->evse_v2g_data.session_id = 0;
    ctx->evse_v2g_data.date_time_now_is_used = 0;

    ctx->current_v2g_msg = V2G_AUTHORIZATION_MSG;
    ctx->ev_v2g_data.received_session_id = 0;

    ctx->evse_v2g_data.evse_processing[PHASE_AUTH] = 0;
    EXPECT_EQ(states::handle_din_contract_authentication(conn.get()), V2G_EVENT_NO_EVENT); // TODO

    auto& res = exi_out->V2G_Message.Body.ContractAuthenticationRes;

    // EXPECT_EQ(res.ResponseCode, din_responseCodeType_OK);
    EXPECT_EQ(res.EVSEProcessing, din_EVSEProcessingType_Finished);
    EXPECT_EQ(ctx->state, WAIT_FOR_CHARGEPARAMETERDISCOVERY);
    EXPECT_EQ(module::stub::get_logs(dloglevel_t::DLOG_LEVEL_ERROR).size(), 1);
    EXPECT_EQ(module::stub::get_logs(dloglevel_t::DLOG_LEVEL_INFO).size(), 0);
}

TEST_F(DinServerTest, handle_din_contract_authentication_check_evse_processing_ongoing) {

    // TODO: set a prober session id
    ctx->evse_v2g_data.session_id = 0;
    ctx->evse_v2g_data.date_time_now_is_used = 0;

    ctx->current_v2g_msg = V2G_AUTHORIZATION_MSG;
    ctx->ev_v2g_data.received_session_id = 0;

    ctx->evse_v2g_data.evse_processing[PHASE_AUTH] = 1;
    EXPECT_EQ(states::handle_din_contract_authentication(conn.get()), V2G_EVENT_NO_EVENT); // TODO

    auto& res = exi_out->V2G_Message.Body.ContractAuthenticationRes;

    // EXPECT_EQ(res.ResponseCode, din_responseCodeType_OK);
    EXPECT_EQ(res.EVSEProcessing, din_EVSEProcessingType_Ongoing);
    EXPECT_EQ(ctx->state, WAIT_FOR_AUTHORIZATION);
    EXPECT_EQ(module::stub::get_logs(dloglevel_t::DLOG_LEVEL_ERROR).size(), 1);
    EXPECT_EQ(module::stub::get_logs(dloglevel_t::DLOG_LEVEL_INFO).size(), 0);
}

// if not otherwise specified, the following testcases are happy paths

TEST_F(DinServerTest, din_validate_response_code_TERMINATE_CONNECTION) {

    // which response code is actually irrelevant here and was picked at random
    auto tmp = din_responseCodeType_FAILED_TariffSelectionInvalid;

    // only this bool determines the outcome
    ctx->is_connection_terminated = true;

    EXPECT_EQ(utils::din_validate_response_code(&tmp, conn.get()), V2G_EVENT_TERMINATE_CONNECTION);
}

TEST_F(DinServerTest, din_validate_response_code_EVENT_NO_EVENT_failed_response_FAILED) {

    // which response code is actually irrelevant here and was picked at random
    // FAILED code
    auto tmp = din_responseCodeType_FAILED_ChallengeInvalid;

    ctx->is_connection_terminated = false;

    ctx->terminate_connection_on_failed_response = false;

    EXPECT_EQ(utils::din_validate_response_code(&tmp, conn.get()), V2G_EVENT_NO_EVENT);
}

TEST_F(DinServerTest, din_validate_response_code_EVENT_NO_EVENT_failed_response_OK) {

    // which response code is actually irrelevant here and was picked at random
    // OK code
    auto tmp = din_responseCodeType_OK;

    ctx->is_connection_terminated = false;

    ctx->terminate_connection_on_failed_response = false;

    EXPECT_EQ(utils::din_validate_response_code(&tmp, conn.get()), V2G_EVENT_NO_EVENT);
}

TEST_F(DinServerTest, din_validate_response_code_EVENT_NO_EVENT_OK) {

    // which response code is actually irrelevant here and was picked at random
    // OK code
    auto tmp = din_responseCodeType_OK;

    ctx->is_connection_terminated = false;

    ctx->stop_hlc = false; //||
    ctx->intl_emergency_shutdown = false;

    ctx->current_v2g_msg = V2G_SESSION_SETUP_MSG; // &&
    ctx->evse_v2g_data.session_id = 1;
    ctx->ev_v2g_data.received_session_id = 2;

    ctx->terminate_connection_on_failed_response = true;

    EXPECT_EQ(utils::din_validate_response_code(&tmp, conn.get()), V2G_EVENT_NO_EVENT);
}

TEST_F(DinServerTest, din_validate_response_code_EVENT_NO_EVENT_OK_bad_path_1) {

    // OK code
    auto tmp = din_responseCodeType_OK;

    ctx->is_connection_terminated = false;

    ctx->stop_hlc = true; //||
    ctx->intl_emergency_shutdown = false;

    ctx->current_v2g_msg = V2G_SESSION_SETUP_MSG; // &&
    ctx->evse_v2g_data.session_id = 1;
    ctx->ev_v2g_data.received_session_id = 2;

    ctx->terminate_connection_on_failed_response = true;

    EXPECT_NE(utils::din_validate_response_code(&tmp, conn.get()), V2G_EVENT_NO_EVENT);
}

TEST_F(DinServerTest, din_validate_response_code_EVENT_NO_EVENT_OK_bad_path_2) {

    // OK code
    auto tmp = din_responseCodeType_OK;

    ctx->is_connection_terminated = false;

    ctx->stop_hlc = false; //||
    ctx->intl_emergency_shutdown = true;

    ctx->current_v2g_msg = V2G_SESSION_SETUP_MSG; // &&
    ctx->evse_v2g_data.session_id = 1;
    ctx->ev_v2g_data.received_session_id = 2;

    ctx->terminate_connection_on_failed_response = true;

    EXPECT_NE(utils::din_validate_response_code(&tmp, conn.get()), V2G_EVENT_NO_EVENT);
}

TEST_F(DinServerTest, din_validate_response_code_EVENT_NO_EVENT_OK_bad_path_3) {

    // OK code
    auto tmp = din_responseCodeType_OK;

    ctx->is_connection_terminated = false;

    ctx->stop_hlc = false; //||
    ctx->intl_emergency_shutdown = false;

    ctx->current_v2g_msg = V2G_CERTIFICATE_INSTALLATION_MSG; // &&
    ctx->evse_v2g_data.session_id = 1;
    ctx->ev_v2g_data.received_session_id = 2;

    ctx->terminate_connection_on_failed_response = true;

    EXPECT_NE(utils::din_validate_response_code(&tmp, conn.get()), V2G_EVENT_NO_EVENT);
}

TEST_F(DinServerTest, din_validate_response_code_EVENT_NO_EVENT_OK_bad_path_4) {

    // OK code
    auto tmp = din_responseCodeType_OK;

    ctx->is_connection_terminated = false;

    ctx->stop_hlc = false; //||
    ctx->intl_emergency_shutdown = true;

    ctx->current_v2g_msg = V2G_SESSION_SETUP_MSG; // &&
    ctx->evse_v2g_data.session_id = 6;
    ctx->ev_v2g_data.received_session_id = 6;

    ctx->terminate_connection_on_failed_response = true;

    EXPECT_NE(utils::din_validate_response_code(&tmp, conn.get()), V2G_EVENT_NO_EVENT);
}

TEST_F(DinServerTest, din_validate_response_code_EVENT_SEND_AND_TERMINATE_1) {

    auto tmp = din_responseCodeType_FAILED_WrongEnergyTransferType;

    ctx->is_connection_terminated = false;

    ctx->stop_hlc = true; //||
    ctx->intl_emergency_shutdown = false;

    ctx->current_v2g_msg = V2G_METERING_RECEIPT_MSG; // &&
    ctx->evse_v2g_data.session_id = 6;
    ctx->ev_v2g_data.received_session_id = 6;

    ctx->terminate_connection_on_failed_response = true;

    EXPECT_EQ(utils::din_validate_response_code(&tmp, conn.get()), V2G_EVENT_SEND_AND_TERMINATE);
}

TEST_F(DinServerTest, din_validate_response_code_EVENT_SEND_AND_TERMINATE_2) {

    auto tmp = din_responseCodeType_FAILED_MeteringSignatureNotValid;

    ctx->is_connection_terminated = false;

    ctx->stop_hlc = false; //||
    ctx->intl_emergency_shutdown = true;

    ctx->current_v2g_msg = V2G_CHARGING_STATUS_MSG; // &&
    ctx->evse_v2g_data.session_id = 1;
    ctx->ev_v2g_data.received_session_id = 6;

    ctx->terminate_connection_on_failed_response = true;

    EXPECT_EQ(utils::din_validate_response_code(&tmp, conn.get()), V2G_EVENT_SEND_AND_TERMINATE);
}

TEST_F(DinServerTest, din_validate_response_code_EVENT_SEND_AND_TERMINATE_3) {

    auto tmp = din_responseCodeType_OK_CertificateExpiresSoon;

    ctx->is_connection_terminated = false;

    ctx->stop_hlc = false; //||
    ctx->intl_emergency_shutdown = false;

    ctx->current_v2g_msg = V2G_UNKNOWN_MSG; // &&
    ctx->evse_v2g_data.session_id = 1;
    ctx->ev_v2g_data.received_session_id = 1;

    ctx->terminate_connection_on_failed_response = true;

    EXPECT_EQ(utils::din_validate_response_code(&tmp, conn.get()), V2G_EVENT_SEND_AND_TERMINATE);
}

TEST_F(DinServerTest, din_validate_response_code_EVENT_SEND_AND_TERMINATE_4) {

    auto tmp = din_responseCodeType_OK_CertificateExpiresSoon;

    ctx->is_connection_terminated = false;

    ctx->stop_hlc = false; //||
    ctx->intl_emergency_shutdown = false;

    ctx->current_v2g_msg = V2G_UNKNOWN_MSG; // &&
    ctx->evse_v2g_data.session_id = 1;
    ctx->ev_v2g_data.received_session_id = 1;

    ctx->terminate_connection_on_failed_response = true;

    EXPECT_EQ(utils::din_validate_response_code(&tmp, conn.get()), V2G_EVENT_SEND_AND_TERMINATE);
}

TEST_F(DinServerTest, din_validate_response_code_EVENT_SEND_AND_TERMINATE_5) {

    auto tmp = din_responseCodeType_OK_CertificateExpiresSoon;

    ctx->is_connection_terminated = false;

    ctx->stop_hlc = false; //||
    ctx->intl_emergency_shutdown = false;

    ctx->current_v2g_msg = V2G_CABLE_CHECK_MSG; // &&
    ctx->evse_v2g_data.session_id = 1;
    ctx->ev_v2g_data.received_session_id = 2;

    ctx->terminate_connection_on_failed_response = true;

    EXPECT_EQ(utils::din_validate_response_code(&tmp, conn.get()), V2G_EVENT_SEND_AND_TERMINATE);
}

TEST_F(DinServerTest, din_validate_response_code_EVENT_SEND_AND_TERMINATE_6) {

    auto tmp = din_responseCodeType_FAILED_SequenceError;

    ctx->is_connection_terminated = false;

    ctx->stop_hlc = false; //||
    ctx->intl_emergency_shutdown = false;

    ctx->current_v2g_msg = V2G_SESSION_SETUP_MSG; // &&
    ctx->evse_v2g_data.session_id = 1;
    ctx->ev_v2g_data.received_session_id = 2;

    ctx->terminate_connection_on_failed_response = true;

    EXPECT_EQ(utils::din_validate_response_code(&tmp, conn.get()), V2G_EVENT_SEND_AND_TERMINATE);
}
TEST_F(DinServerTest, din_validate_response_code_V2G_DC_390) {
    // The response message shall contain the ResponseCode â€œFAILED_SequenceErrorâ€ if the
    // SECC has received an unexpected request message.

    auto given_response_code = din_responseCodeType_OK;
    constexpr auto expected_response_code = din_responseCodeType_FAILED_SequenceError;
    constexpr auto expected_response = V2G_EVENT_NO_EVENT;

    ctx->is_connection_terminated = false;

    ctx->terminate_connection_on_failed_response = false;

    ctx->current_v2g_msg = V2G_UNKNOWN_MSG;

    EXPECT_EQ(utils::din_validate_response_code(&given_response_code, conn.get()), expected_response);
    // given response code should change in the function call
    EXPECT_EQ(given_response_code, expected_response_code);
}

TEST_F(DinServerTest, din_validate_response_code_V2G_DC_391) {
    // The response message shall contain the ResponseCode â€œFAILED_UnknownSessionâ€ if the
    // SessionID in a request message does not match the SessionID provided by the SECC in the SessionSetupRes
    // message.

    auto given_response_code = din_responseCodeType_OK;
    constexpr auto expected_response_code = din_responseCodeType_FAILED_UnknownSession;
    constexpr auto expected_response = V2G_EVENT_NO_EVENT;

    ctx->is_connection_terminated = false;

    ctx->terminate_connection_on_failed_response = false;
    ctx->evse_v2g_data.session_id = 1234;
    ctx->ev_v2g_data.received_session_id = 5678;

    EXPECT_EQ(utils::din_validate_response_code(&given_response_code, conn.get()), expected_response);
    // given response code should change in the function call
    EXPECT_EQ(given_response_code, expected_response_code);
}

TEST_F(DinServerTest, din_validate_response_code_V2G_DC_665) {
    // If the SECC receives a request message that it expects according to the message sequence
    // specified in this chapter, and if the SECC cannot process this request message, e. g. due to
    // errors in the message parameters or due to impeding conditions in the EVSE, the SECC
    // shall:
    // [1.] without any delay, carry out an â€œEVSE-initiated emergency shutdownâ€ as specified in
    // IEC 61851-23, which includes turning off the CP oscillator, if it is turned on,
    // [2.] respond with the corresponding response message with parameter ResponseCode
    // equal to â€œFAILEDâ€, if possible, and
    // [3.] close the TCP connection according to [V2G-DC-116].

    auto given_response_code = din_responseCodeType_FAILED;
    constexpr auto min_expected_response_code = din_responseCodeType_FAILED;
    constexpr auto expected_response = V2G_EVENT_SEND_AND_TERMINATE;

    ctx->is_connection_terminated = false;

    ctx->terminate_connection_on_failed_response = true;

    EXPECT_EQ(utils::din_validate_response_code(&given_response_code, conn.get()), expected_response);
    EXPECT_GE(given_response_code, min_expected_response_code);
}

} // namespace


// ===== tests\evse_securityIntfStub.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright Pionix GmbH and Contributors to EVerest

#ifndef EVSE_SECURITYINTFSTUB_H_
#define EVSE_SECURITYINTFSTUB_H_

#include <iostream>

#include "ModuleAdapterStub.hpp"
#include "generated/types/evse_security.hpp"
#include "utils/types.hpp"
#include <functional>
#include <generated/interfaces/evse_security/Interface.hpp>
#include <optional>
#include <string>

//-----------------------------------------------------------------------------
namespace module::stub {

class evse_securityIntfStub : public evse_securityIntf {
private:
    std::map<const std::string, Result (evse_securityIntfStub::*)(const Requirement& req, const Parameters& args)>
        functions;

public:
    evse_securityIntfStub(ModuleAdapterStub* adapter) :
        evse_securityIntf(adapter, Requirement{"", 0}, "EvseSecurity", std::nullopt) {
        functions["get_verify_file"] = &evse_securityIntfStub::get_verify_file;
        functions["get_leaf_certificate_info"] = &evse_securityIntfStub::get_leaf_certificate_info;
    }
    evse_securityIntfStub(ModuleAdapterStub& adapter) :
        evse_securityIntf(&adapter, Requirement{"", 0}, "EvseSecurity", std::nullopt) {
        functions["get_verify_file"] = &evse_securityIntfStub::get_verify_file;
        functions["get_leaf_certificate_info"] = &evse_securityIntfStub::get_leaf_certificate_info;
    }

    virtual Result call_fn(const Requirement& req, const std::string& str, Parameters args) {
        if (auto it = functions.find(str); it != functions.end()) {
            return std::invoke(it->second, this, req, args);
        }
        std::printf("call_fn (%s)\n", str.c_str());
        return std::nullopt;
    }

    virtual Result get_verify_file(const Requirement& req, const Parameters& args) {
        std::cout << "evse_securityIntf::get_verify_file called" << std::endl;
        return "";
    }

    virtual Result get_leaf_certificate_info(const Requirement& req, const Parameters& args) {
        std::cout << "evse_securityIntf::get_leaf_certificate_info called" << std::endl;
        return "";
    }
};

} // namespace module::stub

#endif // EVSE_SECURITYINTFSTUB_H_


// ===== tests\ISO15118_chargerImplStub.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright Pionix GmbH and Contributors to EVerest

#ifndef ISO15118_CHARGERIMPLSTUB_H_
#define ISO15118_CHARGERIMPLSTUB_H_

#include <iostream>
#include <memory>

#include "ModuleAdapterStub.hpp"

#include <generated/interfaces/ISO15118_charger/Implementation.hpp>

//-----------------------------------------------------------------------------
namespace module::stub {

struct ISO15118_chargerImplStub : public ISO15118_chargerImplBase {
    ISO15118_chargerImplStub(ModuleAdapterStub& adapter) : ISO15118_chargerImplBase(&adapter, "EvseV2G"){};
    ISO15118_chargerImplStub(ModuleAdapterStub* adapter) : ISO15118_chargerImplBase(adapter, "EvseV2G"){};

    virtual void init() {
    }
    virtual void ready() {
    }

    virtual void handle_setup(types::iso15118::EVSEID& evse_id,
                              std::vector<types::iso15118::SupportedEnergyMode>& supported_energy_transfer_modes,
                              types::iso15118::SaeJ2847BidiMode& sae_j2847_mode, bool& debug_mode) {
        std::cout << "ISO15118_chargerImplBase::handle_setup called" << std::endl;
    }
    virtual void handle_set_charging_parameters(types::iso15118::SetupPhysicalValues& physical_values) {
        std::cout << "ISO15118_chargerImplBase::handle_set_charging_parameters called" << std::endl;
    }
    virtual void handle_session_setup(std::vector<types::iso15118::PaymentOption>& payment_options,
                                      bool& supported_certificate_service, bool& central_contract_validation_allowed) {
        std::cout << "ISO15118_chargerImplBase::handle_session_setup called" << std::endl;
    }
    virtual void handle_authorization_response(types::authorization::AuthorizationStatus& authorization_status,
                                               types::authorization::CertificateStatus& certificate_status) {
        std::cout << "ISO15118_chargerImplBase::handle_authorization_response called" << std::endl;
    }
    virtual void handle_ac_contactor_closed(bool& status) {
        std::cout << "ISO15118_chargerImplBase::handle_ac_contactor_closed called" << std::endl;
    }
    virtual void handle_dlink_ready(bool& value) {
        std::cout << "ISO15118_chargerImplBase::handle_dlink_ready called" << std::endl;
    }
    virtual void handle_cable_check_finished(bool& status) {
        std::cout << "ISO15118_chargerImplBase::handle_cable_check_finished called" << std::endl;
    }
    virtual void handle_receipt_is_required(bool& receipt_required) {
        std::cout << "ISO15118_chargerImplBase::handle_receipt_is_required called" << std::endl;
    }
    virtual void handle_stop_charging(bool& stop) {
        std::cout << "ISO15118_chargerImplBase::handle_stop_charging called" << std::endl;
    }
    virtual void handle_pause_charging(bool& pause) {
        std::cout << "ISO15118_chargerImplBase::handle_pause_charging called" << std::endl;
    }
    virtual void handle_update_ac_max_current(double& max_current) {
        std::cout << "ISO15118_chargerImplBase::handle_update_ac_max_current called" << std::endl;
    }
    virtual void handle_update_dc_maximum_limits(types::iso15118::DcEvseMaximumLimits& maximum_limits) {
        std::cout << "ISO15118_chargerImplBase::handle_update_dc_maximum_limits called" << std::endl;
    }
    virtual void handle_update_dc_minimum_limits(types::iso15118::DcEvseMinimumLimits& minimum_limits) {
        std::cout << "ISO15118_chargerImplBase::handle_update_dc_minimum_limits called" << std::endl;
    }
    virtual void handle_update_isolation_status(types::iso15118::IsolationStatus& isolation_status) {
        std::cout << "ISO15118_chargerImplBase::handle_update_isolation_status called" << std::endl;
    }
    virtual void
    handle_update_dc_present_values(types::iso15118::DcEvsePresentVoltageCurrent& present_voltage_current) {
        std::cout << "ISO15118_chargerImplBase::handle_update_dc_present_values called" << std::endl;
    }
    virtual void handle_update_meter_info(types::powermeter::Powermeter& powermeter) {
        std::cout << "ISO15118_chargerImplBase::handle_update_meter_info called" << std::endl;
    }
    virtual void handle_send_error(types::iso15118::EvseError& error) {
        std::cout << "ISO15118_chargerImplBase::handle_send_error called" << std::endl;
    }
    virtual void handle_reset_error() {
        std::cout << "ISO15118_chargerImplBase::handle_reset_error called" << std::endl;
    }
};

} // namespace module::stub

#endif // ISO15118_CHARGERIMPLSTUB_H_


// ===== tests\iso15118_extensionsImplStub.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright Pionix GmbH and Contributors to EVerest

#ifndef ISO15118_EXTENTSIONSIMPLSTUB_H
#define ISO15118_EXTENTSIONSIMPLSTUB_H

#include <iostream>

#include <generated/interfaces/iso15118_extensions/Implementation.hpp>

//-----------------------------------------------------------------------------
namespace module::stub {

class iso15118_extensionsImplStub : public iso15118_extensionsImplBase {
public:
    iso15118_extensionsImplStub() : iso15118_extensionsImplBase(nullptr, "EvseV2G"){};

    virtual void init() {
    }
    virtual void ready() {
    }

    virtual void handle_set_get_certificate_response(types::iso15118::ResponseExiStreamStatus& certificate_response) {
        std::cout << "iso15118_extensionsImplBase::handle_set_get_certificate_response called" << std::endl;
    }
};

} // namespace module::stub

#endif // ISO15118_EXTENTSIONSIMPLSTUB_H


// ===== tests\log.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2020 - 2023 Pionix GmbH and Contributors to EVerest

#include "utest_log.hpp"

#include <cstdarg>
#include <cstdio>

#include <algorithm>
#include <array>
#include <map>

namespace {
std::map<dloglevel_t, std::vector<std::string>> logged_events;

void add_log(dloglevel_t loglevel, const std::string& event) {
    logged_events[loglevel].push_back(event);
}
} // namespace

namespace module::stub {
std::vector<std::string>& get_logs(dloglevel_t loglevel) {
    return logged_events[loglevel];
}

void clear_logs() {
    logged_events.clear();
}

} // namespace module::stub

void dlog_func(const dloglevel_t loglevel, const char* filename, const int linenumber, const char* functionname,
               const char* format, ...) {
    va_list ap;
    std::array<char, 256> buffer;
    va_start(ap, format);
    std::size_t len = std::vsnprintf(buffer.data(), buffer.size(), format, ap);
    va_end(ap);
    if (len > 0) {
        auto s_len = std::min(len, buffer.size());
        std::string event{buffer.data(), s_len};
        (void)std::fprintf(stderr, "log: %s\n", event.c_str());
        add_log(loglevel, event);
    }
}


// ===== tests\openssl_test.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2020 - 2023 Pionix GmbH and Contributors to EVerest

#include "crypto_common.hpp"
#include "gtest/gtest.h"
#include <crypto_openssl.hpp>
#include <cstddef>
#include <cstring>
#include <iso_server.hpp>
#include <openssl/bio.h>
#include <openssl/pem.h>
#include <openssl_util.hpp>

#include <cbv2g/common/exi_bitstream.h>
#include <cbv2g/exi_v2gtp.h> //for V2GTP_HEADER_LENGTHs
#include <cbv2g/iso_2/iso2_msgDefDatatypes.h>
#include <cbv2g/iso_2/iso2_msgDefDecoder.h>
#include <cbv2g/iso_2/iso2_msgDefEncoder.h>

namespace {

template <typename T> constexpr void setCharacters(T& dest, const std::string& s) {
    dest.charactersLen = s.size();
    std::memcpy(&dest.characters[0], s.c_str(), s.size());
}

template <typename T> constexpr void setBytes(T& dest, const std::uint8_t* b, std::size_t len) {
    dest.bytesLen = len;
    std::memcpy(&dest.bytes[0], b, len);
}

struct test_vectors_t {
    const char* input;
    const std::uint8_t digest[32];
};

#if 0
// not used, useful to keep all the exi message test values together
constexpr std::uint8_t sign_test[] = {0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c,
                                      0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55};

constexpr test_vectors_t sha_256_test[] = {
    {"", {0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14, 0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24,
          0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c, 0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55}},
    {"abc", {0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea, 0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23,
             0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c, 0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad}}};

// Test vectors from ISO 15118-2 Section J.2
// checked okay (see iso_priv.pem)
constexpr std::uint8_t iso_private_key[] = {0xb9, 0x13, 0x49, 0x63, 0xf5, 0x1c, 0x44, 0x14, 0x73, 0x84, 0x35,
                                            0x05, 0x7f, 0x97, 0xbb, 0xf1, 0x01, 0x0c, 0xab, 0xcb, 0x8d, 0xbd,
                                            0xe9, 0xc5, 0xd4, 0x81, 0x38, 0x39, 0x6a, 0xa9, 0x4b, 0x9d};
// checked okay (see iso_priv.pem)
constexpr std::uint8_t iso_public_key[] = {0x43, 0xe4, 0xfc, 0x4c, 0xcb, 0x64, 0x39, 0x04, 0x27, 0x9c, 0x7a, 0x5e, 0x65,
                                           0x76, 0xb3, 0x23, 0xe5, 0x5e, 0xc7, 0x9f, 0xf0, 0xe5, 0xa4, 0x05, 0x6e, 0x33,
                                           0x40, 0x84, 0xcb, 0xc3, 0x36, 0xff, 0x46, 0xe4, 0x4c, 0x1a, 0xdd, 0xf6, 0x91,
                                           0x62, 0xe5, 0x19, 0x2c, 0x2a, 0x83, 0xfc, 0x2b, 0xca, 0x9d, 0x8f, 0x46, 0xec,
                                           0xf4, 0xb7, 0x80, 0x67, 0xc2, 0x47, 0x6f, 0x6b, 0x3f, 0x34, 0x60, 0x0e};
#endif

// EXI AuthorizationReq: checked okay (hash computes correctly)
constexpr std::uint8_t iso_exi_a[] = {0x80, 0x04, 0x01, 0x52, 0x51, 0x0c, 0x40, 0x82, 0x9b, 0x7b, 0x6b, 0x29, 0x02,
                                      0x93, 0x0b, 0x73, 0x23, 0x7b, 0x69, 0x02, 0x23, 0x0b, 0xa3, 0x09, 0xe8};

// checked okay
constexpr std::uint8_t iso_exi_a_hash[] = {0xd1, 0xb5, 0xe0, 0x3d, 0x00, 0x65, 0xbe, 0xe5, 0x6b, 0x31, 0x79,
                                           0x84, 0x45, 0x30, 0x51, 0xeb, 0x54, 0xca, 0x18, 0xfc, 0x0e, 0x09,
                                           0x16, 0x17, 0x4f, 0x8b, 0x3c, 0x77, 0xa9, 0x8f, 0x4a, 0xa9};

#if 0
// not used, useful to keep all the exi message test values together
// EXI AuthorizationReq signature block: checked okay (hash computes correctly)
constexpr std::uint8_t iso_exi_b[] = {
    0x80, 0x81, 0x12, 0xb4, 0x3a, 0x3a, 0x38, 0x1d, 0x17, 0x97, 0xbb, 0xbb, 0xbb, 0x97, 0x3b, 0x99, 0x97, 0x37, 0xb9,
    0x33, 0x97, 0xaa, 0x29, 0x17, 0xb1, 0xb0, 0xb7, 0x37, 0xb7, 0x34, 0xb1, 0xb0, 0xb6, 0x16, 0xb2, 0xbc, 0x34, 0x97,
    0xa1, 0xab, 0x43, 0xa3, 0xa3, 0x81, 0xd1, 0x79, 0x7b, 0xbb, 0xbb, 0xb9, 0x73, 0xb9, 0x99, 0x73, 0x7b, 0x93, 0x39,
    0x79, 0x91, 0x81, 0x81, 0x89, 0x79, 0x81, 0xa1, 0x7b, 0xc3, 0x6b, 0x63, 0x23, 0x9b, 0x4b, 0x39, 0x6b, 0x6b, 0x7b,
    0x93, 0x29, 0x1b, 0x2b, 0x1b, 0x23, 0x9b, 0x09, 0x6b, 0x9b, 0x43, 0x09, 0x91, 0xa9, 0xb2, 0x20, 0x62, 0x34, 0x94,
    0x43, 0x10, 0x25, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x77, 0x33, 0x2e, 0x6f, 0x72,
    0x67, 0x2f, 0x54, 0x52, 0x2f, 0x63, 0x61, 0x6e, 0x6f, 0x6e, 0x69, 0x63, 0x61, 0x6c, 0x2d, 0x65, 0x78, 0x69, 0x2f,
    0x48, 0x52, 0xd0, 0xe8, 0xe8, 0xe0, 0x74, 0x5e, 0x5e, 0xee, 0xee, 0xee, 0x5c, 0xee, 0x66, 0x5c, 0xde, 0xe4, 0xce,
    0x5e, 0x64, 0x60, 0x60, 0x62, 0x5e, 0x60, 0x68, 0x5e, 0xf0, 0xda, 0xd8, 0xca, 0xdc, 0xc6, 0x46, 0xe6, 0xd0, 0xc2,
    0x64, 0x6a, 0x6c, 0x84, 0x1a, 0x36, 0xbc, 0x07, 0xa0, 0x0c, 0xb7, 0xdc, 0xad, 0x66, 0x2f, 0x30, 0x88, 0xa6, 0x0a,
    0x3d, 0x6a, 0x99, 0x43, 0x1f, 0x81, 0xc1, 0x22, 0xc2, 0xe9, 0xf1, 0x67, 0x8e, 0xf5, 0x31, 0xe9, 0x55, 0x23, 0x70};
#endif

// checked okay
constexpr std::uint8_t iso_exi_b_hash[] = {0xa4, 0xe9, 0x03, 0xe1, 0x82, 0x43, 0x04, 0x1b, 0x55, 0x4e, 0x11,
                                           0x64, 0x7e, 0x10, 0x1e, 0xd2, 0x5f, 0xc9, 0xf2, 0x15, 0x2a, 0xf4,
                                           0x67, 0x40, 0x14, 0xfe, 0x2a, 0xde, 0xac, 0x1e, 0x1c, 0xf7};

// checked okay (verifies iso_exi_b_hash with iso_priv.pem)
constexpr std::uint8_t iso_exi_sig[] = {0x4c, 0x8f, 0x20, 0xc1, 0x40, 0x0b, 0xa6, 0x76, 0x06, 0xaa, 0x48, 0x11, 0x57,
                                        0x2a, 0x2f, 0x1a, 0xd3, 0xc1, 0x50, 0x89, 0xd9, 0x54, 0x20, 0x36, 0x34, 0x30,
                                        0xbb, 0x26, 0xb4, 0x9d, 0xb1, 0x04, 0xf0, 0x8d, 0xfa, 0x8b, 0xf8, 0x05, 0x5e,
                                        0x63, 0xa4, 0xb7, 0x5a, 0x8d, 0x31, 0x69, 0x20, 0x6f, 0xa8, 0xd5, 0x43, 0x08,
                                        0xba, 0x58, 0xf0, 0x56, 0x6b, 0x96, 0xba, 0xf6, 0x92, 0xce, 0x59, 0x50};

#if 0
// not used, useful to keep all the exi message test values together
const char iso_exi_a_hash_b64[] = "0bXgPQBlvuVrMXmERTBR61TKGPwOCRYXT4s8d6mPSqk=";
const char iso_exi_a_hash_b64_nl[] = "0bXgPQBlvuVrMXmERTBR61TKGPwOCRYXT4s8d6mPSqk=\n";

const char iso_exi_sig_b64[] =
    "TI8gwUALpnYGqkgRVyovGtPBUInZVCA2NDC7JrSdsQTwjfqL+AVeY6S3Wo0xaSBvqNVDCLpY8FZrlrr2ks5ZUA==";
const char iso_exi_sig_b64_nl[] =
    "TI8gwUALpnYGqkgRVyovGtPBUInZVCA2NDC7JrSdsQTwjfqL+AVeY6S3Wo0xaSBv\nqNVDCLpY8FZrlrr2ks5ZUA==\n";
#endif

TEST(openssl, verifyIso) {
    auto* bio = BIO_new_file("iso_priv.pem", "r");
    ASSERT_NE(bio, nullptr);
    auto* pkey = PEM_read_bio_PrivateKey(bio, nullptr, nullptr, nullptr);
    ASSERT_NE(pkey, nullptr);
    BIO_free(bio);

    auto sig = openssl::bn_to_signature(&iso_exi_sig[0], &iso_exi_sig[32]);
    EXPECT_TRUE(openssl::verify(pkey, sig.get(), sig.size(), &iso_exi_b_hash[0], sizeof(iso_exi_b_hash)));
    EVP_PKEY_free(pkey);
}

TEST(isoExi, signature) {
    // The message is:
    //   header { SessionID, Signature}
    //   body { AuthorizationReq }
    // the test vector doesn't include the entire encoded message

    auto* bio = BIO_new_file("iso_priv.pem", "r");
    ASSERT_NE(bio, nullptr);
    auto* pkey = PEM_read_bio_PrivateKey(bio, nullptr, nullptr, nullptr);
    ASSERT_NE(pkey, nullptr);
    BIO_free(bio);

    // decode the test vector AuthorizationReq
    struct iso2_exiFragment exi_a {};
    init_iso2_exiFragment(&exi_a);
    init_iso2_AuthorizationReqType(&exi_a.AuthorizationReq);

    exi_bitstream_t stream;
    exi_bitstream_init(&stream, const_cast<std::uint8_t*>(&iso_exi_a[0]), sizeof(iso_exi_a), 0, nullptr);
    EXPECT_EQ(decode_iso2_exiFragment(&stream, &exi_a), 0);

    // manually populate the Signature structure
    struct iso2_SignatureType sig {};
    init_iso2_SignatureType(&sig);

    // SignedInfo
    setCharacters(sig.SignedInfo.CanonicalizationMethod.Algorithm, "http://www.w3.org/TR/canonical-exi/");
    setCharacters(sig.SignedInfo.SignatureMethod.Algorithm, "http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256");
    sig.SignedInfo.Reference.arrayLen = 1;
    sig.SignedInfo.Reference.array[0].URI_isUsed = 1;
    setCharacters(sig.SignedInfo.Reference.array[0].URI, "#ID1");
    sig.SignedInfo.Reference.array[0].Transforms_isUsed = 1;
    setCharacters(sig.SignedInfo.Reference.array[0].Transforms.Transform.Algorithm,
                  "http://www.w3.org/TR/canonical-exi/");
    setCharacters(sig.SignedInfo.Reference.array[0].DigestMethod.Algorithm, "http://www.w3.org/2001/04/xmlenc#sha256");
    setBytes(sig.SignedInfo.Reference.array[0].DigestValue, &iso_exi_a_hash[0], ::openssl::sha_256_digest_size);
    // SignatureValue
    setBytes(sig.SignatureValue.CONTENT, &iso_exi_sig[0], ::openssl::signature_size);
    EXPECT_TRUE(crypto::openssl::check_iso2_signature(&sig, pkey, &exi_a));

    EVP_PKEY_free(pkey);
}

} // namespace


// ===== tests\requirement.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2020 - 2023 Pionix GmbH and Contributors to EVerest

#include <string>

#include "utils/types.hpp"

bool operator<(const Requirement& lhs, const Requirement& rhs) {
    return true;
}


// ===== tests\sdp_test.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright Pionix GmbH and Contributors to EVerest
#include <gtest/gtest.h>
#include <sdp.hpp>

namespace {

class SdpTest : public testing::Test {
protected:
    SdpTest() {
    }
};

TEST_F(SdpTest, sdp_write_header) {
    uint8_t buffer[20];
    uint16_t payload_type = 0x9001;
    uint32_t length = 367;

    EXPECT_EQ(sdp_write_header(buffer, payload_type, length), 8);

    EXPECT_EQ(buffer[0], 0x01);
    EXPECT_EQ(buffer[1], 0xFE);
    EXPECT_EQ(buffer[2], 0x90);
    EXPECT_EQ(buffer[3], 0x01);
    EXPECT_EQ(buffer[4], 0x00);
    EXPECT_EQ(buffer[5], 0x00);
    EXPECT_EQ(buffer[6], 0x01);
    EXPECT_EQ(buffer[7], 0x6F);
}

} // namespace


// ===== tests\utest_log.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2020 - 2023 Pionix GmbH and Contributors to EVerest

#pragma once

#include <log.hpp>

#include <string>
#include <vector>

namespace module::stub {
std::vector<std::string>& get_logs(dloglevel_t loglevel);
void clear_logs();

} // namespace module::stub


// ===== tests\v2g_ctx_test.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright Pionix GmbH and Contributors to EVerest
#include <memory>
#include <v2g_ctx.hpp>

#include "ISO15118_chargerImplStub.hpp"
#include "ModuleAdapterStub.hpp"
#include "evse_securityIntfStub.hpp"
#include "iso15118_extensionsImplStub.hpp"
#include "utest_log.hpp"
#include "v2g.hpp"

#include <gtest/gtest.h>

namespace {

struct v2g_contextDeleter {
    void operator()(v2g_context* ptr) const {
        v2g_ctx_free(ptr);
    };
};

class V2gCtxTest : public testing::Test {
protected:
    std::unique_ptr<v2g_context, v2g_contextDeleter> ctx;
    module::stub::QuietModuleAdapterStub adapter;
    module::stub::ISO15118_chargerImplStub charger;
    module::stub::evse_securityIntfStub security;
    module::stub::iso15118_extensionsImplStub extensions;

    V2gCtxTest() : charger(adapter), security(adapter) {
    }

    void v2g_ctx_init_charging_state_cleared() {
        // checks try to match the order is v2g.hpp

        EXPECT_EQ(ctx->last_v2g_msg, V2G_UNKNOWN_MSG);
        EXPECT_EQ(ctx->current_v2g_msg, V2G_UNKNOWN_MSG);
        EXPECT_EQ(ctx->state, 0);

        // not changed
        // is_dc_charger
        // debugMode
        // supported_protocols

        EXPECT_EQ(ctx->selected_protocol, V2G_UNKNOWN_PROTOCOL);
        EXPECT_FALSE(ctx->intl_emergency_shutdown);
        EXPECT_FALSE(ctx->stop_hlc);

        // ctx->is_connection_terminated is updated rather than cleared

        // not changed
        // terminate_connection_on_failed_response
        // contactor_is_closed

        // many items in session not reset
        EXPECT_FALSE(ctx->session.renegotiation_required);
        EXPECT_FALSE(ctx->session.is_charging);
    }

    void SetUp() override {
        auto ptr = v2g_ctx_create(&charger, &extensions, &security);
        ctx = std::unique_ptr<v2g_context, v2g_contextDeleter>(ptr, v2g_contextDeleter());
        module::stub::clear_logs();
    }

    void TearDown() override {
    }
};

TEST(RunFirst, v2g_ctx_init_charging_values) {
    // must not be part of V2gCtxTest
    // V2gCtxTest::SetUp() creates the v2g_context which would be the 1st
    // call to v2g_ctx_init_charging_values()

    // only called from v2g_ctx_init_charging_session()
    // which is called from v2g_ctx_create()

    // note v2g_ctx_init_charging_values() has a static bool so it
    // performs different tidyup after the first time it is called

    v2g_context ctx;
    ctx.evse_v2g_data.charge_service.FreeService = 9;
    v2g_ctx_init_charging_values(&ctx);
    EXPECT_EQ(ctx.evse_v2g_data.charge_service.FreeService, 0);
    ctx.evse_v2g_data.charge_service.FreeService = 10;
    v2g_ctx_init_charging_values(&ctx);
    EXPECT_EQ(ctx.evse_v2g_data.charge_service.FreeService, 10);

    // reset back to a valid value as it will never be reset
    ctx.evse_v2g_data.charge_service.FreeService = 0;
}

TEST_F(V2gCtxTest, v2g_ctx_init_charging_stateTrue) {
    // called on session start in v2g_handle_connection()

    ctx->last_v2g_msg = V2G_CABLE_CHECK_MSG;
    ctx->current_v2g_msg = V2G_CHARGE_PARAMETER_DISCOVERY_MSG;
    ctx->state = 10;
    ctx->selected_protocol = V2G_PROTO_DIN70121;
    ctx->intl_emergency_shutdown = true;
    ctx->stop_hlc = true;
    ctx->session.renegotiation_required = true;
    ctx->session.is_charging = true;

    v2g_ctx_init_charging_state(ctx.get(), true);

    v2g_ctx_init_charging_state_cleared();
    EXPECT_TRUE(ctx->is_connection_terminated);
}

TEST_F(V2gCtxTest, v2g_ctx_init_charging_stateFalse) {
    // called on session end in v2g_handle_connection()

    ctx->last_v2g_msg = V2G_CABLE_CHECK_MSG;
    ctx->current_v2g_msg = V2G_CHARGE_PARAMETER_DISCOVERY_MSG;
    ctx->state = 10;
    ctx->selected_protocol = V2G_PROTO_DIN70121;
    ctx->intl_emergency_shutdown = true;
    ctx->stop_hlc = true;
    ctx->session.renegotiation_required = true;
    ctx->session.is_charging = true;

    v2g_ctx_init_charging_state(ctx.get(), false);

    v2g_ctx_init_charging_state_cleared();
    EXPECT_FALSE(ctx->is_connection_terminated);
}

#if 0
// v2g_ctx_init_charging_session() is a trivial implementation
TEST_F(V2gCtxTest, v2g_ctx_init_charging_sessionTrue) {
    // called in connection_teardown()
    // calls v2g_ctx_init_charging_state
    // calls v2g_ctx_init_charging_values
}

TEST_F(V2gCtxTest, v2g_ctx_init_charging_sessionFalse) {
    // called in connection_teardown()
    // calls v2g_ctx_init_charging_state
    // calls v2g_ctx_init_charging_values
}
#endif

TEST(valgrind, memcheck) {
    GTEST_SKIP() << "pthreads result in valgrind reporting errors";
    /*
     * v2g_ctx_free() doesn't stop or wait for threads to finish (no join)
     * hence there is access to free'd memory reported.
     *
     * ==2136== LEAK SUMMARY:
     * ==2136==    definitely lost: 0 bytes in 0 blocks
     * ==2136==    indirectly lost: 0 bytes in 0 blocks
     * ==2136==      possibly lost: 304 bytes in 1 blocks
     * ==2136==    still reachable: 80 bytes in 2 blocks
     * ==2136==         suppressed: 0 bytes in 0 blocks
     */

    // run via valgrind to ensure that malloc/free are working
    module::stub::QuietModuleAdapterStub adapter;
    module::stub::ISO15118_chargerImplStub charger(adapter);
    module::stub::evse_securityIntfStub security(adapter);
    module::stub::iso15118_extensionsImplStub extensions;
    auto ptr = v2g_ctx_create(&charger, &extensions, &security);
    v2g_ctx_free(ptr);
}

} // namespace


// ===== tests\v2g_main.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2020 - 2023 Pionix GmbH and Contributors to EVerest

/*
 * testing options
 * openssl s_client -connect [fe80::ae91:a1ff:fec9:a947%3]:64109 -verify 2 -CAfile server_root_cert.pem -cert
 * client_cert.pem -cert_chain client_chain.pem -key client_priv.pem -verify_return_error -verify_hostname
 * evse.pionix.de -status
 */

#include <array>
#include <cassert>
#include <chrono>
#include <cstdlib>
#include <iostream>
#include <optional>
#include <thread>
#include <unistd.h>

#include "ISO15118_chargerImplStub.hpp"
#include "ModuleAdapterStub.hpp"
#include "evse_securityIntfStub.hpp"
#include "iso15118_extensionsImplStub.hpp"

#include <connection.hpp>
#include <tls.hpp>
#include <v2g_ctx.hpp>

using namespace std::chrono_literals;

// needs to be in the global namespace
int v2g_handle_connection(struct v2g_connection* conn) {
    assert(conn != nullptr);
    assert(conn->read != nullptr);
    assert(conn->write != nullptr);

    std::array<unsigned char, 1024> buffer{};
    bool bExit = false;
    while (!bExit) {
        const ssize_t readbytes = conn->read(conn, buffer.data(), buffer.size());
        if (readbytes > 0) {
            const ssize_t writebytes = conn->write(conn, buffer.data(), readbytes);
            if (writebytes <= 0) {
                bExit = true;
            }
        } else if (readbytes < 0) {
            bExit = true;
        }
    }
    return 0;
}

namespace {

const char* interface;

void parse_options(int argc, char** argv) {
    interface = nullptr;
    int c;

    while ((c = getopt(argc, argv, "hi:")) != -1) {
        switch (c) {
        case 'i':
            interface = optarg;
            break;
        case 'h':
        case '?':
            std::cout << "Usage: " << argv[0] << " -i <interface name>" << std::endl;
            exit(1);
            break;
        default:
            exit(2);
        }
    }

    if (interface == nullptr) {
        std::cerr << "Error: " << argv[0] << " requires -i <interface name>" << std::endl;
        exit(3);
    }
}

// EvseSecurity "implementation"
struct EvseSecurity : public module::stub::evse_securityIntfStub {
    EvseSecurity(module::stub::ModuleAdapterStub& adapter) : module::stub::evse_securityIntfStub(&adapter) {
    }

    Result get_verify_file(const Requirement& req, const Parameters& args) override {
        return "client_root_cert.pem";
    }

    virtual Result get_leaf_certificate_info(const Requirement& req, const Parameters& args) override {
        // using types::evse_security::CertificateHashDataType;
        using types::evse_security::CertificateInfo;
        using types::evse_security::CertificateOCSP;
        using types::evse_security::GetCertificateInfoResult;
        using types::evse_security::GetCertificateInfoStatus;
        using types::evse_security::HashAlgorithm;

        CertificateInfo cert_info;
        cert_info.key = "server_priv.pem";
        cert_info.certificate = "server_chain.pem";
        cert_info.certificate_count = 2;
        cert_info.ocsp = {{
                              {HashAlgorithm::SHA256},
                              {"ocsp_response.der"},
                          },
                          {
                              {HashAlgorithm::SHA256},
                              {"ocsp_response.der"},
                          }};

        const GetCertificateInfoResult res = {
            GetCertificateInfoStatus::Accepted,
            cert_info,
        };
        json jres = res;
        return jres;
    }
};

} // namespace

int main(int argc, char** argv) {
    parse_options(argc, argv);

    tls::Server tls_server;
    module::stub::ModuleAdapterStub adapter;
    module::stub::ISO15118_chargerImplStub charger(adapter);
    EvseSecurity security(adapter);
    module::stub::iso15118_extensionsImplStub extensions;

    auto* ctx = v2g_ctx_create(&charger, &extensions, &security);

    if (ctx == nullptr) {
        std::cerr << "failed to create context" << std::endl;
    } else {
        ctx->tls_server = &tls_server;
        ctx->if_name = interface;
        ctx->tls_security = TLS_SECURITY_FORCE;
        ctx->is_connection_terminated = false;

        std::thread stop([ctx]() {
            // there is a 60 second read timeout in connection.cpp
            std::this_thread::sleep_for(75s);
            std::cout << "shutdown" << std::endl;
            ctx->is_connection_terminated = true;
            ctx->shutdown = true;
        });

        std::cout << "connection_init" << std::endl;
        if (::connection_init(ctx) != 0) {
            std::cerr << "connection_init failed" << std::endl;
        } else {
            std::cout << "connection_init started" << std::endl;
        }

        std::cout << "connection_start_servers " << std::endl;
        if (::connection_start_servers(ctx) != 0) {
            std::cerr << "connection_start_servers failed" << std::endl;
        } else {
            std::cout << "connection_start_servers started" << std::endl;
        }

        stop.join();
        tls::ServerConnection::wait_all_closed();

        // wait for v2g_ctx_start_events thread to stop
        std::this_thread::sleep_for(2s);
        v2g_ctx_free(ctx);
    }

    return 0;
}


// ===== tools.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2022-2023 chargebyte GmbH
// Copyright (C) 2022-2023 Contributors to EVerest
#include "tools.hpp"
#include "log.hpp"
#include <arpa/inet.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <ifaddrs.h>
#include <iomanip>
#include <math.h>
#include <sstream>
#include <stdio.h>
#include <string.h>
#include <string>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>

ssize_t safe_read(int fd, void* buf, size_t count) {
    for (;;) {
        ssize_t result = read(fd, buf, count);

        if (result >= 0)
            return result;
        else if (errno == EINTR)
            continue;
        else
            return result;
    }
}

int generate_random_data(void* dest, size_t dest_len) {
    size_t len = 0;
    int fd;

    fd = open("/dev/urandom", O_RDONLY);
    if (fd == -1)
        return -1;

    while (len < dest_len) {
        ssize_t rv = safe_read(fd, dest, dest_len);

        if (rv < 0) {
            close(fd);
            return -1;
        }

        len += rv;
    }

    close(fd);
    return 0;
}

const char* choose_first_ipv6_interface() {
    struct ifaddrs *ifaddr, *ifa;
    char buffer[INET6_ADDRSTRLEN];

    if (getifaddrs(&ifaddr) == -1)
        return NULL;

    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
        if (!ifa->ifa_addr)
            continue;

        if (ifa->ifa_addr->sa_family == AF_INET6) {
            inet_ntop(AF_INET6, &ifa->ifa_addr->sa_data, buffer, sizeof(buffer));
            if (strstr(buffer, "fe80") != NULL) {
                return ifa->ifa_name;
            }
        }
    }
    dlog(DLOG_LEVEL_ERROR, "No necessary IPv6 link-local address was found!");
    return NULL;
}

int get_interface_ipv6_address(const char* if_name, enum Addr6Type type, struct sockaddr_in6* addr) {
    struct ifaddrs *ifaddr, *ifa;
    int rv = -1;

    // If using loopback device, accept any address
    // (lo usually does not have a link local address)
    if (strcmp(if_name, "lo") == 0) {
        type = ADDR6_TYPE_UNPSEC;
    }

    if (getifaddrs(&ifaddr) == -1)
        return -1;

    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
        if (!ifa->ifa_addr)
            continue;

        if (ifa->ifa_addr->sa_family != AF_INET6)
            continue;

        if (strcmp(ifa->ifa_name, if_name) != 0)
            continue;

        /* on Linux the scope_id is interface index for link-local addresses */
        switch (type) {
        case ADDR6_TYPE_GLOBAL: /* no link-local address requested */
            if ((reinterpret_cast<struct sockaddr_in6*>(ifa->ifa_addr))->sin6_scope_id != 0)
                continue;
            break;

        case ADDR6_TYPE_LINKLOCAL: /* link-local address requested */
            if ((reinterpret_cast<struct sockaddr_in6*>(ifa->ifa_addr))->sin6_scope_id == 0)
                continue;
            break;

        default: /* any address of the interface requested */
            /* use first found */
            break;
        }

        memcpy(addr, ifa->ifa_addr, sizeof(*addr));

        rv = 0;
        goto out;
    }

out:
    freeifaddrs(ifaddr);
    return rv;
}

#define NSEC_PER_SEC 1000000000L

void set_normalized_timespec(struct timespec* ts, time_t sec, int64_t nsec) {
    while (nsec >= NSEC_PER_SEC) {
        nsec -= NSEC_PER_SEC;
        ++sec;
    }
    while (nsec < 0) {
        nsec += NSEC_PER_SEC;
        --sec;
    }
    ts->tv_sec = sec;
    ts->tv_nsec = nsec;
}

struct timespec timespec_add(struct timespec lhs, struct timespec rhs) {
    struct timespec ts_delta;

    set_normalized_timespec(&ts_delta, lhs.tv_sec + rhs.tv_sec, lhs.tv_nsec + rhs.tv_nsec);

    return ts_delta;
}

struct timespec timespec_sub(struct timespec lhs, struct timespec rhs) {
    struct timespec ts_delta;

    set_normalized_timespec(&ts_delta, lhs.tv_sec - rhs.tv_sec, lhs.tv_nsec - rhs.tv_nsec);

    return ts_delta;
}

void timespec_add_ms(struct timespec* ts, long long msec) {
    long long sec = msec / 1000;

    set_normalized_timespec(ts, ts->tv_sec + sec, ts->tv_nsec + (msec - sec * 1000) * 1000 * 1000);
}

long long timespec_to_ms(struct timespec ts) {
    return ((long long)ts.tv_sec * 1000) + (ts.tv_nsec / 1000000);
}

long long int getmonotonictime() {
    struct timespec time;
    clock_gettime(CLOCK_MONOTONIC, &time);
    return time.tv_sec * 1000 + time.tv_nsec / 1000000;
}

double calc_physical_value(const int16_t& value, const int8_t& multiplier) {
    return static_cast<double>(value * pow(10.0, multiplier));
}

types::iso15118::HashAlgorithm convert_to_hash_algorithm(const types::evse_security::HashAlgorithm hash_algorithm) {
    switch (hash_algorithm) {
    case types::evse_security::HashAlgorithm::SHA256:
        return types::iso15118::HashAlgorithm::SHA256;
    case types::evse_security::HashAlgorithm::SHA384:
        return types::iso15118::HashAlgorithm::SHA384;
    case types::evse_security::HashAlgorithm::SHA512:
        return types::iso15118::HashAlgorithm::SHA512;
    default:
        throw std::runtime_error(
            "Could not convert types::evse_security::HashAlgorithm to types::iso15118::HashAlgorithm");
    }
}

std::vector<types::iso15118::CertificateHashDataInfo>
convert_to_certificate_hash_data_info_vector(const types::evse_security::OCSPRequestDataList& ocsp_request_data_list) {
    std::vector<types::iso15118::CertificateHashDataInfo> certificate_hash_data_info_vec;
    for (const auto& ocsp_request_data : ocsp_request_data_list.ocsp_request_data_list) {
        if (ocsp_request_data.responder_url.has_value() and ocsp_request_data.certificate_hash_data.has_value()) {
            types::iso15118::CertificateHashDataInfo certificate_hash_data;
            certificate_hash_data.hashAlgorithm =
                convert_to_hash_algorithm(ocsp_request_data.certificate_hash_data.value().hash_algorithm);
            certificate_hash_data.issuerNameHash = ocsp_request_data.certificate_hash_data.value().issuer_name_hash;
            certificate_hash_data.issuerKeyHash = ocsp_request_data.certificate_hash_data.value().issuer_key_hash;
            certificate_hash_data.serialNumber = ocsp_request_data.certificate_hash_data.value().serial_number;
            certificate_hash_data.responderURL = ocsp_request_data.responder_url.value();
            certificate_hash_data_info_vec.push_back(certificate_hash_data);
        }
    }
    return certificate_hash_data_info_vec;
}


// ===== tools.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2022-2023 chargebyte GmbH
// Copyright (C) 2022-2023 Contributors to EVerest
#ifndef TOOLS_H
#define TOOLS_H

#include <generated/types/evse_security.hpp>
#include <generated/types/iso15118.hpp>
#include <netinet/in.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <string>
#include <sys/time.h>
#include <time.h>
#include <vector>

#define MAX_FILE_NAME_LENGTH 100
#define MAX_PKI_CA_LENGTH    4 /* leaf up to root certificate */

#ifndef ROUND_UP
#define ROUND_UP(N, S) ((((N) + (S)-1) / (S)) * (S))
#endif

#ifndef ROUND_UP_ELEMENTS
#define ROUND_UP_ELEMENTS(N, S) (((N) + (S)-1) / (S))
#endif

int generate_random_data(void* dest, size_t dest_len);

enum Addr6Type {
    ADDR6_TYPE_UNPSEC = -1,
    ADDR6_TYPE_GLOBAL = 0,
    ADDR6_TYPE_LINKLOCAL = 1,
};

const char* choose_first_ipv6_interface();
int get_interface_ipv6_address(const char* if_name, enum Addr6Type type, struct sockaddr_in6* addr);

void set_normalized_timespec(struct timespec* ts, time_t sec, int64_t nsec);
struct timespec timespec_sub(struct timespec lhs, struct timespec rhs);
struct timespec timespec_add(struct timespec lhs, struct timespec rhs);
void timespec_add_ms(struct timespec* ts, long long msec);
long long timespec_to_ms(struct timespec ts);
long long int getmonotonictime(void);

/*!
 *  \brief calc_physical_value This function calculates the physical value consists on a value and multiplier.
 *  \param value is the value of the physical value
 *  \param multiplier is the multiplier of the physical value
 *  \return Returns the physical value
 */
double calc_physical_value(const int16_t& value, const int8_t& multiplier);

/**
 * \brief convert the given \p hash_algorithm to type types::iso15118::HashAlgorithm
 * \param hash_algorithm
 * \return types::iso15118::HashAlgorithm
 */
types::iso15118::HashAlgorithm convert_to_hash_algorithm(const types::evse_security::HashAlgorithm hash_algorithm);

/**
 * \brief convert the given \p ocsp_request_data_list to std::vector<types::iso15118::CertificateHashDataInfo>
 * \param ocsp_request_data_list
 * \return std::vector<types::iso15118::CertificateHashDataInfo>
 */
std::vector<types::iso15118::CertificateHashDataInfo>
convert_to_certificate_hash_data_info_vector(const types::evse_security::OCSPRequestDataList& ocsp_request_data_list);
#endif /* TOOLS_H */


// ===== v2g.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2022-2023 chargebyte GmbH
// Copyright (C) 2022-2023 Contributors to EVerest
#ifndef V2G_H
#define V2G_H

#include <generated/interfaces/ISO15118_charger/Implementation.hpp>
#include <generated/interfaces/evse_security/Interface.hpp>
#include <generated/interfaces/iso15118_extensions/Implementation.hpp>

#include <atomic>
#include <cstdint>
#include <netinet/in.h>
#include <pthread.h>
#include <vector>

#include <openssl_util.hpp>
#include <tls.hpp>

#include <cbv2g/app_handshake/appHand_Datatypes.h>
#include <cbv2g/common/exi_basetypes.h>
#include <cbv2g/common/exi_bitstream.h>
#include <cbv2g/din/din_msgDefDatatypes.h>
#include <cbv2g/iso_2/iso2_msgDefDatatypes.h>

#include <event2/event.h>
#include <event2/thread.h>

/* timeouts in milliseconds */
#define V2G_SEQUENCE_TIMEOUT_60S              60000 /* [V2G2-443] et.al. */
#define V2G_SEQUENCE_TIMEOUT_10S              10000
#define V2G_CP_STATE_B_TO_C_D_TIMEOUT         250  /* [V2G2-847] */
#define V2G_CP_STATE_B_TO_C_D_TIMEOUT_RELAXED 500  /* [V2G2-847] */
#define V2G_CP_STATE_C_D_TO_B_TIMEOUT         250  /* [V2G2-848] */
#define V2G_CONTACTOR_CLOSE_TIMEOUT           3000 /* [V2G2-862] [V2G2-865] 4.5 s for PowerDeliveryRes */
#define V2G_COMMUNICATION_SETUP_TIMEOUT                                                                                \
    18000 /* [V2G2-723] [V2G2-029] [V2G2-032] [V2G2-714] [V2G2-716] V2G_SECC_CommunicationSetup_Performance_Time */
#define V2G_CPSTATE_DETECTION_TIMEOUT                                                                                  \
    1500 /* [V2G-DC-547] not (yet) defined for ISO and not implemented, but may be implemented */
#define V2G_CPSTATE_DETECTION_TIMEOUT_RELAXED                                                                          \
    3000 /* [V2G-DC-547] not (yet) defined for ISO and not implemented, but may be implemented */

#define SA_SCHEDULE_DURATION 86400

#define ISO_15118_2013_MSG_DEF "urn:iso:15118:2:2013:MsgDef"
#define ISO_15118_2013_MAJOR   2

#define ISO_15118_2010_MSG_DEF "urn:iso:15118:2:2010:MsgDef"
#define ISO_15118_2010_MAJOR   1

#define DIN_70121_MSG_DEF "urn:din:70121:2012:MsgDef"
#define DIN_70121_MAJOR   2

#define EVSE_LEAF_KEY_FILE_NAME "CPO_EVSE_LEAF.key"
#define EVSE_PROV_KEY_FILE_NAME "PROV_LEAF.key"
#define MO_ROOT_CRT_NAME        "MO_ROOT_CRT"
#define V2G_ROOT_CRT_NAME       "V2G_ROOT_CRT"
#define MAX_V2G_ROOT_CERTS      10
#define MAX_KEY_PW_LEN          32
#define FORCE_PUB_MSG           25 // max msg cycles when topics values must be udpated
#define MAX_PCID_LEN            17

#define DEFAULT_BUFFER_SIZE 8192

#define DEBUG 1

enum tls_security_level {
    TLS_SECURITY_ALLOW = 0,
    TLS_SECURITY_PROHIBIT,
    TLS_SECURITY_FORCE
};

enum v2g_event {
    V2G_EVENT_NO_EVENT = 0,
    V2G_EVENT_TERMINATE_CONNECTION, // Terminate the connection immediately
    V2G_EVENT_SEND_AND_TERMINATE,   // Send next msg and terminate the connection
    V2G_EVENT_SEND_RECV_EXI_MSG,    // If msg must not be exi-encoded and can be sent directly
    V2G_EVENT_IGNORE_MSG            // Received message can't be handled
};

enum v2g_protocol {
    V2G_PROTO_DIN70121 = 0,
    V2G_PROTO_ISO15118_2010,
    V2G_PROTO_ISO15118_2013,
    V2G_PROTO_ISO15118_2015,
    V2G_UNKNOWN_PROTOCOL
};

/* ISO 15118 table 105 */
enum v2g_service {
    V2G_SERVICE_ID_CHARGING = 1,
    V2G_SERVICE_ID_CERTIFICATE = 2,
    V2G_SERVICE_ID_INTERNET = 3,
    V2G_SERVICE_ID_USECASEINFORMATION = 4,
};

/*!
 * \brief The charging_phase enum to identify the actual charing phase.
 */
enum charging_phase {
    PHASE_INIT = 0,
    PHASE_AUTH,
    PHASE_PARAMETER,
    PHASE_ISOLATION,
    PHASE_PRECHARGE,
    PHASE_CHARGE,
    PHASE_WELDING,
    PHASE_STOP,
    PHASE_LENGTH
};

/*!
 * \brief The res_msg_ids enum is a list of response msg ids
 */
enum V2gMsgTypeId {
    V2G_SUPPORTED_APP_PROTOCOL_MSG = 0,
    V2G_SESSION_SETUP_MSG,
    V2G_SERVICE_DISCOVERY_MSG,
    V2G_SERVICE_DETAIL_MSG,
    V2G_PAYMENT_SERVICE_SELECTION_MSG,
    V2G_PAYMENT_DETAILS_MSG,
    V2G_AUTHORIZATION_MSG,
    V2G_CHARGE_PARAMETER_DISCOVERY_MSG,
    V2G_METERING_RECEIPT_MSG,
    V2G_CERTIFICATE_UPDATE_MSG,
    V2G_CERTIFICATE_INSTALLATION_MSG,
    V2G_CHARGING_STATUS_MSG,
    V2G_CABLE_CHECK_MSG,
    V2G_PRE_CHARGE_MSG,
    V2G_POWER_DELIVERY_MSG,
    V2G_CURRENT_DEMAND_MSG,
    V2G_WELDING_DETECTION_MSG,
    V2G_SESSION_STOP_MSG,
    V2G_UNKNOWN_MSG
};

/* EVSE ID */
struct v2g_evse_id {
    uint8_t bytes[iso2_EVSEID_CHARACTER_SIZE];
    uint16_t bytesLen;
};

/* Meter ID */
struct v2g_meter_id {
    uint8_t bytes[iso2_MeterID_CHARACTER_SIZE];
    uint16_t bytesLen;
};

/* Struct for tls-session-log-key tracing */
typedef struct keylogDebugCtx {
    FILE* file;
    bool inClientRandom;
    bool inMasterSecret;
    uint8_t hexdumpLinesToProcess;
    int udp_socket;
    std::string udp_buffer;
} keylogDebugCtx;

struct SAE_Bidi_Data {
    bool enabled_sae_v2h;
    bool enabled_sae_v2g;
    int8_t sae_v2h_minimal_soc;
    bool discharging;
};

/**
 * Abstracts a charging port, i.e. a power outlet in this daemon.
 *
 * **** NOTE ****
 * Be very careful about adding C++ objects since constructors and
 * destructors are not called. (see v2g_ctx_create() and calloc)
 */
struct v2g_context {
    std::atomic_bool shutdown;

    evse_securityIntf* r_security;
    ISO15118_chargerImplBase* p_charger;
    iso15118_extensionsImplBase* p_extensions;

    struct event_base* event_base;
    pthread_t event_thread;

    const char* if_name;
    struct sockaddr_in6* local_tcp_addr;
    struct sockaddr_in6* local_tls_addr;

    std::string tls_key_logging_path;

    uint32_t network_read_timeout;     /* in milli seconds */
    uint32_t network_read_timeout_tls; /* in milli seconds */

    enum tls_security_level tls_security;

    int sdp_socket;
    int tcp_socket;

    int udp_port;
    int udp_socket;

    pthread_t tcp_thread;

    struct {
        int fd;
    } tls_socket;
    tls::Server* tls_server;

    bool tls_key_logging;

    pthread_mutex_t mqtt_lock;
    pthread_cond_t mqtt_cond;
    pthread_condattr_t mqtt_attr;

    struct {
        float evse_ac_current_limit; // default is 0
    } basic_config;                  // This config will not reseted after beginning of a new charging session

    /* actual charging state */
    enum V2gMsgTypeId last_v2g_msg;    /* holds the current v2g msg type */
    enum V2gMsgTypeId current_v2g_msg; /* holds the last v2g msg type */
    int state;                         /* holds the current state id */
    bool is_dc_charger;         /* Is set to true if it is a DC charger. Value is configured after configuration of the
                                   supported energy type */
    bool debugMode;             /* To activate/deactivate the debug mode */
    int8_t supported_protocols; /* Is an bit mask and holds the supported app protocols. See v2g_protocol enum */
    enum v2g_protocol selected_protocol; /* Holds the selected protocole after supported app protocol */
    std::atomic<bool>
        intl_emergency_shutdown; /* Is set to true if an internal emergency_shutdown has occurred (send failed response,
                                    configure emergency shutdown in EVSEStatus and close tcp connection) */
    std::atomic_bool stop_hlc; /* is set to true if a shutdown of the charging session should be initiated (send failed
                      response and close tcp connection) */
    std::atomic_bool is_connection_terminated; /* Is set to true if the connection is terminated (CP State A/F, shutdown
                                      immediately without response message) */
    std::atomic<bool> terminate_connection_on_failed_response;
    std::atomic<bool> contactor_is_closed; /* Actual contactor state */

    struct {
        bool meter_info_is_used;
        uint64_t meter_reading;
        struct v2g_meter_id meter_id;
    } meter_info;

    struct {
        /* EVSE V2G values */
        uint64_t session_id; // Is the evse session id, generated by the evse. This id shall not change during a V2G
                             // Communication Session.
        uint32_t notification_max_delay;
        uint8_t evse_isolation_status;
        unsigned int evse_isolation_status_is_used;
        uint8_t evse_notification;
        uint8_t evse_status_code[PHASE_LENGTH];
        uint8_t evse_processing[PHASE_LENGTH];
        struct v2g_evse_id evse_id;
        unsigned int date_time_now_is_used;
        struct iso2_ChargeServiceType charge_service;
        std::vector<iso2_ServiceType> evse_service_list{};
        struct iso2_ServiceParameterListType service_parameter_list[iso2_ServiceType_8_ARRAY_SIZE];

        struct iso2_SAScheduleListType evse_sa_schedule_list;
        bool evse_sa_schedule_list_is_used;

        iso2_paymentOptionType payment_option_list[iso2_paymentOptionType_2_ARRAY_SIZE];
        uint8_t payment_option_list_len;
        bool central_contract_validation_allowed;

        bool cert_install_status;
        std::string cert_install_res_b64_buffer;

        // AC parameter
        int rcd;
        int receipt_required;

        // evse power electronic values
        struct iso2_PhysicalValueType evse_current_regulation_tolerance;
        unsigned int evse_current_regulation_tolerance_is_used;
        struct iso2_PhysicalValueType evse_energy_to_be_delivered;
        unsigned int evse_energy_to_be_delivered_is_used;
        struct iso2_PhysicalValueType evse_maximum_current_limit; // DC charging
        unsigned int evse_maximum_current_limit_is_used;
        int evse_current_limit_achieved;
        struct iso2_PhysicalValueType evse_maximum_power_limit;
        unsigned int evse_maximum_power_limit_is_used;
        int evse_power_limit_achieved;
        struct iso2_PhysicalValueType evse_maximum_voltage_limit;
        unsigned int evse_maximum_voltage_limit_is_used;
        int evse_voltage_limit_achieved;
        struct iso2_PhysicalValueType evse_minimum_current_limit;
        struct iso2_PhysicalValueType evse_minimum_voltage_limit;
        struct iso2_PhysicalValueType evse_peak_current_ripple;
        struct iso2_PhysicalValueType evse_present_voltage;
        struct iso2_PhysicalValueType evse_present_current;

        /* AC only power electronic values */
        struct iso2_PhysicalValueType evse_nominal_voltage;

        // Specific SAE J2847 bidi values
        struct SAE_Bidi_Data sae_bidi_data;

    } evse_v2g_data;

    struct {
        /* V2G session values */
        iso2_paymentOptionType iso_selected_payment_option;
        long long int auth_start_timeout;
        int auth_timeout_eim;
        int auth_timeout_pnc;                                                   // for PnC
        uint8_t gen_challenge[16];                                              // for PnC
        bool verify_contract_cert_chain;                                        // for PnC
        types::authorization::CertificateStatus certificate_status;             // for PnC
        bool authorization_rejected;                                            // for PnC
        std::optional<types::authorization::ProvidedIdToken> provided_id_token; // for PnC

        bool renegotiation_required;  /* Is set to true if renegotiation is required. Only relevant for ISO */
        bool is_charging;             /* set to true if ChargeProgress is set to Start */
        uint8_t sa_schedule_tuple_id; /* selected SA schedule tuple ID*/
    } session;

    struct {
        /* EV V2G values */
        int bulk_charging_complete;
        int charging_complete;
        uint64_t received_session_id; // Is the received ev session id transmitted over the v2g header. This id shall
                                      // not change during a V2G Communication Session.

        union {
            struct din_DC_EVStatusType din_dc_ev_status;
            struct iso2_DC_EVStatusType iso2_dc_ev_status;
        };
        float ev_maximum_current_limit;
        float ev_maximum_power_limit;
        float ev_maximum_voltage_limit;
        float v2g_target_current;
        float v2g_target_voltage;
        float remaining_time_to_bulk_soc;
        float remaining_time_to_full_soc;
    } ev_v2g_data;

    bool hlc_pause_active;
};

enum mqtt_dlink_action {
    MQTT_DLINK_ACTION_ERROR,
    MQTT_DLINK_ACTION_TERMINATE,
    MQTT_DLINK_ACTION_PAUSE,
};

/**
 * High-level abstraction of an incoming TCP/TLS connection on a certain charging port.
 */
struct v2g_connection {
    pthread_t thread_id;
    struct v2g_context* ctx;

    bool is_tls_connection;

    // used for non-TLS connections
    struct {
        int socket_fd;
    } conn;

    tls::Connection* tls_connection;
    openssl::pkey_ptr* pubkey;

    ssize_t (*read)(struct v2g_connection* conn, unsigned char* buf, std::size_t count);
    ssize_t (*write)(struct v2g_connection* conn, unsigned char* buf, std::size_t count);

    /* V2GTP EXI encoding/decoding stuff */
    uint8_t* buffer;
    uint32_t payload_len;
    exi_bitstream_t stream;

    struct appHand_exiDocument handshake_req;
    struct appHand_exiDocument handshake_resp;

    union {
        struct din_exiDocument* dinEXIDocument;
        struct iso2_exiDocument* iso2EXIDocument;
    } exi_in;

    union {
        struct din_exiDocument* dinEXIDocument;
        struct iso2_exiDocument* iso2EXIDocument;
    } exi_out;

    enum mqtt_dlink_action dlink_action; /* signaled action after connection is closed */
};

#endif /* V2G_H */


// ===== v2g_ctx.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2022-2023 chargebyte GmbH
// Copyright (C) 2022-2023 Contributors to EVerest

#include <cstdlib>
#include <cstring>
#include <dirent.h>
#include <errno.h>
#include <math.h>
#include <unistd.h> // sleep

#include "log.hpp"
#include "v2g_ctx.hpp"

#include <cbv2g/iso_2/iso2_msgDefDatatypes.h>

void init_physical_value(struct iso2_PhysicalValueType* const physicalValue, iso2_unitSymbolType unit) {
    physicalValue->Multiplier = 0;
    physicalValue->Unit = unit;
    physicalValue->Value = 0;
}

// Only for AC
bool populate_physical_value(struct iso2_PhysicalValueType* pv, long long int value, iso2_unitSymbolType unit) {
    struct iso2_PhysicalValueType physic_tmp = {pv->Multiplier, pv->Unit, pv->Value}; // To restore
    pv->Unit = unit;
    pv->Multiplier = 0; // with integers, we don't need negative multipliers for precision, so start at 0

    // if the value is too large to be represented in 16 signed bits, increase the multiplier
    while ((value > INT16_MAX) || (value < INT16_MIN)) {
        pv->Multiplier++;
        value /= 10;
    }

    if ((pv->Multiplier < PHY_VALUE_MULT_MIN) || (pv->Multiplier > PHY_VALUE_MULT_MAX)) {
        memcpy(pv, &physic_tmp, sizeof(struct iso2_PhysicalValueType));
        dlog(DLOG_LEVEL_WARNING, "Physical value out of scope. Ignore value");
        return false;
    }

    pv->Value = value;

    return true;
}

void populate_physical_value_float(struct iso2_PhysicalValueType* pv, float value, uint8_t decimal_places,
                                   iso2_unitSymbolType unit) {
    if (false == populate_physical_value(pv, (long long int)value, unit)) {
        return;
    }

    if (pv->Multiplier == 0) {
        for (uint8_t idx = 0; idx < decimal_places; idx++) {
            if (((long int)(value * 10) < INT16_MAX) && ((long int)(value * 10) > INT16_MIN)) {
                pv->Multiplier--;
                value *= 10;
            }
        }
    }

    if (pv->Multiplier != -decimal_places) {
        dlog(DLOG_LEVEL_WARNING,
             "Possible precision loss while converting to physical value type, requested %i, actual %i (value %f)",
             decimal_places, -pv->Multiplier, value);
    }

    pv->Value = value;
}

static void* v2g_ctx_eventloop(void* data) {
    struct v2g_context* ctx = static_cast<struct v2g_context*>(data);

    while (!ctx->shutdown) {
        int rv;

        rv = event_base_loop(ctx->event_base, 0);
        if (rv == -1)
            break;

        /* if no events are registered, restart looping */
        if (rv == 1)
            sleep(1); /* FIXME this is bad since we actually do busy-waiting here */
    }

    return NULL;
}

static int v2g_ctx_start_events(struct v2g_context* ctx) {
    pthread_attr_t attr;
    int rv;

    /* create the thread in detached state so we don't need to join it later */
    if (pthread_attr_init(&attr) != 0) {
        dlog(DLOG_LEVEL_ERROR, "pthread_attr_init failed: %s", strerror(errno));
        return -1;
    }
    if (pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) != 0) {
        dlog(DLOG_LEVEL_ERROR, "pthread_attr_setdetachstate failed: %s", strerror(errno));
        return -1;
    }

    rv = pthread_create(&ctx->event_thread, NULL, v2g_ctx_eventloop, ctx);
    return rv ? -1 : 0;
}

void v2g_ctx_init_charging_session(struct v2g_context* const ctx, bool is_connection_terminated) {
    v2g_ctx_init_charging_state(ctx, is_connection_terminated); // Init charging state
    v2g_ctx_init_charging_values(ctx);                          // Loads the internal default config
}

void v2g_ctx_init_charging_state(struct v2g_context* const ctx, bool is_connection_terminated) {
    ctx->stop_hlc = false;
    ctx->intl_emergency_shutdown = false;
    ctx->is_connection_terminated = is_connection_terminated;
    ctx->last_v2g_msg = V2G_UNKNOWN_MSG;
    ctx->current_v2g_msg = V2G_UNKNOWN_MSG;
    ctx->state = 0; // WAIT_FOR_SESSIONSETUP
    ctx->selected_protocol = V2G_UNKNOWN_PROTOCOL;
    ctx->session.renegotiation_required = false;
    ctx->session.is_charging = false;
}

void v2g_ctx_init_charging_values(struct v2g_context* const ctx) {
    static bool initialize_once = false;
    const char init_service_name[] = {"EVCharging_Service"};

    if (ctx->hlc_pause_active != true) {
        ctx->evse_v2g_data.session_id =
            (uint64_t)0; /* store associated session id, this is zero until SessionSetupRes is sent */
    }
    ctx->evse_v2g_data.notification_max_delay = (uint32_t)0;
    ctx->evse_v2g_data.evse_isolation_status = (uint8_t)iso2_isolationLevelType_Invalid;
    ctx->evse_v2g_data.evse_isolation_status_is_used = (unsigned int)1; // Shall be used in DIN
    ctx->evse_v2g_data.evse_notification = (uint8_t)0;
    ctx->evse_v2g_data.evse_status_code[PHASE_INIT] = iso2_DC_EVSEStatusCodeType_EVSE_NotReady;
    ctx->evse_v2g_data.evse_status_code[PHASE_AUTH] = iso2_DC_EVSEStatusCodeType_EVSE_NotReady;
    ctx->evse_v2g_data.evse_status_code[PHASE_PARAMETER] = iso2_DC_EVSEStatusCodeType_EVSE_Ready; // [V2G-DC-453]
    ctx->evse_v2g_data.evse_status_code[PHASE_ISOLATION] = iso2_DC_EVSEStatusCodeType_EVSE_IsolationMonitoringActive;
    ctx->evse_v2g_data.evse_status_code[PHASE_PRECHARGE] = iso2_DC_EVSEStatusCodeType_EVSE_Ready;
    ctx->evse_v2g_data.evse_status_code[PHASE_CHARGE] = iso2_DC_EVSEStatusCodeType_EVSE_Ready;
    ctx->evse_v2g_data.evse_status_code[PHASE_WELDING] = iso2_DC_EVSEStatusCodeType_EVSE_NotReady;
    ctx->evse_v2g_data.evse_status_code[PHASE_STOP] = iso2_DC_EVSEStatusCodeType_EVSE_NotReady;
    memset(ctx->evse_v2g_data.evse_processing, iso2_EVSEProcessingType_Ongoing, PHASE_LENGTH);
    ctx->evse_v2g_data.evse_processing[PHASE_PARAMETER] = iso2_EVSEProcessingType_Finished; // Skip parameter phase

    if (ctx->hlc_pause_active != true) {
        ctx->evse_v2g_data.charge_service.ServiceCategory = iso2_serviceCategoryType_EVCharging;
        ctx->evse_v2g_data.charge_service.ServiceID = (uint16_t)1;
        memcpy(ctx->evse_v2g_data.charge_service.ServiceName.characters, init_service_name, sizeof(init_service_name));
        ctx->evse_v2g_data.charge_service.ServiceName.charactersLen = sizeof(init_service_name);
        ctx->evse_v2g_data.charge_service.ServiceName_isUsed = 0;
        // ctx->evse_v2g_data.chargeService.ServiceScope.characters
        // ctx->evse_v2g_data.chargeService.ServiceScope.charactersLen
        ctx->evse_v2g_data.charge_service.ServiceScope_isUsed = (unsigned int)0;
    }
    ctx->meter_info.meter_info_is_used = false;

    ctx->evse_v2g_data.evse_service_list.clear();
    memset(&ctx->evse_v2g_data.service_parameter_list, 0,
           sizeof(struct iso2_ServiceParameterListType) * iso2_ServiceType_8_ARRAY_SIZE);

    if (initialize_once == false) {
        ctx->evse_v2g_data.charge_service.FreeService = 0;
        std::string evse_id = std::string("DE*CBY*ETE1*234");
        strcpy(reinterpret_cast<char*>(ctx->evse_v2g_data.evse_id.bytes), evse_id.data());
        ctx->evse_v2g_data.evse_id.bytesLen = evse_id.size();
        ctx->evse_v2g_data.charge_service.SupportedEnergyTransferMode.EnergyTransferMode.array[0] =
            iso2_EnergyTransferModeType_AC_single_phase_core;
        ctx->evse_v2g_data.charge_service.SupportedEnergyTransferMode.EnergyTransferMode.arrayLen = 1;
        ctx->evse_v2g_data.date_time_now_is_used = (unsigned int)0;

        // evse power values
        init_physical_value(&ctx->evse_v2g_data.evse_current_regulation_tolerance, iso2_unitSymbolType_A);
        ctx->evse_v2g_data.evse_current_regulation_tolerance_is_used = (unsigned int)0; // optional in din
        init_physical_value(&ctx->evse_v2g_data.evse_energy_to_be_delivered, iso2_unitSymbolType_Wh);
        ctx->evse_v2g_data.evse_energy_to_be_delivered_is_used = (unsigned int)0; // optional in din
        init_physical_value(&ctx->evse_v2g_data.evse_maximum_current_limit, iso2_unitSymbolType_A);
        ctx->evse_v2g_data.evse_maximum_current_limit_is_used = (unsigned int)0;
        ctx->evse_v2g_data.evse_current_limit_achieved = (int)0;
        init_physical_value(&ctx->evse_v2g_data.evse_maximum_power_limit, iso2_unitSymbolType_W);
        ctx->evse_v2g_data.evse_maximum_power_limit_is_used = (unsigned int)0;
        ctx->evse_v2g_data.evse_power_limit_achieved = (int)0;
        init_physical_value(&ctx->evse_v2g_data.evse_maximum_voltage_limit, iso2_unitSymbolType_V);

        ctx->evse_v2g_data.evse_maximum_voltage_limit_is_used = (unsigned int)0; // mandatory
        ctx->evse_v2g_data.evse_voltage_limit_achieved = (int)0;
        init_physical_value(&ctx->evse_v2g_data.evse_minimum_current_limit, iso2_unitSymbolType_A);
        init_physical_value(&ctx->evse_v2g_data.evse_minimum_voltage_limit, iso2_unitSymbolType_V);
        init_physical_value(&ctx->evse_v2g_data.evse_peak_current_ripple, iso2_unitSymbolType_A);
        // AC evse power values
        init_physical_value(&ctx->evse_v2g_data.evse_nominal_voltage, iso2_unitSymbolType_V);
        ctx->evse_v2g_data.rcd = (int)0; // 0 if RCD has not detected an error
        ctx->contactor_is_closed = false;

        ctx->evse_v2g_data.payment_option_list[0] = iso2_paymentOptionType_ExternalPayment;
        ctx->evse_v2g_data.payment_option_list_len = (uint8_t)1; // One option must be set

        ctx->evse_v2g_data.evse_service_list.reserve(iso2_ServiceType_8_ARRAY_SIZE);
    }

    init_physical_value(&ctx->evse_v2g_data.evse_present_voltage, iso2_unitSymbolType_V);
    init_physical_value(&ctx->evse_v2g_data.evse_present_current, iso2_unitSymbolType_A);

    if (ctx->hlc_pause_active != true) {
        // SAScheduleTupleID#PMaxScheduleTupleID#Start#Duration#PMax#
        init_physical_value(&ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0]
                                 .PMaxSchedule.PMaxScheduleEntry.array[0]
                                 .PMax,
                            iso2_unitSymbolType_W);
        ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0]
            .PMaxSchedule.PMaxScheduleEntry.array[0]
            .RelativeTimeInterval.duration = (uint32_t)0;
        ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0]
            .PMaxSchedule.PMaxScheduleEntry.array[0]
            .RelativeTimeInterval.duration_isUsed = (unsigned int)1;
        ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0]
            .PMaxSchedule.PMaxScheduleEntry.array[0]
            .RelativeTimeInterval.start = (uint32_t)0;
        ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0]
            .PMaxSchedule.PMaxScheduleEntry.array[0]
            .RelativeTimeInterval_isUsed = (unsigned int)1; // Optional: In DIN/ISO it must be set to 1
        ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0]
            .PMaxSchedule.PMaxScheduleEntry.array[0]
            .TimeInterval_isUsed = (unsigned int)0;
        ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0].PMaxSchedule.PMaxScheduleEntry.arrayLen = 1;
        ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0].SalesTariff_isUsed = (unsigned int)0;
        ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0].SAScheduleTupleID =
            (uint8_t)1; // [V2G2-773]  1 to 255
        ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.arrayLen = (uint16_t)1;
        ctx->evse_v2g_data.evse_sa_schedule_list_is_used = false;

        // ctx->evse_v2g_data.evseSAScheduleTuple.SalesTariff
        ctx->evse_v2g_data.evse_sa_schedule_list.SAScheduleTuple.array[0].SalesTariff_isUsed =
            (unsigned int)0; // Not supported in DIN
    } else {
        ctx->evse_v2g_data.evse_sa_schedule_list_is_used = true;
    }
    if (ctx->evse_v2g_data.cert_install_res_b64_buffer.empty() == false) {
        ctx->evse_v2g_data.cert_install_res_b64_buffer.clear();
    }

    // AC paramter
    ctx->evse_v2g_data.rcd = (int)0; // 0 if RCD has not detected an error
    ctx->contactor_is_closed = false;
    ctx->evse_v2g_data.receipt_required = (int)0;

    // Specific SAE J2847 bidi values
    ctx->evse_v2g_data.sae_bidi_data.enabled_sae_v2g = false;
    ctx->evse_v2g_data.sae_bidi_data.enabled_sae_v2h = false;
    ctx->evse_v2g_data.sae_bidi_data.sae_v2h_minimal_soc = 20;
    ctx->evse_v2g_data.sae_bidi_data.discharging = false;

    // Init EV received v2g-data to an invalid state
    memset(&ctx->ev_v2g_data, 0xff, sizeof(ctx->ev_v2g_data));

    /* Init session values */
    if (ctx->hlc_pause_active != true) {
        ctx->session.iso_selected_payment_option = iso2_paymentOptionType_ExternalPayment;
    } else {
        ctx->evse_v2g_data.payment_option_list[0] = ctx->session.iso_selected_payment_option;
        ctx->evse_v2g_data.payment_option_list_len = (uint8_t)1; // One option must be set
    }
    memset(ctx->session.gen_challenge, 0, sizeof(ctx->session.gen_challenge));

    ctx->session.authorization_rejected = false;

    initialize_once = true;
}

struct v2g_context* v2g_ctx_create(ISO15118_chargerImplBase* p_chargerImplBase,
                                   iso15118_extensionsImplBase* p_extensions, evse_securityIntf* r_security) {
    struct v2g_context* ctx;

    // TODO There are c++ objects within v2g_context and calloc doesn't call initialisers.
    //      free() will not call destructors
    ctx = static_cast<v2g_context*>(calloc(1, sizeof(*ctx)));
    if (!ctx)
        return NULL;

    ctx->r_security = r_security;
    ctx->p_charger = p_chargerImplBase;
    ctx->p_extensions = p_extensions;

    ctx->tls_security = TLS_SECURITY_PROHIBIT; // default

    /* This evse parameter will be initialized once */
    ctx->basic_config.evse_ac_current_limit = 0.0f;

    ctx->local_tcp_addr = NULL;
    ctx->local_tls_addr = NULL;

    ctx->is_dc_charger = true;

    v2g_ctx_init_charging_session(ctx, true);

    /* interface from config file or options */
    ctx->if_name = "eth1";

    ctx->network_read_timeout = 1000;
    ctx->network_read_timeout_tls = 5000;

    ctx->sdp_socket = -1;
    ctx->tcp_socket = -1;
    ctx->tls_socket.fd = -1;
    ctx->tls_key_logging = false;
    ctx->debugMode = false;

    /* according to man page, both functions never return an error */
    evthread_use_pthreads();
    pthread_mutex_init(&ctx->mqtt_lock, NULL);
    pthread_condattr_init(&ctx->mqtt_attr);
    pthread_condattr_setclock(&ctx->mqtt_attr, CLOCK_MONOTONIC);
    pthread_cond_init(&ctx->mqtt_cond, &ctx->mqtt_attr);

    ctx->event_base = event_base_new();
    if (!ctx->event_base) {
        dlog(DLOG_LEVEL_ERROR, "event_base_new failed");
        goto free_out;
    }

    if (v2g_ctx_start_events(ctx) != 0)
        goto free_out;

    ctx->hlc_pause_active = false;

    return ctx;

free_out:
    if (ctx->event_base) {
        event_base_loopbreak(ctx->event_base);
        event_base_free(ctx->event_base);
    }
    free(ctx->local_tls_addr);
    free(ctx->local_tcp_addr);
    free(ctx);
    return NULL;
}

void v2g_ctx_free(struct v2g_context* ctx) {
    if (ctx->event_base) {
        event_base_loopbreak(ctx->event_base);
        event_base_free(ctx->event_base);
    }

    pthread_cond_destroy(&ctx->mqtt_cond);
    pthread_mutex_destroy(&ctx->mqtt_lock);

    free(ctx->local_tls_addr);
    ctx->local_tls_addr = NULL;
    free(ctx->local_tcp_addr);
    ctx->local_tcp_addr = NULL;
    free(ctx);
}

void publish_dc_ev_maximum_limits(struct v2g_context* ctx, const float& v2g_dc_ev_max_current_limit,
                                  const unsigned int& v2g_dc_ev_max_current_limit_is_used,
                                  const float& v2g_dc_ev_max_power_limit,
                                  const unsigned int& v2g_dc_ev_max_power_limit_is_used,
                                  const float& v2g_dc_ev_max_voltage_limit,
                                  const unsigned int& v2g_dc_ev_max_voltage_limit_is_used) {
    types::iso15118::DcEvMaximumLimits dc_ev_maximum_limits;
    bool publish_message = false;

    if (v2g_dc_ev_max_current_limit_is_used == (unsigned int)1) {
        dc_ev_maximum_limits.dc_ev_maximum_current_limit = v2g_dc_ev_max_current_limit;
        if (ctx->ev_v2g_data.ev_maximum_current_limit != dc_ev_maximum_limits.dc_ev_maximum_current_limit.value()) {
            ctx->ev_v2g_data.ev_maximum_current_limit = v2g_dc_ev_max_current_limit;
            publish_message = true;
        }
    }
    if (v2g_dc_ev_max_power_limit_is_used == (unsigned int)1) {
        dc_ev_maximum_limits.dc_ev_maximum_power_limit = v2g_dc_ev_max_power_limit;
        if (ctx->ev_v2g_data.ev_maximum_power_limit != v2g_dc_ev_max_power_limit) {
            ctx->ev_v2g_data.ev_maximum_power_limit = v2g_dc_ev_max_power_limit;
            publish_message = true;
        }
    }
    if (v2g_dc_ev_max_voltage_limit_is_used == (unsigned int)1) {
        dc_ev_maximum_limits.dc_ev_maximum_voltage_limit = v2g_dc_ev_max_voltage_limit;
        if (ctx->ev_v2g_data.ev_maximum_voltage_limit != dc_ev_maximum_limits.dc_ev_maximum_voltage_limit.value()) {
            ctx->ev_v2g_data.ev_maximum_voltage_limit = v2g_dc_ev_max_voltage_limit;
            publish_message = true;
        }
    }

    if (publish_message == true) {
        ctx->p_charger->publish_dc_ev_maximum_limits(dc_ev_maximum_limits);
    }
}

void publish_dc_ev_target_voltage_current(struct v2g_context* ctx, const float& v2g_dc_ev_target_voltage,
                                          const float& v2g_dc_ev_target_current) {
    if ((ctx->ev_v2g_data.v2g_target_voltage != v2g_dc_ev_target_voltage) ||
        (ctx->ev_v2g_data.v2g_target_current != v2g_dc_ev_target_current)) {
        types::iso15118::DcEvTargetValues dc_ev_target_values;
        dc_ev_target_values.dc_ev_target_voltage = v2g_dc_ev_target_voltage;
        dc_ev_target_values.dc_ev_target_current = v2g_dc_ev_target_current;

        ctx->ev_v2g_data.v2g_target_voltage = v2g_dc_ev_target_voltage;
        ctx->ev_v2g_data.v2g_target_current = v2g_dc_ev_target_current;

        ctx->p_charger->publish_dc_ev_target_voltage_current(dc_ev_target_values);
    }
}

void publish_dc_ev_remaining_time(struct v2g_context* ctx, const float& v2g_dc_ev_remaining_time_to_full_soc,
                                  const unsigned int& v2g_dc_ev_remaining_time_to_full_soc_is_used,
                                  const float& v2g_dc_ev_remaining_time_to_bulk_soc,
                                  const unsigned int& v2g_dc_ev_remaining_time_to_bulk_soc_is_used) {
    types::iso15118::DcEvRemainingTime dc_ev_remaining_time;
    const char* format = "%Y-%m-%dT%H:%M:%SZ";
    char buffer[100];
    std::time_t time_now_in_sec = time(NULL);
    bool publish_message = false;

    if (v2g_dc_ev_remaining_time_to_full_soc_is_used == (unsigned int)1) {
        if (ctx->ev_v2g_data.remaining_time_to_full_soc != v2g_dc_ev_remaining_time_to_full_soc) {
            std::time_t time_to_full_soc = time_now_in_sec + v2g_dc_ev_remaining_time_to_full_soc;
            std::strftime(buffer, sizeof(buffer), format, std::gmtime(&time_to_full_soc));
            dc_ev_remaining_time.ev_remaining_time_to_full_soc = std::string(buffer);
            ctx->ev_v2g_data.remaining_time_to_full_soc = v2g_dc_ev_remaining_time_to_full_soc;
            publish_message = true;
        }
    }
    if (v2g_dc_ev_remaining_time_to_bulk_soc_is_used == (unsigned int)1) {
        if (ctx->ev_v2g_data.remaining_time_to_bulk_soc != v2g_dc_ev_remaining_time_to_bulk_soc) {
            std::time_t time_to_bulk_soc = time_now_in_sec + v2g_dc_ev_remaining_time_to_bulk_soc;
            std::strftime(buffer, sizeof(buffer), format, std::gmtime(&time_to_bulk_soc));
            dc_ev_remaining_time.ev_remaining_time_to_full_bulk_soc = std::string(buffer);
            ctx->ev_v2g_data.remaining_time_to_bulk_soc = v2g_dc_ev_remaining_time_to_bulk_soc;
            publish_message = true;
        }
    }

    if (publish_message == true) {
        ctx->p_charger->publish_dc_ev_remaining_time(dc_ev_remaining_time);
    }
}

/*!
 * \brief log_selected_energy_transfer_type This function prints the selected energy transfer mode.
 * \param selected_energy_transfer_mode is the selected energy transfer mode
 */
void log_selected_energy_transfer_type(int selected_energy_transfer_mode) {
    if (selected_energy_transfer_mode >= iso2_EnergyTransferModeType_AC_single_phase_core &&
        selected_energy_transfer_mode <= iso2_EnergyTransferModeType_DC_unique) {
        dlog(DLOG_LEVEL_INFO, "Selected energy transfer mode: %s",
             selected_energy_transfer_mode_string[selected_energy_transfer_mode]);
    } else {
        dlog(DLOG_LEVEL_WARNING, "Selected energy transfer mode %d is invalid", selected_energy_transfer_mode);
    }
}

bool add_service_to_service_list(struct v2g_context* v2g_ctx, const struct iso2_ServiceType& evse_service,
                                 const int16_t* parameter_set_id, uint8_t parameter_set_id_len) {

    uint8_t write_idx = 0;
    bool service_found = false;

    for (const auto& service : v2g_ctx->evse_v2g_data.evse_service_list) {
        if (service.ServiceID == evse_service.ServiceID) {
            service_found = true;
            break;
        }
        write_idx++;
    }

    if (service_found == false and (v2g_ctx->evse_v2g_data.evse_service_list.size() < iso2_ServiceType_8_ARRAY_SIZE)) {
        v2g_ctx->evse_v2g_data.evse_service_list.push_back(evse_service);
    } else if (v2g_ctx->evse_v2g_data.evse_service_list.size() == iso2_ServiceType_8_ARRAY_SIZE) {
        dlog(DLOG_LEVEL_ERROR, "Maximum service list size reached. Unable to add service ID %u",
             evse_service.ServiceID);
        return false;
    }

    // Configure parameter-set-id if requiered
    for (uint8_t idx = 0; idx < parameter_set_id_len; idx++) {
        configure_parameter_set(&v2g_ctx->evse_v2g_data.service_parameter_list[write_idx], parameter_set_id[idx],
                                evse_service.ServiceID);
    }

    return true;
}

void remove_service_from_service_list_if_exists(struct v2g_context* v2g_ctx, uint16_t service_id) {
    auto& service_list = v2g_ctx->evse_v2g_data.evse_service_list;
    service_list.erase(std::remove_if(service_list.begin(), service_list.end(),
                                      [service_id](const auto service) { return service.ServiceID == service_id; }),
                       service_list.end());
}

void configure_parameter_set(struct iso2_ServiceParameterListType* parameterSetList, int16_t parameterSetId,
                             uint16_t serviceId) {

    bool parameter_set_id_found = false;
    uint8_t write_idx = 0;
    for (uint8_t idx = 0; idx < parameterSetList->ParameterSet.arrayLen; idx++) {
        if (parameterSetList->ParameterSet.array[idx].ParameterSetID == parameterSetId) {
            parameter_set_id_found = true;
            write_idx = idx;
            break;
        }
    }
    if ((parameter_set_id_found == false) &&
        (parameterSetList->ParameterSet.arrayLen < iso2_ParameterSetType_5_ARRAY_SIZE)) {
        write_idx = parameterSetList->ParameterSet.arrayLen;
        parameterSetList->ParameterSet.arrayLen++;
    } else if (parameterSetList->ParameterSet.arrayLen == iso2_ParameterSetType_5_ARRAY_SIZE) {
        dlog(DLOG_LEVEL_ERROR, "Maximum parameter-set list size reached. Unable to add parameter-set-ID %d",
             parameterSetId);
        return;
    }

    /* Get an free parameter-set-entry */
    struct iso2_ParameterSetType* parameterSet = &parameterSetList->ParameterSet.array[write_idx];
    parameterSet->ParameterSetID = parameterSetId;
    if (serviceId == 2) {
        /* Configure parameter-set-ID of the certificate service */
        /* Service to install a Contract Certificate (Ref. Table 106 â€”
         * ServiceParameterList for certificate service) */
        if (parameterSet->ParameterSetID == 1) {
            /* Configure parameter name */
            strcpy(parameterSet->Parameter.array[parameterSet->Parameter.arrayLen].Name.characters, "Service");
            parameterSet->Parameter.array[parameterSet->Parameter.arrayLen].Name.charactersLen =
                std::string(parameterSet->Parameter.array[parameterSet->Parameter.arrayLen].Name.characters).size();
            /* Configure parameter value */
            strcpy(parameterSet->Parameter.array[parameterSet->Parameter.arrayLen].stringValue.characters,
                   "Installation");
            parameterSet->Parameter.array[parameterSet->Parameter.arrayLen].stringValue.charactersLen =
                std::string(parameterSet->Parameter.array[write_idx].stringValue.characters).size();
            parameterSet->Parameter.array[parameterSet->Parameter.arrayLen].stringValue_isUsed = 1;
            parameterSet->Parameter.arrayLen = 1;
        }
        /* Service to update a Contract Certificate */
        else if (parameterSet->ParameterSetID == 2) {
            /* Configure parameter name */
            strcpy(parameterSet->Parameter.array[parameterSet->Parameter.arrayLen].Name.characters, "Service");
            parameterSet->Parameter.array[parameterSet->Parameter.arrayLen].Name.charactersLen =
                std::string(parameterSet->Parameter.array[parameterSet->Parameter.arrayLen].Name.characters).size();
            /* Configure parameter value */
            strcpy(parameterSet->Parameter.array[parameterSet->Parameter.arrayLen].stringValue.characters, "Update");
            parameterSet->Parameter.array[parameterSet->Parameter.arrayLen].stringValue.charactersLen =
                std::string(parameterSet->Parameter.array[parameterSet->Parameter.arrayLen].stringValue.characters)
                    .size();
            parameterSet->Parameter.array[parameterSet->Parameter.arrayLen].stringValue_isUsed = 1;
            parameterSet->Parameter.arrayLen = 1;
        }
    } else {
        dlog(DLOG_LEVEL_WARNING, "Parameter-set-ID of service ID %u is not supported", serviceId);
    }
}


// ===== v2g_ctx.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2022-2023 chargebyte GmbH
// Copyright (C) 2022-2023 Contributors to EVerest
#ifndef V2G_CTX_H
#define V2G_CTX_H

#include "v2g.hpp"

#include <stdbool.h>

#define PHY_VALUE_MULT_MIN  -3
#define PHY_VALUE_MULT_MAX  3
#define PHY_VALUE_VALUE_MIN SHRT_MIN
#define PHY_VALUE_VALUE_MAX SHRT_MAX

static const char* selected_energy_transfer_mode_string[] = {
    "AC_single_phase_core", "AC_three_phase_core", "DC_core", "DC_extended", "DC_combo_core", "DC_unique",
};

struct v2g_context* v2g_ctx_create(ISO15118_chargerImplBase* p_chargerImplBase,
                                   iso15118_extensionsImplBase* p_extensions, evse_securityIntf* r_security);

/*!
 * \brief v2g_ctx_init_charging_session This funcion inits a charging session.
 * \param ctx is a pointer of type \c v2g_context. It holds the charging values.
 * \param is_connection_terminated must be set to \c true if the connection is terminated.
 */
void v2g_ctx_init_charging_session(struct v2g_context* const ctx, bool is_connection_terminated);

/*!
 * \brief init_physical_value This funcion inits a physicalValue struct.
 * \param physicalValue is the struct of the physical value.
 * \param unit is the unit of the physical value.
 */
void init_physical_value(struct iso2_PhysicalValueType* const physicalValue, iso2_unitSymbolType unit);

/*!
 * \brief populate_physical_value This function fills all elements of a \c iso2_PhysicalValueType struct regarding the
 * parameter value and unit.
 * \param pv is pointer to the physical value struct
 * \param value is the physical value
 * \param unit is the unit of the physical value
 * \return Returns \c true if the convertion was succesfull, otherwise \c false.
 */
bool populate_physical_value(struct iso2_PhysicalValueType* pv, long long int value, iso2_unitSymbolType unit);

/*!
 * \brief populate_physical_value_float This function fills all elements of a \c iso2_PhysicalValueType struct from a
 * json object.
 * \param pv is pointer to the physical value struct
 * \param value is the physical value
 * \param decimal_places is to determine the precision
 * \param unit is the unit of the physical value
 */
void populate_physical_value_float(struct iso2_PhysicalValueType* pv, float value, uint8_t decimal_places,
                                   iso2_unitSymbolType unit);

/*!
 * \brief v2g_ctx_init_charging_state This function inits the charging state. This should be called afer a terminated
 * charging session.
 * \param ctx is a pointer of type \c v2g_context. It holds the charging values.
 * \param is_connection_terminated is set to \c true if the connection is terminated
 */
void v2g_ctx_init_charging_state(struct v2g_context* const ctx, bool is_connection_terminated);

/*!
 * \brief init_charging_values This function inits all charge-values (din/iso). This should be called after starting the
 * charging session.
 * \param ctx is a pointer of type \c v2g_context. It holds the charging values.
 */
void v2g_ctx_init_charging_values(struct v2g_context* const ctx);

/*!
 * \brief v2g_ctx_free
 * \param ctx
 */
void v2g_ctx_free(struct v2g_context* ctx);

/*!
 * \brief publish_dc_ev_maximum_limits This function publishes the dc_ev_maximum_limits
 * \param ctx  is a pointer of type \c v2g_context
 * \param v2g_dc_ev_max_current_limit is the EV max current limit
 * \param v2g_dc_ev_max_current_limit_is_used is set to \c true if used, otherwise \c false
 * \param v2g_dc_ev_max_power_limit is the EV max power limit
 * \param v2g_dc_ev_max_power_limit_is_used is set to \c true if used, otherwise \c false
 * \param v2g_dc_ev_max_voltage_limit is the EV max voltage limit
 * \param v2g_dc_ev_max_voltage_limit_is_used is set to \c true if used, otherwise \c false
 */
void publish_dc_ev_maximum_limits(struct v2g_context* ctx, const float& v2g_dc_ev_max_current_limit,
                                  const unsigned int& v2g_dc_ev_max_current_limit_is_used,
                                  const float& v2g_dc_ev_max_power_limit,
                                  const unsigned int& v2g_dc_ev_max_power_limit_is_used,
                                  const float& v2g_dc_ev_max_voltage_limit,
                                  const unsigned int& v2g_dc_ev_max_voltage_limit_is_used);

/*!
 * \brief publish_dc_ev_target_voltage_current This function publishes the DcEvTargetValues
 * \param ctx  is a pointer of type \c v2g_context
 * \param v2g_dc_ev_target_voltage is the EV target voltage
 * \param v2g_dc_ev_target_current is the EV target current
 */
void publish_dc_ev_target_voltage_current(struct v2g_context* ctx, const float& v2g_dc_ev_target_voltage,
                                          const float& v2g_dc_ev_target_current);

/*!
 * \brief publish_dc_ev_remaining_time This function publishes the dc_ev_remaining_time
 * \param ctx is a pointer of type \c v2g_context
 * \param iso2_dc_ev_remaining_time_to_full_soc is the EV remaining time to full soc
 * \param iso2_dc_ev_remaining_time_to_full_soc_is_used is set to \c true if used, otherwise \c false
 * \param iso2_dc_ev_remaining_time_to_bulk_soc is the EV remaining time to bulk soc
 * \param iso2_dc_ev_remaining_time_to_bulk_soc_is_used is set to \c true if used, otherwise \c false
 */
void publish_dc_ev_remaining_time(struct v2g_context* ctx, const float& iso2_dc_ev_remaining_time_to_full_soc,
                                  const unsigned int& iso2_dc_ev_remaining_time_to_full_soc_is_used,
                                  const float& iso2_dc_ev_remaining_time_to_bulk_soc,
                                  const unsigned int& iso2_dc_ev_remaining_time_to_bulk_soc_is_used);

/*!
 * \brief log_selected_energy_transfer_type This function logs the selected_energy_transfer_mode
 */
void log_selected_energy_transfer_type(int selected_energy_transfer_mode);

/*!
 * \brief add_service_to_service_list This function adds a service list item to the service list.
 * \param v2g_ctx is a pointer of type \c v2g_context
 * \param evse_service is service which shall be provided by the EVSE in the service list.
 * \param parameter_set_id is an array of optional service parameter-set-IDs
 * \param parameter_set_id_len is the array length of parameter_set_id
 * \return Returns \c true if it was successful, otherwise \c false.
 */
bool add_service_to_service_list(struct v2g_context* v2g_ctx, const struct iso2_ServiceType& evse_service,
                                 const int16_t* parameter_set_id = NULL, uint8_t parameter_set_id_len = 0);

/*!
 * \brief remove_service_from_service_list_if_exists This function removes a service list item from the service list.
 * \param v2g_ctx is a pointer of type \c v2g_context
 * \param service_id is the service which shall be removed by the EVSE in the service list.
 */
void remove_service_from_service_list_if_exists(struct v2g_context* v2g_ctx, uint16_t service_id);

/*!
 * \brief configure_parameter_set This function configures the parameter-set structure of a specific service ID.
 * \param v2g_ctx is a pointer of type \c v2g_context
 * \param parameterSetId is the parameter-set-ID which belongs to the service ID.
 * \param serviceId is the service ID. Currently only service ID 2 ("Certificate") supported.
 */
void configure_parameter_set(struct iso2_ServiceParameterListType* parameterSetList, int16_t parameterSetId,
                             uint16_t serviceId);

#endif /* V2G_CTX_H */


// ===== v2g_server.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2023 chargebyte GmbH
// Copyright (C) 2023 Contributors to EVerest
#include "v2g_server.hpp"

#include <cstdint>
#include <cstdlib>
#include <inttypes.h>
#include <string.h>
#include <unistd.h>

#include <cbv2g/app_handshake/appHand_Decoder.h>
#include <cbv2g/app_handshake/appHand_Encoder.h>
#include <cbv2g/common/exi_basetypes.h>
#include <cbv2g/din/din_msgDefDecoder.h>
#include <cbv2g/din/din_msgDefEncoder.h>
#include <cbv2g/exi_v2gtp.h>
#include <cbv2g/iso_2/iso2_msgDefDecoder.h>
#include <cbv2g/iso_2/iso2_msgDefEncoder.h>

#include "connection.hpp"
#include "din_server.hpp"
#include "iso_server.hpp"
#include "log.hpp"
#include "tools.hpp"

#define MAX_RES_TIME 98

static types::iso15118::V2gMessageId get_v2g_message_id(enum V2gMsgTypeId v2g_msg, enum v2g_protocol selected_protocol,
                                                        bool is_req) {
    switch (v2g_msg) {
    case V2G_SUPPORTED_APP_PROTOCOL_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::SupportedAppProtocolReq
                              : types::iso15118::V2gMessageId::SupportedAppProtocolRes;
    case V2G_SESSION_SETUP_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::SessionSetupReq
                              : types::iso15118::V2gMessageId::SessionSetupRes;
    case V2G_SERVICE_DISCOVERY_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::ServiceDiscoveryReq
                              : types::iso15118::V2gMessageId::ServiceDiscoveryRes;
    case V2G_SERVICE_DETAIL_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::ServiceDetailReq
                              : types::iso15118::V2gMessageId::ServiceDetailRes;
    case V2G_PAYMENT_SERVICE_SELECTION_MSG:
        return is_req == true                            ? selected_protocol == V2G_PROTO_DIN70121
                                                               ? types::iso15118::V2gMessageId::ServicePaymentSelectionReq
                                                               : types::iso15118::V2gMessageId::PaymentServiceSelectionReq
               : selected_protocol == V2G_PROTO_DIN70121 ? types::iso15118::V2gMessageId::ServicePaymentSelectionRes
                                                         : types::iso15118::V2gMessageId::PaymentServiceSelectionRes;
    case V2G_PAYMENT_DETAILS_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::PaymentDetailsReq
                              : types::iso15118::V2gMessageId::PaymentDetailsRes;
    case V2G_AUTHORIZATION_MSG:
        return is_req == true                            ? selected_protocol == V2G_PROTO_DIN70121
                                                               ? types::iso15118::V2gMessageId::ContractAuthenticationReq
                                                               : types::iso15118::V2gMessageId::AuthorizationReq
               : selected_protocol == V2G_PROTO_DIN70121 ? types::iso15118::V2gMessageId::ContractAuthenticationRes
                                                         : types::iso15118::V2gMessageId::AuthorizationRes;
    case V2G_CHARGE_PARAMETER_DISCOVERY_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::ChargeParameterDiscoveryReq
                              : types::iso15118::V2gMessageId::ChargeParameterDiscoveryRes;
    case V2G_METERING_RECEIPT_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::MeteringReceiptReq
                              : types::iso15118::V2gMessageId::MeteringReceiptRes;
    case V2G_CERTIFICATE_UPDATE_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::CertificateUpdateReq
                              : types::iso15118::V2gMessageId::CertificateUpdateRes;
    case V2G_CERTIFICATE_INSTALLATION_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::CertificateInstallationReq
                              : types::iso15118::V2gMessageId::CertificateInstallationRes;
    case V2G_CHARGING_STATUS_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::ChargingStatusReq
                              : types::iso15118::V2gMessageId::ChargingStatusRes;
    case V2G_CABLE_CHECK_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::CableCheckReq
                              : types::iso15118::V2gMessageId::CableCheckRes;
    case V2G_PRE_CHARGE_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::PreChargeReq
                              : types::iso15118::V2gMessageId::PreChargeRes;
    case V2G_POWER_DELIVERY_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::PowerDeliveryReq
                              : types::iso15118::V2gMessageId::PowerDeliveryRes;
    case V2G_CURRENT_DEMAND_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::CurrentDemandReq
                              : types::iso15118::V2gMessageId::CurrentDemandRes;
    case V2G_WELDING_DETECTION_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::WeldingDetectionReq
                              : types::iso15118::V2gMessageId::WeldingDetectionRes;
    case V2G_SESSION_STOP_MSG:
        return is_req == true ? types::iso15118::V2gMessageId::SessionStopReq
                              : types::iso15118::V2gMessageId::SessionStopRes;
    case V2G_UNKNOWN_MSG:
    default:
        return types::iso15118::V2gMessageId::UnknownMessage;
    }
}

/*!
 * \brief publish_var_V2G_Message This function fills a V2gMessages type with the V2G EXI message as HEX and Base64
 * \param conn hold the context of the V2G-connection.
 * \param is_req if it is a V2G request or response: 'true' if a request, and 'false' if a response
 */
static void publish_var_V2G_Message(v2g_connection* conn, bool is_req) {
    types::iso15118::V2gMessages v2g_message;

    u_int8_t* tempbuff = conn->buffer;
    std::string msg_as_hex_string;
    for (int i = 0; ((tempbuff != NULL) && (i < conn->payload_len + V2GTP_HEADER_LENGTH)); i++) {
        char hex[4];
        snprintf(hex, 4, "%x", *tempbuff); // to hex
        if (std::string(hex).size() == 1)
            msg_as_hex_string += '0';
        msg_as_hex_string += hex;
        tempbuff++;
    }

    std::string EXI_Base64;

    EXI_Base64 = openssl::base64_encode(conn->buffer, conn->payload_len + V2GTP_HEADER_LENGTH);
    if (EXI_Base64.size() == 0) {
        dlog(DLOG_LEVEL_WARNING, "Unable to base64 encode EXI buffer");
    }

    v2g_message.exi_base64 = EXI_Base64;
    v2g_message.id = get_v2g_message_id(conn->ctx->current_v2g_msg, conn->ctx->selected_protocol, is_req);
    v2g_message.exi = msg_as_hex_string;
    conn->ctx->p_charger->publish_v2g_messages(v2g_message);
}

/*!
 * \brief v2g_incoming_v2gtp This function reads the V2G transport header
 * \param conn hold the context of the V2G-connection.
 * \return Returns 0 if the V2G-session was successfully stopped, otherwise -1.
 */
static int v2g_incoming_v2gtp(struct v2g_connection* conn) {
    assert(conn != nullptr);
    assert(conn->read != nullptr);

    int rv;

    /* read and process header */
    rv = conn->read(conn, conn->buffer, V2GTP_HEADER_LENGTH);
    if (rv < 0) {
        dlog(DLOG_LEVEL_ERROR, "connection_read(header) failed: %s",
             (rv == -1) ? strerror(errno) : "connection terminated");
        return -1;
    }
    /* peer closed connection */
    if (rv == 0)
        return 1;
    if (rv != V2GTP_HEADER_LENGTH) {
        dlog(DLOG_LEVEL_ERROR, "connection_read(header) too short: expected %d, got %d", V2GTP_HEADER_LENGTH, rv);
        return -1;
    }

    rv = V2GTP_ReadHeader(conn->buffer, &conn->payload_len);
    if (rv == -1) {
        dlog(DLOG_LEVEL_ERROR, "Invalid v2gtp header");
        return -1;
    }

    if (conn->payload_len >= UINT32_MAX - V2GTP_HEADER_LENGTH) {
        dlog(DLOG_LEVEL_ERROR, "Prevent integer overflow - payload too long: have %d, would need %u",
             DEFAULT_BUFFER_SIZE, conn->payload_len);
        return -1;
    }

    if (conn->payload_len + V2GTP_HEADER_LENGTH > DEFAULT_BUFFER_SIZE) {
        dlog(DLOG_LEVEL_ERROR, "payload too long: have %d, would need %u", DEFAULT_BUFFER_SIZE,
             conn->payload_len + V2GTP_HEADER_LENGTH);

        /* we have no way to flush/discard remaining unread data from the socket without reading it in chunks,
         * but this opens the chance to bind us in a "endless" read loop; so to protect us, simply close the connection
         */

        return -1;
    }
    /* read request */
    rv = conn->read(conn, &conn->buffer[V2GTP_HEADER_LENGTH], conn->payload_len);
    if (rv < 0) {
        dlog(DLOG_LEVEL_ERROR, "connection_read(payload) failed: %s",
             (rv == -1) ? strerror(errno) : "connection terminated");
        return -1;
    }
    if (rv != conn->payload_len) {
        dlog(DLOG_LEVEL_ERROR, "connection_read(payload) too short: expected %d, got %d", conn->payload_len, rv);
        return -1;
    }
    /* adjust buffer pos to decode request */
    conn->stream.byte_pos = V2GTP_HEADER_LENGTH;
    conn->stream.data_size = conn->payload_len + V2GTP_HEADER_LENGTH;

    return 0;
}

/*!
 * \brief v2g_outgoing_v2gtp This function creates the v2g transport header
 * \param conn hold the context of the v2g-connection.
 * \return Returns 0 if the v2g-session was successfully stopped, otherwise -1.
 */
int v2g_outgoing_v2gtp(struct v2g_connection* conn) {
    assert(conn != nullptr);
    assert(conn->write != nullptr);

    /* fixup/create header */
    const auto len = exi_bitstream_get_length(&conn->stream);

    V2GTP_WriteHeader(conn->buffer, len - V2GTP_HEADER_LENGTH);

    if (conn->write(conn, conn->buffer, len) == -1) {
        dlog(DLOG_LEVEL_ERROR, "connection_write(header) failed: %s", strerror(errno));
        return -1;
    }

    return 0;
}

/*!
 * \brief v2g_handle_apphandshake After receiving a supportedAppProtocolReq message,
 * the SECC shall process the received information. DIN [V2G-DC-436] ISO [V2G2-540]
 * \param conn hold the context of the v2g-connection.
 * \return Returns a v2g-event of type enum v2g_event.
 */
static enum v2g_event v2g_handle_apphandshake(struct v2g_connection* conn) {
    enum v2g_event next_event = V2G_EVENT_NO_EVENT;
    int i;
    uint8_t ev_app_priority = 20; // lowest priority

    /* validate handshake request and create response */
    init_appHand_exiDocument(&conn->handshake_resp);
    conn->handshake_resp.supportedAppProtocolRes_isUsed = 1;
    conn->handshake_resp.supportedAppProtocolRes.ResponseCode =
        appHand_responseCodeType_Failed_NoNegotiation; // [V2G2-172]

    dlog(DLOG_LEVEL_INFO, "Handling SupportedAppProtocolReq");
    conn->ctx->current_v2g_msg = V2G_SUPPORTED_APP_PROTOCOL_MSG;

    if (decode_appHand_exiDocument(&conn->stream, &conn->handshake_req) != 0) {
        dlog(DLOG_LEVEL_ERROR, "decode_appHandExiDocument() failed");
        return V2G_EVENT_TERMINATE_CONNECTION; // If the mesage can't be decoded we have to terminate the tcp-connection
                                               // (e.g. after an unexpected message)
    }

    types::iso15118::AppProtocols app_protocols; // to publish supported app protocol array

    for (i = 0; i < conn->handshake_req.supportedAppProtocolReq.AppProtocol.arrayLen; i++) {
        struct appHand_AppProtocolType* app_proto = &conn->handshake_req.supportedAppProtocolReq.AppProtocol.array[i];
        char* proto_ns = strndup(static_cast<const char*>(app_proto->ProtocolNamespace.characters),
                                 app_proto->ProtocolNamespace.charactersLen);

        if (!proto_ns) {
            dlog(DLOG_LEVEL_ERROR, "out-of-memory condition");
            return V2G_EVENT_TERMINATE_CONNECTION;
        }

        dlog(DLOG_LEVEL_TRACE,
             "handshake_req: Namespace: %s, Version: %" PRIu32 ".%" PRIu32 ", SchemaID: %" PRIu8 ", Priority: %" PRIu8,
             proto_ns, app_proto->VersionNumberMajor, app_proto->VersionNumberMinor, app_proto->SchemaID,
             app_proto->Priority);

        if ((conn->ctx->supported_protocols & (1 << V2G_PROTO_DIN70121)) &&
            (strcmp(proto_ns, DIN_70121_MSG_DEF) == 0) && (app_proto->VersionNumberMajor == DIN_70121_MAJOR) &&
            (ev_app_priority >= app_proto->Priority)) {
            conn->handshake_resp.supportedAppProtocolRes.ResponseCode =
                appHand_responseCodeType_OK_SuccessfulNegotiation;
            ev_app_priority = app_proto->Priority;
            conn->handshake_resp.supportedAppProtocolRes.SchemaID = app_proto->SchemaID;
            conn->ctx->selected_protocol = V2G_PROTO_DIN70121;
        } else if ((conn->ctx->supported_protocols & (1 << V2G_PROTO_ISO15118_2013)) &&
                   (strcmp(proto_ns, ISO_15118_2013_MSG_DEF) == 0) &&
                   (app_proto->VersionNumberMajor == ISO_15118_2013_MAJOR) &&
                   (ev_app_priority >= app_proto->Priority)) {

            conn->handshake_resp.supportedAppProtocolRes.ResponseCode =
                appHand_responseCodeType_OK_SuccessfulNegotiationWithMinorDeviation;
            ev_app_priority = app_proto->Priority;
            conn->handshake_resp.supportedAppProtocolRes.SchemaID = app_proto->SchemaID;
            conn->ctx->selected_protocol = V2G_PROTO_ISO15118_2013;
        }

        if (conn->ctx->debugMode == true) {
            const types::iso15118::AppProtocol protocol = {
                std::string(proto_ns), static_cast<int32_t>(app_proto->VersionNumberMajor),
                static_cast<int32_t>(app_proto->VersionNumberMinor), static_cast<int32_t>(app_proto->SchemaID),
                static_cast<int32_t>(app_proto->Priority)};

            app_protocols.Protocols.push_back(protocol);
        }

        // TODO: ISO15118v2
        free(proto_ns);
    }

    if (conn->ctx->debugMode == true) {
        conn->ctx->p_charger->publish_ev_app_protocol(app_protocols);
        /* form the content of V2G_Message type and publish the request*/
        publish_var_V2G_Message(conn, true);
    }

    std::string selected_protocol_str;
    if (conn->handshake_resp.supportedAppProtocolRes.ResponseCode ==
            appHand_responseCodeType_OK_SuccessfulNegotiation ||
        conn->handshake_resp.supportedAppProtocolRes.ResponseCode ==
            appHand_responseCodeType_OK_SuccessfulNegotiationWithMinorDeviation) {
        conn->handshake_resp.supportedAppProtocolRes.SchemaID_isUsed = (unsigned int)1;
        if (V2G_PROTO_DIN70121 == conn->ctx->selected_protocol) {
            dlog(DLOG_LEVEL_INFO, "Protocol negotiation was successful. Selected protocol is DIN70121");
            selected_protocol_str = "DIN70121";
        } else if (V2G_PROTO_ISO15118_2013 == conn->ctx->selected_protocol) {
            dlog(DLOG_LEVEL_INFO, "Protocol negotiation was successful. Selected protocol is ISO15118");
            selected_protocol_str = "ISO15118-2-2013";
        } else if (V2G_PROTO_ISO15118_2010 == conn->ctx->selected_protocol) {
            dlog(DLOG_LEVEL_INFO, "Protocol negotiation was successful. Selected protocol is ISO15118-2010");
            selected_protocol_str = "ISO15118-2-2010";
        }
    } else {
        dlog(DLOG_LEVEL_ERROR, "No compatible protocol found");
        selected_protocol_str = "None";
        next_event = V2G_EVENT_SEND_AND_TERMINATE; // Send response and terminate tcp-connection
    }

    if (conn->ctx->debugMode == true) {
        conn->ctx->p_charger->publish_selected_protocol(selected_protocol_str);
    }

    if (conn->ctx->is_connection_terminated == true) {
        dlog(DLOG_LEVEL_ERROR, "Connection is terminated. Abort charging");
        return V2G_EVENT_TERMINATE_CONNECTION; // Abort charging without sending a response
    }

    /* Validate response code */
    if ((conn->ctx->intl_emergency_shutdown == true) || (conn->ctx->stop_hlc == true) ||
        (V2G_EVENT_SEND_AND_TERMINATE == next_event)) {
        conn->handshake_resp.supportedAppProtocolRes.ResponseCode = appHand_responseCodeType_Failed_NoNegotiation;
        dlog(DLOG_LEVEL_ERROR, "Abort charging session");

        if (conn->ctx->terminate_connection_on_failed_response == true) {
            next_event = V2G_EVENT_SEND_AND_TERMINATE; // send response and terminate the TCP-connection
        }
    }

    /* encode response at the right buffer location */
    conn->stream.byte_pos = V2GTP_HEADER_LENGTH;
    conn->stream.bit_count = 0;

    if (encode_appHand_exiDocument(&conn->stream, &conn->handshake_resp) != 0) {
        dlog(DLOG_LEVEL_ERROR, "Encoding of the protocol handshake message failed");
        next_event = V2G_EVENT_SEND_AND_TERMINATE;
    }

    return next_event;
}

int v2g_handle_connection(struct v2g_connection* conn) {
    int rv = -1;
    enum v2g_event rvAppHandshake = V2G_EVENT_NO_EVENT;
    bool stop_receiving_loop = false;
    int64_t start_time = 0; // in ms

    enum v2g_protocol selected_protocol = V2G_UNKNOWN_PROTOCOL;
    v2g_ctx_init_charging_state(conn->ctx, false);
    conn->buffer = static_cast<uint8_t*>(malloc(DEFAULT_BUFFER_SIZE));
    if (!conn->buffer)
        return -1;

    /* static setup */
    conn->stream.data = conn->buffer;

    /* Here is a good point to wait until the customer is ready for a resumed session,
     * because we are waiting for the incoming message of the ev */
    if (conn->dlink_action == MQTT_DLINK_ACTION_PAUSE) {
        // TODO: D_LINK pause
    }

    do {
        /* setup for receive */
        conn->stream.data[0] = 0;
        conn->payload_len = 0;
        exi_bitstream_init(&conn->stream, conn->buffer, 0, 0, nullptr);

        /* next call return -1 on error, 1 when peer closed connection, 0 on success */
        rv = v2g_incoming_v2gtp(conn);

        if (rv != 0) {
            dlog(DLOG_LEVEL_ERROR, "v2g_incoming_v2gtp() failed");
            goto error_out;
        }

        if (conn->ctx->is_connection_terminated == true) {
            rv = -1;
            goto error_out;
        }

        /* next call return -1 on non-recoverable errors, 1 on recoverable errors, 0 on success */
        rvAppHandshake = v2g_handle_apphandshake(conn);

        if (rvAppHandshake == V2G_EVENT_IGNORE_MSG) {
            dlog(DLOG_LEVEL_WARNING, "v2g_handle_apphandshake() failed, ignoring packet");
        }
    } while ((rv == 1) && (rvAppHandshake == V2G_EVENT_IGNORE_MSG));

    /* stream setup for sending is done within v2g_handle_apphandshake */
    /* send supportedAppRes message */
    if ((rvAppHandshake == V2G_EVENT_SEND_AND_TERMINATE) || (rvAppHandshake == V2G_EVENT_NO_EVENT)) {
        /* form the content of V2G_Message type and publish the response for debugging*/
        if (conn->ctx->debugMode == true) {
            publish_var_V2G_Message(conn, false);
        }

        rv = v2g_outgoing_v2gtp(conn);

        if (rv == -1) {
            dlog(DLOG_LEVEL_ERROR, "v2g_outgoing_v2gtp() failed");
            goto error_out;
        }
    }

    /* terminate connection, if supportedApp handshake has failed */
    if ((rvAppHandshake == V2G_EVENT_SEND_AND_TERMINATE) || (rvAppHandshake == V2G_EVENT_TERMINATE_CONNECTION)) {
        rv = -1;
        goto error_out;
    }

    /* Backup the selected protocol, because this value is shared and can be reseted while unplugging. */
    selected_protocol = conn->ctx->selected_protocol;

    /* allocate in/out documents dynamically */
    switch (selected_protocol) {
    case V2G_PROTO_DIN70121:
    case V2G_PROTO_ISO15118_2010:
        conn->exi_in.dinEXIDocument = static_cast<struct din_exiDocument*>(calloc(1, sizeof(struct din_exiDocument)));
        if (conn->exi_in.dinEXIDocument == NULL) {
            dlog(DLOG_LEVEL_ERROR, "out-of-memory");
            goto error_out;
        }
        conn->exi_out.dinEXIDocument = static_cast<struct din_exiDocument*>(calloc(1, sizeof(struct din_exiDocument)));
        if (conn->exi_out.dinEXIDocument == NULL) {
            dlog(DLOG_LEVEL_ERROR, "out-of-memory");
            goto error_out;
        }
        break;
    case V2G_PROTO_ISO15118_2013:
        conn->exi_in.iso2EXIDocument =
            static_cast<struct iso2_exiDocument*>(calloc(1, sizeof(struct iso2_exiDocument)));
        if (conn->exi_in.iso2EXIDocument == NULL) {
            dlog(DLOG_LEVEL_ERROR, "out-of-memory");
            goto error_out;
        }
        conn->exi_out.iso2EXIDocument =
            static_cast<struct iso2_exiDocument*>(calloc(1, sizeof(struct iso2_exiDocument)));
        if (conn->exi_out.iso2EXIDocument == NULL) {
            dlog(DLOG_LEVEL_ERROR, "out-of-memory");
            goto error_out;
        }
        break;
    default:
        goto error_out; //     if protocol is unknown
    }

    do {
        /* setup for receive */
        conn->stream.data[0] = 0;
        conn->stream.bit_count = 0;
        conn->stream.byte_pos = 0;
        conn->payload_len = 0;

        /* next call return -1 on error, 1 when peer closed connection, 0 on success */
        rv = v2g_incoming_v2gtp(conn);

        if (rv == 1) {
            dlog(DLOG_LEVEL_ERROR, "Timeout waiting for next request or peer closed connection");
            break;
        } else if (rv == -1) {
            dlog(DLOG_LEVEL_ERROR, "v2g_incoming_v2gtp() (previous message \"%s\") failed",
                 v2g_msg_type[conn->ctx->last_v2g_msg]);
            break;
        }

        start_time = getmonotonictime(); // To calc the duration of req msg configuration

        /* according to agreed protocol decode the stream */
        enum v2g_event v2gEvent = V2G_EVENT_NO_EVENT;
        switch (selected_protocol) {
        case V2G_PROTO_DIN70121:
        case V2G_PROTO_ISO15118_2010:
            memset(conn->exi_in.dinEXIDocument, 0, sizeof(struct din_exiDocument));
            rv = decode_din_exiDocument(&conn->stream, conn->exi_in.dinEXIDocument);
            if (rv != 0) {
                dlog(DLOG_LEVEL_ERROR, "decode_dinExiDocument() (previous message \"%s\") failed: %d",
                     v2g_msg_type[conn->ctx->last_v2g_msg], rv);
                /* we must ignore packet which we cannot decode, so reset rv to zero to stay in loop */
                rv = 0;
                v2gEvent = V2G_EVENT_IGNORE_MSG;
                break;
            }

            memset(conn->exi_out.dinEXIDocument, 0, sizeof(struct din_exiDocument));

            v2gEvent = din_handle_request(conn);
            break;

        case V2G_PROTO_ISO15118_2013:
            memset(conn->exi_in.iso2EXIDocument, 0, sizeof(struct iso2_exiDocument));
            rv = decode_iso2_exiDocument(&conn->stream, conn->exi_in.iso2EXIDocument);
            if (rv != 0) {
                dlog(DLOG_LEVEL_ERROR, "decode_iso2_exiDocument() (previous message \"%s\") failed: %d",
                     v2g_msg_type[conn->ctx->last_v2g_msg], rv);
                /* we must ignore packet which we cannot decode, so reset rv to zero to stay in loop */
                rv = 0;
                v2gEvent = V2G_EVENT_IGNORE_MSG;
                break;
            }
            conn->stream.byte_pos = 0; // Reset pos for the case if exi msg will be configured over mqtt
            memset(conn->exi_out.iso2EXIDocument, 0, sizeof(struct iso2_exiDocument));

            v2gEvent = iso_handle_request(conn);

            break;
        default:
            goto error_out; //     if protocol is unknown
        }

        /* form the content of V2G_Message type and publish the request*/
        if (conn->ctx->debugMode == true) {
            publish_var_V2G_Message(conn, true);
        }

        switch (v2gEvent) {
        case V2G_EVENT_SEND_AND_TERMINATE:
            stop_receiving_loop = true;
        case V2G_EVENT_NO_EVENT: { // fall-through intended
            /* Reset v2g-buffer */
            conn->stream.data[0] = 0;
            conn->stream.bit_count = 0;
            conn->stream.byte_pos = V2GTP_HEADER_LENGTH;
            conn->stream.data_size = DEFAULT_BUFFER_SIZE;

            /* Configure msg and send */
            switch (selected_protocol) {
            case V2G_PROTO_DIN70121:
            case V2G_PROTO_ISO15118_2010:
                if ((rv = encode_din_exiDocument(&conn->stream, conn->exi_out.dinEXIDocument)) != 0) {
                    dlog(DLOG_LEVEL_ERROR, "encode_dinExiDocument() (message \"%s\") failed: %d",
                         v2g_msg_type[conn->ctx->current_v2g_msg], rv);
                }
                break;
            case V2G_PROTO_ISO15118_2013:
                if ((rv = encode_iso2_exiDocument(&conn->stream, conn->exi_out.iso2EXIDocument)) != 0) {
                    dlog(DLOG_LEVEL_ERROR, "encode_iso2_exiDocument() (message \"%s\") failed: %d",
                         v2g_msg_type[conn->ctx->current_v2g_msg], rv);
                }
                break;
            default:
                goto error_out; //     if protocol is unknown
            }
            /* Wait max. res-time before sending the next response */
            int64_t time_to_conf_res = getmonotonictime() - start_time;

            if (time_to_conf_res < MAX_RES_TIME) {
                // dlog(DLOG_LEVEL_ERROR,"time_to_conf_res %llu", time_to_conf_res);
                std::this_thread::sleep_for(std::chrono::microseconds((MAX_RES_TIME - time_to_conf_res) * 1000));
            } else {
                dlog(DLOG_LEVEL_WARNING, "Response message (type %d) not configured within %d ms (took %" PRIi64 " ms)",
                     conn->ctx->current_v2g_msg, MAX_RES_TIME, time_to_conf_res);
            }
        }
        case V2G_EVENT_SEND_RECV_EXI_MSG: { // fall-through intended
            /* form the content of V2G_Message type and publish the response for debugging*/
            if (conn->ctx->debugMode == true) {
                publish_var_V2G_Message(conn, false);
            }

            /* Write header and send next res-msg */
            if ((rv != 0) || ((rv = v2g_outgoing_v2gtp(conn)) == -1)) {
                dlog(DLOG_LEVEL_ERROR, "v2g_outgoing_v2gtp() \"%s\" failed: %d",
                     v2g_msg_type[conn->ctx->current_v2g_msg], rv);
                break;
            }
            break;
        }
        case V2G_EVENT_IGNORE_MSG:
            dlog(DLOG_LEVEL_ERROR, "Ignoring V2G request message \"%s\". Waiting for next request",
                 v2g_msg_type[conn->ctx->current_v2g_msg]);
            break;
        case V2G_EVENT_TERMINATE_CONNECTION: // fall-through intended
        default:
            dlog(DLOG_LEVEL_ERROR, "Failed to handle V2G request message \"%s\"",
                 v2g_msg_type[conn->ctx->current_v2g_msg]);
            stop_receiving_loop = true;
            break;
        }
    } while ((rv == 0) && (stop_receiving_loop == false));

error_out:
    switch (selected_protocol) {
    case V2G_PROTO_DIN70121:
    case V2G_PROTO_ISO15118_2010:
        if (conn->exi_in.dinEXIDocument != NULL)
            free(conn->exi_in.dinEXIDocument);
        if (conn->exi_out.dinEXIDocument != NULL)
            free(conn->exi_out.dinEXIDocument);
        break;
    case V2G_PROTO_ISO15118_2013:
        if (conn->exi_in.iso2EXIDocument != NULL)
            free(conn->exi_in.iso2EXIDocument);
        if (conn->exi_out.iso2EXIDocument != NULL)
            free(conn->exi_out.iso2EXIDocument);
        break;
    default:
        break;
    }

    if (conn->buffer != NULL) {
        free(conn->buffer);
    }

    v2g_ctx_init_charging_state(conn->ctx, true);

    return rv ? -1 : 0;
}

uint64_t v2g_session_id_from_exi(bool is_iso, void* exi_in) {
    uint64_t session_id = 0;

    if (is_iso) {
        struct iso2_exiDocument* req = static_cast<struct iso2_exiDocument*>(exi_in);
        struct iso2_MessageHeaderType* hdr = &req->V2G_Message.Header;

        /* the provided session id could be smaller (error) in case that the peer did not
         * send our full session id back to us; this is why we init the id with 0 above
         * and only copy the provided byte len
         */
        memcpy(&session_id, &hdr->SessionID.bytes, std::min((int)sizeof(session_id), (int)hdr->SessionID.bytesLen));
    } else {
        struct din_exiDocument* req = static_cast<struct din_exiDocument*>(exi_in);
        struct din_MessageHeaderType* hdr = &req->V2G_Message.Header;

        /* see comment above */
        memcpy(&session_id, &hdr->SessionID.bytes, std::min((int)sizeof(session_id), (int)hdr->SessionID.bytesLen));
    }

    return session_id;
}


// ===== v2g_server.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright (C) 2023 chargebyte GmbH
// Copyright (C) 2023 Contributors to EVerest
#ifndef V2G_SERVER_H
#define V2G_SERVER_H

#include "v2g.hpp"

static const char* v2g_msg_type[] = {
    "Supported App Protocol",
    "Session Setup",
    "Service Discovery",
    "Service Detail",
    "Payment Service Selection",
    "Payment Details",
    "Authorization",
    "Charge Parameter Discovery",
    "Metering Receipt",
    "Certificate Update",
    "Certificate Installation",
    "Charging Status",
    "Cable Check",
    "Pre Charge",
    "Power Delivery",
    "Current Demand",
    "Welding Detection",
    "Session Stop",
    "Unknown",
};

/*!
 * \brief v2g_handle_connection This function handles a v2g-charging-session.
 * \param conn hold the context of the v2g-connection.
 * \return Returns 0 if the v2g-session was successfully stopped, otherwise -1.
 */
int v2g_handle_connection(struct v2g_connection* conn);

/*!
 * \brief v2g_session_id_from_exi This function extracts session ID from an EXI stream.
 * \param is_iso determines if ISO or DIN should be handled.
 * \param exi_in holds the input EXI stream.
 * \return Returns the extracted session ID.
 */
uint64_t v2g_session_id_from_exi(bool is_iso, void* exi_in);

#endif /* V2G_SERVER_H */


